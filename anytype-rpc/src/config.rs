use std::env;
use std::fmt;
use std::fs;
use std::path::{Path, PathBuf};

use serde::Deserialize;

/// Headless CLI config.json fields relevant for gRPC auth.
#[derive(Debug, Default, Deserialize)]
pub struct AnytypeHeadlessConfig {
    #[serde(rename = "accountKey")]
    pub account_key: Option<String>,
    #[serde(rename = "sessionToken")]
    pub session_token: Option<String>,
}

#[derive(Debug)]
pub enum AnytypeConfigError {
    Io(std::io::Error),
    Parse(serde_json::Error),
    MissingHome,
}

impl fmt::Display for AnytypeConfigError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AnytypeConfigError::Io(err) => write!(f, "config io error: {err}"),
            AnytypeConfigError::Parse(err) => write!(f, "config parse error: {err}"),
            AnytypeConfigError::MissingHome => write!(f, "HOME environment variable not set"),
        }
    }
}

impl std::error::Error for AnytypeConfigError {}

impl From<std::io::Error> for AnytypeConfigError {
    fn from(err: std::io::Error) -> Self {
        AnytypeConfigError::Io(err)
    }
}

impl From<serde_json::Error> for AnytypeConfigError {
    fn from(err: serde_json::Error) -> Self {
        AnytypeConfigError::Parse(err)
    }
}

pub fn default_headless_config_path() -> Result<PathBuf, AnytypeConfigError> {
    let home = env::var("HOME").map_err(|_| AnytypeConfigError::MissingHome)?;
    Ok(PathBuf::from(home).join(".anytype").join("config.json"))
}

/// load configuration file generated by the headless server.
/// Data from this file can be used to generate a grpc auth token
pub fn load_headless_config(
    path: Option<&Path>,
) -> Result<Option<AnytypeHeadlessConfig>, AnytypeConfigError> {
    let path = match path {
        Some(path) => path.to_path_buf(),
        None => default_headless_config_path()?,
    };

    if !path.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&path)?;
    let config = serde_json::from_str(&content)?;
    Ok(Some(config))
}
