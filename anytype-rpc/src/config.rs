use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use serde::Deserialize;

pub use crate::error::ConfigError;

/// Headless CLI config.json fields relevant for gRPC auth.
#[derive(Debug, Default, Deserialize)]
pub struct AnytypeHeadlessConfig {
    #[serde(default, rename = "accountKey")]
    pub account_key: Option<String>,

    #[serde(default, rename = "sessionToken")]
    pub session_token: Option<String>,

    #[serde(default, rename = "accountId")]
    pub account_id: Option<String>,
}

pub fn default_headless_config_path() -> Result<PathBuf, ConfigError> {
    let home = env::var("HOME").map_err(|_| ConfigError::MissingHome)?;
    Ok(PathBuf::from(home).join(".anytype").join("config.json"))
}

/// load configuration file generated by the headless server.
/// Data from this file can be used to generate a grpc auth token
pub fn load_headless_config(
    path: Option<&Path>,
) -> Result<Option<AnytypeHeadlessConfig>, ConfigError> {
    let path = match path {
        Some(path) => path.to_path_buf(),
        None => default_headless_config_path()?,
    };

    if !path.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&path)?;
    let config = serde_json::from_str(&content)?;
    Ok(Some(config))
}
