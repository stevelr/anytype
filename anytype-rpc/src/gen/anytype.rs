// This file is @generated by prost-build.
/// Event â€“ type of message, that could be sent from a middleware to the
/// corresponding front-end.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<event::Message>,
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub initiator: ::core::option::Option<crate::model::Account>,
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Event`.
pub mod event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Message {
        #[prost(string, tag = "132")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(
            oneof = "message::Value",
            tags = "1, 201, 202, 203, 204, 205, 16, 50, 51, 52, 53, 54, 65, 55, 60, 61, 62, 63, 64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 17, 21, 25, 36, 37, 40, 19, 20, 29, 35, 38, 39, 124, 123, 125, 126, 127, 24, 23, 31, 32, 33, 34, 100, 101, 102, 103, 110, 111, 112, 113, 118, 114, 115, 116, 117, 137, 119, 120, 121, 128, 129, 130, 134, 135, 136, 131, 133, 138, 139"
        )]
        pub value: ::core::option::Option<message::Value>,
    }
    /// Nested message and enum types in `Message`.
    pub mod message {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            AccountShow(super::account::Show),
            #[prost(message, tag = "201")]
            AccountDetails(super::account::Details),
            #[prost(message, tag = "202")]
            AccountConfigUpdate(super::account::config::Update),
            #[prost(message, tag = "203")]
            AccountUpdate(super::account::Update),
            #[prost(message, tag = "204")]
            AccountLinkChallenge(super::account::LinkChallenge),
            #[prost(message, tag = "205")]
            AccountLinkChallengeHide(super::account::LinkChallengeHide),
            #[prost(message, tag = "16")]
            ObjectDetailsSet(super::object::details::Set),
            #[prost(message, tag = "50")]
            ObjectDetailsAmend(super::object::details::Amend),
            #[prost(message, tag = "51")]
            ObjectDetailsUnset(super::object::details::Unset),
            #[prost(message, tag = "52")]
            ObjectRelationsAmend(super::object::relations::Amend),
            #[prost(message, tag = "53")]
            ObjectRelationsRemove(super::object::relations::Remove),
            #[prost(message, tag = "54")]
            ObjectRemove(super::object::Remove),
            #[prost(message, tag = "65")]
            ObjectClose(super::object::Close),
            #[prost(message, tag = "55")]
            ObjectRestrictionsSet(super::object::restrictions::Set),
            #[prost(message, tag = "60")]
            SubscriptionAdd(super::object::subscription::Add),
            #[prost(message, tag = "61")]
            SubscriptionRemove(super::object::subscription::Remove),
            #[prost(message, tag = "62")]
            SubscriptionPosition(super::object::subscription::Position),
            #[prost(message, tag = "63")]
            SubscriptionCounters(super::object::subscription::Counters),
            #[prost(message, tag = "64")]
            SubscriptionGroups(super::object::subscription::Groups),
            #[prost(message, tag = "2")]
            BlockAdd(super::block::Add),
            #[prost(message, tag = "3")]
            BlockDelete(super::block::Delete),
            #[prost(message, tag = "4")]
            FilesUpload(super::block::FilesUpload),
            #[prost(message, tag = "5")]
            MarksInfo(super::block::MarksInfo),
            #[prost(message, tag = "6")]
            BlockSetFields(super::block::set::Fields),
            #[prost(message, tag = "7")]
            BlockSetChildrenIds(super::block::set::ChildrenIds),
            #[prost(message, tag = "8")]
            BlockSetRestrictions(super::block::set::Restrictions),
            #[prost(message, tag = "9")]
            BlockSetBackgroundColor(super::block::set::BackgroundColor),
            #[prost(message, tag = "10")]
            BlockSetText(super::block::set::Text),
            #[prost(message, tag = "11")]
            BlockSetFile(super::block::set::File),
            #[prost(message, tag = "13")]
            BlockSetLink(super::block::set::Link),
            #[prost(message, tag = "14")]
            BlockSetBookmark(super::block::set::Bookmark),
            #[prost(message, tag = "15")]
            BlockSetAlign(super::block::set::Align),
            #[prost(message, tag = "17")]
            BlockSetDiv(super::block::set::Div),
            #[prost(message, tag = "21")]
            BlockSetRelation(super::block::set::Relation),
            #[prost(message, tag = "25")]
            BlockSetLatex(super::block::set::Latex),
            #[prost(message, tag = "36")]
            BlockSetVerticalAlign(super::block::set::VerticalAlign),
            #[prost(message, tag = "37")]
            BlockSetTableRow(super::block::set::TableRow),
            #[prost(message, tag = "40")]
            BlockSetWidget(super::block::set::Widget),
            #[prost(message, tag = "19")]
            BlockDataviewViewSet(super::block::dataview::ViewSet),
            #[prost(message, tag = "20")]
            BlockDataviewViewDelete(super::block::dataview::ViewDelete),
            #[prost(message, tag = "29")]
            BlockDataviewViewOrder(super::block::dataview::ViewOrder),
            /// deprecated, source is no longer used
            #[prost(message, tag = "35")]
            BlockDataviewSourceSet(super::block::dataview::SourceSet),
            #[prost(message, tag = "38")]
            BlockDataViewGroupOrderUpdate(super::block::dataview::GroupOrderUpdate),
            #[prost(message, tag = "39")]
            BlockDataViewObjectOrderUpdate(super::block::dataview::ObjectOrderUpdate),
            #[prost(message, tag = "124")]
            BlockDataviewRelationDelete(super::block::dataview::RelationDelete),
            #[prost(message, tag = "123")]
            BlockDataviewRelationSet(super::block::dataview::RelationSet),
            #[prost(message, tag = "125")]
            BlockDataviewViewUpdate(super::block::dataview::ViewUpdate),
            #[prost(message, tag = "126")]
            BlockDataviewTargetObjectIdSet(super::block::dataview::TargetObjectIdSet),
            #[prost(message, tag = "127")]
            BlockDataviewIsCollectionSet(super::block::dataview::IsCollectionSet),
            /// deprecated
            #[prost(message, tag = "24")]
            BlockDataviewOldRelationDelete(super::block::dataview::OldRelationDelete),
            /// deprecated
            #[prost(message, tag = "23")]
            BlockDataviewOldRelationSet(super::block::dataview::OldRelationSet),
            #[prost(message, tag = "31")]
            UserBlockJoin(super::user::block::Join),
            #[prost(message, tag = "32")]
            UserBlockLeft(super::user::block::Left),
            #[prost(message, tag = "33")]
            UserBlockSelectRange(super::user::block::SelectRange),
            #[prost(message, tag = "34")]
            UserBlockTextRange(super::user::block::TextRange),
            #[prost(message, tag = "100")]
            Ping(super::Ping),
            #[prost(message, tag = "101")]
            ProcessNew(super::process::New),
            #[prost(message, tag = "102")]
            ProcessUpdate(super::process::Update),
            #[prost(message, tag = "103")]
            ProcessDone(super::process::Done),
            #[prost(message, tag = "110")]
            ThreadStatus(super::status::Thread),
            #[prost(message, tag = "111")]
            FileLimitReached(super::file::LimitReached),
            #[prost(message, tag = "112")]
            FileSpaceUsage(super::file::SpaceUsage),
            #[prost(message, tag = "113")]
            FileLocalUsage(super::file::LocalUsage),
            #[prost(message, tag = "118")]
            FileLimitUpdated(super::file::LimitUpdated),
            #[prost(message, tag = "114")]
            NotificationSend(super::notification::Send),
            #[prost(message, tag = "115")]
            NotificationUpdate(super::notification::Update),
            #[prost(message, tag = "116")]
            PayloadBroadcast(super::payload::Broadcast),
            #[prost(message, tag = "117")]
            MembershipUpdate(super::membership::Update),
            #[prost(message, tag = "137")]
            MembershipTiersUpdate(super::membership::TiersUpdate),
            #[prost(message, tag = "119")]
            SpaceSyncStatusUpdate(super::space::sync_status::Update),
            #[prost(message, tag = "120")]
            P2pStatusUpdate(super::p2p_status::Update),
            #[prost(message, tag = "121")]
            ImportFinish(super::import::Finish),
            #[prost(message, tag = "128")]
            ChatAdd(super::chat::Add),
            #[prost(message, tag = "129")]
            ChatUpdate(super::chat::Update),
            #[prost(message, tag = "130")]
            ChatUpdateReactions(super::chat::UpdateReactions),
            /// received to update per-message read status (if needed to
            #[prost(message, tag = "134")]
            ChatUpdateMessageReadStatus(super::chat::UpdateMessageReadStatus),
            /// highlight the unread messages in the UI)
            ///
            /// received to update per-message mention read status (if needed
            #[prost(message, tag = "135")]
            ChatUpdateMentionReadStatus(super::chat::UpdateMentionReadStatus),
            /// to highlight the unread mentions in the UI)
            #[prost(message, tag = "136")]
            ChatUpdateMessageSyncStatus(super::chat::UpdateMessageSyncStatus),
            #[prost(message, tag = "131")]
            ChatDelete(super::chat::Delete),
            /// in case new unread messages received or chat state changed
            #[prost(message, tag = "133")]
            ChatStateUpdate(super::chat::UpdateState),
            #[prost(message, tag = "138")]
            MembershipV2Update(super::membership_v2::Update),
            #[prost(message, tag = "139")]
            MembershipV2ProductsUpdate(super::membership_v2::ProductsUpdate),
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Chat {}
    /// Nested message and enum types in `Chat`.
    pub mod chat {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Add {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub order_id: ::prost::alloc::string::String,
            #[prost(string, tag = "6")]
            pub after_order_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "3")]
            pub message: ::core::option::Option<crate::model::ChatMessage>,
            #[prost(string, repeated, tag = "4")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(message, repeated, tag = "5")]
            pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Delete {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub message: ::core::option::Option<crate::model::ChatMessage>,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateReactions {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub reactions: ::core::option::Option<crate::model::chat_message::Reactions>,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UpdateMessageReadStatus {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "2")]
            pub is_read: bool,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UpdateMentionReadStatus {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "2")]
            pub is_read: bool,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UpdateMessageSyncStatus {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(bool, tag = "2")]
            pub is_synced: bool,
            #[prost(string, repeated, tag = "3")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UpdateState {
            #[prost(message, optional, tag = "1")]
            pub state: ::core::option::Option<crate::model::ChatState>,
            #[prost(string, repeated, tag = "2")]
            pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Account {}
    /// Nested message and enum types in `Account`.
    pub mod account {
        /// *
        ///
        /// Message, that will be sent to the front on each account found after an
        /// AccountRecoverRequest
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Show {
            /// Number of an account in an all found accounts list
            #[prost(int32, tag = "1")]
            pub index: i32,
            /// An Account, that has been found for the mnemonic
            #[prost(message, optional, tag = "2")]
            pub account: ::core::option::Option<crate::model::Account>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Details {
            #[prost(string, tag = "1")]
            pub profile_id: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub details: ::core::option::Option<::prost_types::Struct>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Config {}
        /// Nested message and enum types in `Config`.
        pub mod config {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Update {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<crate::model::account::Config>,
                #[prost(message, optional, tag = "2")]
                pub status: ::core::option::Option<crate::model::account::Status>,
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub config: ::core::option::Option<crate::model::account::Config>,
            #[prost(message, optional, tag = "2")]
            pub status: ::core::option::Option<crate::model::account::Status>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LinkChallenge {
            #[prost(string, tag = "1")]
            pub challenge: ::prost::alloc::string::String,
            #[prost(message, optional, tag = "2")]
            pub client_info: ::core::option::Option<link_challenge::ClientInfo>,
            #[prost(enumeration = "crate::model::account::auth::LocalApiScope", tag = "3")]
            pub scope: i32,
        }
        /// Nested message and enum types in `LinkChallenge`.
        pub mod link_challenge {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ClientInfo {
                #[prost(string, tag = "1")]
                pub process_name: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub process_path: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub name: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub signature_verified: bool,
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LinkChallengeHide {
            /// verify code before hiding to protect from MITM attacks
            #[prost(string, tag = "1")]
            pub challenge: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Object {}
    /// Nested message and enum types in `Object`.
    pub mod object {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Details {}
        /// Nested message and enum types in `Details`.
        pub mod details {
            /// Amend (i.e. add a new key-value pair or update an existing key-value
            /// pair) existing state
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Amend {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// slice of changed key-values
                #[prost(message, repeated, tag = "2")]
                pub details: ::prost::alloc::vec::Vec<amend::KeyValue>,
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Amend`.
            pub mod amend {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct KeyValue {
                    #[prost(string, tag = "1")]
                    pub key: ::prost::alloc::string::String,
                    /// should not be null
                    #[prost(message, optional, tag = "2")]
                    pub value: ::core::option::Option<::prost_types::Value>,
                }
            }
            /// Overwrite current state
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Set {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// can not be a partial state. Should replace client details
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// state
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Unset existing detail keys
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Unset {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, repeated, tag = "3")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Subscription {}
        /// Nested message and enum types in `Subscription`.
        pub mod subscription {
            /// Adds new document to subscriptions
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// id of previous doc in order, empty means first
                #[prost(string, tag = "2")]
                pub after_id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Removes document from subscription
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "2")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Indicates new position of document
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Position {
                /// object id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// id of previous doc in order, empty means first
                #[prost(string, tag = "2")]
                pub after_id: ::prost::alloc::string::String,
                /// subscription id
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Counters {
                /// total available records
                #[prost(int64, tag = "1")]
                pub total: i64,
                /// how many records available after
                #[prost(int64, tag = "2")]
                pub next_count: i64,
                /// how many records available before
                #[prost(int64, tag = "3")]
                pub prev_count: i64,
                /// subscription id
                #[prost(string, tag = "4")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Groups {
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub group: ::core::option::Option<crate::model::block::content::dataview::Group>,
                #[prost(bool, tag = "3")]
                pub remove: bool,
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Relations {}
        /// Nested message and enum types in `Relations`.
        pub mod relations {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Amend {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub relation_links: ::prost::alloc::vec::Vec<crate::model::RelationLink>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {
                /// context objectId
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Remove {
            /// notifies that objects were removed
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Restrictions {}
        /// Nested message and enum types in `Restrictions`.
        pub mod restrictions {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Set {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<crate::model::Restrictions>,
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Close {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Block {}
    /// Nested message and enum types in `Block`.
    pub mod block {
        /// Event to show internal blocks on a client.
        /// Example Scenarios
        /// A. Block Creation
        ///
        ///    1. Block A have been created on a client C1
        ///    1. Client C2 receives Event.Block.Add(Block A),
        ///       Event.Block.Update(Page.children) B. Partial block load
        ///    1. Client C1 opens Page1, that contains, for example, 133 blocks.
        ///    1. M -> F: ShowFullScreen(Root, blocks1-50)
        ///    1. M -> F: Block.Add(blocks51-100)
        ///    1. M -> F: Block.Add(blocks101-133)
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Add {
            /// id -> block
            #[prost(message, repeated, tag = "1")]
            pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
        }
        /// *
        ///
        /// Middleware to front end event message, that will be sent on one of this
        /// scenarios: Precondition: user A opened a block
        ///
        ///    1. User A drops a set of files/pictures/videos
        ///    1. User A creates a MediaBlock and drops a single media, that corresponds
        ///       to its type.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct FilesUpload {
            /// if empty => create new blocks
            #[prost(string, tag = "1")]
            pub block_id: ::prost::alloc::string::String,
            /// filepaths to the files
            #[prost(string, repeated, tag = "2")]
            pub file_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Delete {
            #[prost(string, repeated, tag = "1")]
            pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MarksInfo {
            #[prost(
                enumeration = "crate::model::block::content::text::mark::Type",
                repeated,
                tag = "1"
            )]
            pub marks_in_range: ::prost::alloc::vec::Vec<i32>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Set {}
        /// Nested message and enum types in `Set`.
        pub mod set {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Relation {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub key: ::core::option::Option<relation::Key>,
            }
            /// Nested message and enum types in `Relation`.
            pub mod relation {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Key {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Fields {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ChildrenIds {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub children_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Restrictions {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<crate::model::block::Restrictions>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct BackgroundColor {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub background_color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Align {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Align", tag = "2")]
                pub align: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct VerticalAlign {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::VerticalAlign", tag = "2")]
                pub vertical_align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Text {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<text::Text>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<text::Style>,
                #[prost(message, optional, tag = "4")]
                pub marks: ::core::option::Option<text::Marks>,
                #[prost(message, optional, tag = "5")]
                pub checked: ::core::option::Option<text::Checked>,
                #[prost(message, optional, tag = "6")]
                pub color: ::core::option::Option<text::Color>,
                #[prost(message, optional, tag = "7")]
                pub icon_emoji: ::core::option::Option<text::IconEmoji>,
                #[prost(message, optional, tag = "8")]
                pub icon_image: ::core::option::Option<text::IconImage>,
            }
            /// Nested message and enum types in `Text`.
            pub mod text {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::text::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Marks {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<crate::model::block::content::text::Marks>,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Checked {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Color {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct IconEmoji {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct IconImage {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Latex {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<latex::Text>,
                #[prost(message, optional, tag = "3")]
                pub processor: ::core::option::Option<latex::Processor>,
            }
            /// Nested message and enum types in `Latex`.
            pub mod latex {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Processor {
                    #[prost(
                        enumeration = "crate::model::block::content::latex::Processor",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Div {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub style: ::core::option::Option<div::Style>,
            }
            /// Nested message and enum types in `Div`.
            pub mod div {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::div::Style", tag = "1")]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct File {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub r#type: ::core::option::Option<file::Type>,
                #[prost(message, optional, tag = "3")]
                pub state: ::core::option::Option<file::State>,
                #[prost(message, optional, tag = "4")]
                pub mime: ::core::option::Option<file::Mime>,
                #[prost(message, optional, tag = "5")]
                pub hash: ::core::option::Option<file::Hash>,
                #[prost(message, optional, tag = "6")]
                pub name: ::core::option::Option<file::Name>,
                #[prost(message, optional, tag = "7")]
                pub size: ::core::option::Option<file::Size>,
                #[prost(message, optional, tag = "8")]
                pub style: ::core::option::Option<file::Style>,
                #[prost(message, optional, tag = "9")]
                pub target_object_id: ::core::option::Option<file::TargetObjectId>,
            }
            /// Nested message and enum types in `File`.
            pub mod file {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Name {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Width {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct State {
                    #[prost(enumeration = "crate::model::block::content::file::State", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Type {
                    #[prost(enumeration = "crate::model::block::content::file::Type", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::file::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Hash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Mime {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Size {
                    #[prost(int64, tag = "1")]
                    pub value: i64,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Link {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub target_block_id: ::core::option::Option<link::TargetBlockId>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<link::Style>,
                #[prost(message, optional, tag = "4")]
                pub fields: ::core::option::Option<link::Fields>,
                #[prost(message, optional, tag = "5")]
                pub icon_size: ::core::option::Option<link::IconSize>,
                #[prost(message, optional, tag = "6")]
                pub card_style: ::core::option::Option<link::CardStyle>,
                #[prost(message, optional, tag = "7")]
                pub description: ::core::option::Option<link::Description>,
                #[prost(message, optional, tag = "8")]
                pub relations: ::core::option::Option<link::Relations>,
            }
            /// Nested message and enum types in `Link`.
            pub mod link {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TargetBlockId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::link::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Fields {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost_types::Struct>,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct IconSize {
                    #[prost(
                        enumeration = "crate::model::block::content::link::IconSize",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct CardStyle {
                    #[prost(
                        enumeration = "crate::model::block::content::link::CardStyle",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Description {
                    #[prost(
                        enumeration = "crate::model::block::content::link::Description",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Relations {
                    #[prost(string, repeated, tag = "1")]
                    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Bookmark {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub url: ::core::option::Option<bookmark::Url>,
                #[prost(message, optional, tag = "3")]
                pub title: ::core::option::Option<bookmark::Title>,
                #[prost(message, optional, tag = "4")]
                pub description: ::core::option::Option<bookmark::Description>,
                #[prost(message, optional, tag = "5")]
                pub image_hash: ::core::option::Option<bookmark::ImageHash>,
                #[prost(message, optional, tag = "6")]
                pub favicon_hash: ::core::option::Option<bookmark::FaviconHash>,
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<bookmark::Type>,
                #[prost(message, optional, tag = "8")]
                pub target_object_id: ::core::option::Option<bookmark::TargetObjectId>,
                #[prost(message, optional, tag = "9")]
                pub state: ::core::option::Option<bookmark::State>,
            }
            /// Nested message and enum types in `Bookmark`.
            pub mod bookmark {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Url {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Title {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Description {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ImageHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct FaviconHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Type {
                    #[prost(enumeration = "crate::model::link_preview::Type", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct State {
                    #[prost(
                        enumeration = "crate::model::block::content::bookmark::State",
                        tag = "1"
                    )]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct TableRow {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub is_header: ::core::option::Option<table_row::IsHeader>,
            }
            /// Nested message and enum types in `TableRow`.
            pub mod table_row {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct IsHeader {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Widget {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub layout: ::core::option::Option<widget::Layout>,
                #[prost(message, optional, tag = "3")]
                pub limit: ::core::option::Option<widget::Limit>,
                #[prost(message, optional, tag = "4")]
                pub view_id: ::core::option::Option<widget::ViewId>,
            }
            /// Nested message and enum types in `Widget`.
            pub mod widget {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Layout {
                    #[prost(
                        enumeration = "crate::model::block::content::widget::Layout",
                        tag = "1"
                    )]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Limit {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ViewId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Fill {}
        /// Nested message and enum types in `Fill`.
        pub mod fill {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Details {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DatabaseRecords {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Fields {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ChildrenIds {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub children_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Restrictions {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub restrictions: ::core::option::Option<crate::model::block::Restrictions>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct BackgroundColor {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub background_color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Align {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Align", tag = "2")]
                pub align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Text {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub text: ::core::option::Option<text::Text>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<text::Style>,
                #[prost(message, optional, tag = "4")]
                pub marks: ::core::option::Option<text::Marks>,
                #[prost(message, optional, tag = "5")]
                pub checked: ::core::option::Option<text::Checked>,
                #[prost(message, optional, tag = "6")]
                pub color: ::core::option::Option<text::Color>,
            }
            /// Nested message and enum types in `Text`.
            pub mod text {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Text {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::text::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Marks {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<crate::model::block::content::text::Marks>,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Checked {
                    #[prost(bool, tag = "1")]
                    pub value: bool,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Color {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Div {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub style: ::core::option::Option<div::Style>,
            }
            /// Nested message and enum types in `Div`.
            pub mod div {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::div::Style", tag = "1")]
                    pub value: i32,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct File {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub r#type: ::core::option::Option<file::Type>,
                #[prost(message, optional, tag = "3")]
                pub state: ::core::option::Option<file::State>,
                #[prost(message, optional, tag = "4")]
                pub mime: ::core::option::Option<file::Mime>,
                #[prost(message, optional, tag = "5")]
                pub hash: ::core::option::Option<file::Hash>,
                #[prost(message, optional, tag = "6")]
                pub name: ::core::option::Option<file::Name>,
                #[prost(message, optional, tag = "7")]
                pub size: ::core::option::Option<file::Size>,
                #[prost(message, optional, tag = "8")]
                pub style: ::core::option::Option<file::Style>,
            }
            /// Nested message and enum types in `File`.
            pub mod file {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Name {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Width {
                    #[prost(int32, tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct State {
                    #[prost(enumeration = "crate::model::block::content::file::State", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Type {
                    #[prost(enumeration = "crate::model::block::content::file::Type", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::file::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Hash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Mime {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Size {
                    #[prost(int64, tag = "1")]
                    pub value: i64,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Link {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub target_block_id: ::core::option::Option<link::TargetBlockId>,
                #[prost(message, optional, tag = "3")]
                pub style: ::core::option::Option<link::Style>,
                #[prost(message, optional, tag = "4")]
                pub fields: ::core::option::Option<link::Fields>,
            }
            /// Nested message and enum types in `Link`.
            pub mod link {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TargetBlockId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Style {
                    #[prost(enumeration = "crate::model::block::content::link::Style", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Fields {
                    #[prost(message, optional, tag = "1")]
                    pub value: ::core::option::Option<::prost_types::Struct>,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Bookmark {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub url: ::core::option::Option<bookmark::Url>,
                #[prost(message, optional, tag = "3")]
                pub title: ::core::option::Option<bookmark::Title>,
                #[prost(message, optional, tag = "4")]
                pub description: ::core::option::Option<bookmark::Description>,
                #[prost(message, optional, tag = "5")]
                pub image_hash: ::core::option::Option<bookmark::ImageHash>,
                #[prost(message, optional, tag = "6")]
                pub favicon_hash: ::core::option::Option<bookmark::FaviconHash>,
                #[prost(message, optional, tag = "7")]
                pub r#type: ::core::option::Option<bookmark::Type>,
                #[prost(message, optional, tag = "8")]
                pub target_object_id: ::core::option::Option<bookmark::TargetObjectId>,
            }
            /// Nested message and enum types in `Bookmark`.
            pub mod bookmark {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Url {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Title {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Description {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ImageHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct FaviconHash {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Type {
                    #[prost(enumeration = "crate::model::link_preview::Type", tag = "1")]
                    pub value: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TargetObjectId {
                    #[prost(string, tag = "1")]
                    pub value: ::prost::alloc::string::String,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Dataview {}
        /// Nested message and enum types in `Dataview`.
        pub mod dataview {
            /// sent when the view have been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view id, client should double check this to make sure client
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                /// doesn't switch the active view in the middle
                #[prost(message, optional, tag = "3")]
                pub view: ::core::option::Option<crate::model::block::content::dataview::View>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ViewUpdate {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub filter: ::prost::alloc::vec::Vec<view_update::Filter>,
                #[prost(message, repeated, tag = "4")]
                pub relation: ::prost::alloc::vec::Vec<view_update::Relation>,
                #[prost(message, repeated, tag = "5")]
                pub sort: ::prost::alloc::vec::Vec<view_update::Sort>,
                #[prost(message, optional, tag = "6")]
                pub fields: ::core::option::Option<view_update::Fields>,
            }
            /// Nested message and enum types in `ViewUpdate`.
            pub mod view_update {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Fields {
                    #[prost(
                        enumeration = "crate::model::block::content::dataview::view::Type",
                        tag = "1"
                    )]
                    pub r#type: i32,
                    #[prost(string, tag = "2")]
                    pub name: ::prost::alloc::string::String,
                    /// Relation used for cover in gallery
                    #[prost(string, tag = "3")]
                    pub cover_relation_key: ::prost::alloc::string::String,
                    /// Hide icon near name
                    #[prost(bool, tag = "4")]
                    pub hide_icon: bool,
                    /// Gallery card size
                    #[prost(
                        enumeration = "crate::model::block::content::dataview::view::Size",
                        tag = "5"
                    )]
                    pub card_size: i32,
                    /// Image fits container
                    #[prost(bool, tag = "6")]
                    pub cover_fit: bool,
                    /// Group view by this relationKey
                    #[prost(string, tag = "7")]
                    pub group_relation_key: ::prost::alloc::string::String,
                    #[prost(string, tag = "16")]
                    pub end_relation_key: ::prost::alloc::string::String,
                    /// Enable backgrounds in groups
                    #[prost(bool, tag = "8")]
                    pub group_background_colors: bool,
                    /// Limit of objects shown in widget
                    #[prost(int32, tag = "9")]
                    pub page_limit: i32,
                    /// Id of template object set default for the view
                    #[prost(string, tag = "10")]
                    pub default_template_id: ::prost::alloc::string::String,
                    /// Default object type that is chosen for new object created
                    #[prost(string, tag = "15")]
                    pub default_object_type_id: ::prost::alloc::string::String,
                    /// within the view
                    ///
                    /// Wrap content in view
                    #[prost(bool, tag = "17")]
                    pub wrap_content: bool,
                    /// List view size setting
                    #[prost(
                        enumeration = "crate::model::block::content::dataview::view::ListSize",
                        tag = "18"
                    )]
                    pub list_size: i32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Filter {
                    #[prost(oneof = "filter::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<filter::Operation>,
                }
                /// Nested message and enum types in `Filter`.
                pub mod filter {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items: ::prost::alloc::vec::Vec<
                            crate::model::block::content::dataview::Filter,
                        >,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item:
                            ::core::option::Option<crate::model::block::content::dataview::Filter>,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Relation {
                    #[prost(oneof = "relation::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<relation::Operation>,
                }
                /// Nested message and enum types in `Relation`.
                pub mod relation {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items: ::prost::alloc::vec::Vec<
                            crate::model::block::content::dataview::Relation,
                        >,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item: ::core::option::Option<
                            crate::model::block::content::dataview::Relation,
                        >,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Sort {
                    #[prost(oneof = "sort::Operation", tags = "1, 2, 3, 4")]
                    pub operation: ::core::option::Option<sort::Operation>,
                }
                /// Nested message and enum types in `Sort`.
                pub mod sort {
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Add {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(message, repeated, tag = "2")]
                        pub items:
                            ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Sort>,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Remove {
                        #[prost(string, repeated, tag = "1")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct Update {
                        #[prost(string, tag = "1")]
                        pub id: ::prost::alloc::string::String,
                        #[prost(message, optional, tag = "2")]
                        pub item:
                            ::core::option::Option<crate::model::block::content::dataview::Sort>,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Move {
                        #[prost(string, tag = "1")]
                        pub after_id: ::prost::alloc::string::String,
                        #[prost(string, repeated, tag = "2")]
                        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    }
                    #[derive(Clone, PartialEq, ::prost::Oneof)]
                    pub enum Operation {
                        #[prost(message, tag = "1")]
                        Add(Add),
                        #[prost(message, tag = "2")]
                        Remove(Remove),
                        #[prost(message, tag = "3")]
                        Update(Update),
                        #[prost(message, tag = "4")]
                        Move(Move),
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ViewDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view id to remove
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ViewOrder {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// view ids in new order
                #[prost(string, repeated, tag = "2")]
                pub view_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SourceSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct OldRelationDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to remove
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
            }
            /// sent when the dataview relation has been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct OldRelationSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to update
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub relation: ::core::option::Option<crate::model::Relation>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct RelationDelete {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation key to remove
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// sent when the dataview relation has been changed or added
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RelationSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// relation id to update
                #[prost(message, repeated, tag = "2")]
                pub relation_links: ::prost::alloc::vec::Vec<crate::model::RelationLink>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroupOrderUpdate {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub group_order:
                    ::core::option::Option<crate::model::block::content::dataview::GroupOrder>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ObjectOrderUpdate {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub group_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub slice_changes: ::prost::alloc::vec::Vec<SliceChange>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SliceChange {
                #[prost(enumeration = "SliceOperation", tag = "1")]
                pub op: i32,
                #[prost(string, repeated, tag = "2")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub after_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct TargetObjectIdSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct IsCollectionSet {
                /// dataview block's id
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub value: bool,
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum SliceOperation {
                /// not used
                None = 0,
                Add = 1,
                Move = 2,
                Remove = 3,
                Replace = 4,
            }
            impl SliceOperation {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "SliceOperationNone",
                        Self::Add => "SliceOperationAdd",
                        Self::Move => "SliceOperationMove",
                        Self::Remove => "SliceOperationRemove",
                        Self::Replace => "SliceOperationReplace",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SliceOperationNone" => Some(Self::None),
                        "SliceOperationAdd" => Some(Self::Add),
                        "SliceOperationMove" => Some(Self::Move),
                        "SliceOperationRemove" => Some(Self::Remove),
                        "SliceOperationReplace" => Some(Self::Replace),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct User {}
    /// Nested message and enum types in `User`.
    pub mod user {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Block {}
        /// Nested message and enum types in `Block`.
        pub mod block {
            /// * Middleware to front end event message, that will be sent in this
            ///   scenario: Precondition: user A opened a block
            ///
            ///    1. User B opens the same block
            ///    1. User A receives a message about p.1
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Join {
                /// Account of the user, that opened a block
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
            }
            /// * Middleware to front end event message, that will be sent in this
            ///   scenario: Precondition: user A and user B opened the same block
            ///
            ///    1. User B closes the block
            ///    1. User A receives a message about p.1
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Left {
                /// Account of the user, that left the block
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
            }
            /// *
            ///
            /// Middleware to front end event message, that will be sent in this
            /// scenario: Precondition: user A and user B opened the same block
            ///
            ///    1. User B sets cursor or selects a text region into a text block
            ///    1. User A receives a message about p.1
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct TextRange {
                /// Account of the user, that selected a text
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
                /// Id of the text block, that have a selection
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                /// Range of the selection
                #[prost(message, optional, tag = "3")]
                pub range: ::core::option::Option<crate::model::Range>,
            }
            /// *
            ///
            /// Middleware to front end event message, that will be sent in this
            /// scenario: Precondition: user A and user B opened the same block
            ///
            ///    1. User B selects some inner blocks
            ///    1. User A receives a message about p.1
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SelectRange {
                /// Account of the user, that selected blocks
                #[prost(message, optional, tag = "1")]
                pub account: ::core::option::Option<super::super::Account>,
                /// Ids of selected blocks.
                #[prost(string, repeated, tag = "2")]
                pub block_ids_array: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ping {
        #[prost(int32, tag = "1")]
        pub index: i32,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Process {}
    /// Nested message and enum types in `Process`.
    pub mod process {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct New {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::model::Process>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::model::Process>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Done {
            #[prost(message, optional, tag = "1")]
            pub process: ::core::option::Option<super::super::model::Process>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Thread {
            #[prost(message, optional, tag = "1")]
            pub summary: ::core::option::Option<thread::Summary>,
            #[prost(message, optional, tag = "2")]
            pub cafe: ::core::option::Option<thread::Cafe>,
            #[prost(message, repeated, tag = "3")]
            pub accounts: ::prost::alloc::vec::Vec<thread::Account>,
        }
        /// Nested message and enum types in `Thread`.
        pub mod thread {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Summary {
                #[prost(enumeration = "SyncStatus", tag = "1")]
                pub status: i32,
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Cafe {
                #[prost(enumeration = "SyncStatus", tag = "1")]
                pub status: i32,
                #[prost(int64, tag = "2")]
                pub last_pulled: i64,
                #[prost(bool, tag = "3")]
                pub last_push_succeed: bool,
                #[prost(message, optional, tag = "4")]
                pub files: ::core::option::Option<cafe::PinStatus>,
            }
            /// Nested message and enum types in `Cafe`.
            pub mod cafe {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct PinStatus {
                    #[prost(int32, tag = "1")]
                    pub pinning: i32,
                    #[prost(int32, tag = "2")]
                    pub pinned: i32,
                    #[prost(int32, tag = "3")]
                    pub failed: i32,
                    #[prost(int64, tag = "4")]
                    pub updated: i64,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Account {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub image_hash: ::prost::alloc::string::String,
                #[prost(bool, tag = "4")]
                pub online: bool,
                #[prost(int64, tag = "5")]
                pub last_pulled: i64,
                #[prost(int64, tag = "6")]
                pub last_edited: i64,
                #[prost(message, repeated, tag = "7")]
                pub devices: ::prost::alloc::vec::Vec<Device>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Device {
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub online: bool,
                #[prost(int64, tag = "3")]
                pub last_pulled: i64,
                #[prost(int64, tag = "4")]
                pub last_edited: i64,
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum SyncStatus {
                Unknown = 0,
                Offline = 1,
                Syncing = 2,
                Synced = 3,
                Failed = 4,
                IncompatibleVersion = 5,
                NetworkNeedsUpdate = 6,
            }
            impl SyncStatus {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unknown => "Unknown",
                        Self::Offline => "Offline",
                        Self::Syncing => "Syncing",
                        Self::Synced => "Synced",
                        Self::Failed => "Failed",
                        Self::IncompatibleVersion => "IncompatibleVersion",
                        Self::NetworkNeedsUpdate => "NetworkNeedsUpdate",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Unknown" => Some(Self::Unknown),
                        "Offline" => Some(Self::Offline),
                        "Syncing" => Some(Self::Syncing),
                        "Synced" => Some(Self::Synced),
                        "Failed" => Some(Self::Failed),
                        "IncompatibleVersion" => Some(Self::IncompatibleVersion),
                        "NetworkNeedsUpdate" => Some(Self::NetworkNeedsUpdate),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct File {}
    /// Nested message and enum types in `File`.
    pub mod file {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LimitReached {
            #[prost(string, tag = "1")]
            pub space_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub file_id: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SpaceUsage {
            #[prost(uint64, tag = "1")]
            pub bytes_usage: u64,
            #[prost(string, tag = "2")]
            pub space_id: ::prost::alloc::string::String,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LocalUsage {
            #[prost(uint64, tag = "1")]
            pub local_bytes_usage: u64,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LimitUpdated {
            #[prost(uint64, tag = "1")]
            pub bytes_limit: u64,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Membership {}
    /// Nested message and enum types in `Membership`.
    pub mod membership {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub data: ::core::option::Option<crate::model::Membership>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TiersUpdate {
            #[prost(message, repeated, tag = "1")]
            pub tiers: ::prost::alloc::vec::Vec<crate::model::MembershipTierData>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MembershipV2 {}
    /// Nested message and enum types in `MembershipV2`.
    pub mod membership_v2 {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub data: ::core::option::Option<crate::model::membership_v2::Data>,
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProductsUpdate {
            #[prost(message, repeated, tag = "1")]
            pub products: ::prost::alloc::vec::Vec<crate::model::membership_v2::Product>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Notification {}
    /// Nested message and enum types in `Notification`.
    pub mod notification {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Send {
            #[prost(message, optional, tag = "1")]
            pub notification: ::core::option::Option<crate::model::Notification>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Update {
            #[prost(message, optional, tag = "1")]
            pub notification: ::core::option::Option<crate::model::Notification>,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Payload {}
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Broadcast {
            #[prost(string, tag = "1")]
            pub payload: ::prost::alloc::string::String,
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Space {}
    /// Nested message and enum types in `Space`.
    pub mod space {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SyncStatus {}
        /// Nested message and enum types in `SyncStatus`.
        pub mod sync_status {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Update {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "super::Status", tag = "2")]
                pub status: i32,
                #[prost(enumeration = "super::Network", tag = "3")]
                pub network: i32,
                #[prost(enumeration = "super::SyncError", tag = "4")]
                pub error: i32,
                #[prost(int64, tag = "5")]
                pub syncing_objects_counter: i64,
                #[prost(int64, tag = "6")]
                pub not_synced_files_counter: i64,
                #[prost(int64, tag = "7")]
                pub uploading_files_counter: i64,
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Status {
            Synced = 0,
            Syncing = 1,
            Error = 2,
            Offline = 3,
            NetworkNeedsUpdate = 4,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Synced => "Synced",
                    Self::Syncing => "Syncing",
                    Self::Error => "Error",
                    Self::Offline => "Offline",
                    Self::NetworkNeedsUpdate => "NetworkNeedsUpdate",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Synced" => Some(Self::Synced),
                    "Syncing" => Some(Self::Syncing),
                    "Error" => Some(Self::Error),
                    "Offline" => Some(Self::Offline),
                    "NetworkNeedsUpdate" => Some(Self::NetworkNeedsUpdate),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Network {
            Anytype = 0,
            SelfHost = 1,
            LocalOnly = 2,
        }
        impl Network {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Anytype => "Anytype",
                    Self::SelfHost => "SelfHost",
                    Self::LocalOnly => "LocalOnly",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Anytype" => Some(Self::Anytype),
                    "SelfHost" => Some(Self::SelfHost),
                    "LocalOnly" => Some(Self::LocalOnly),
                    _ => None,
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum SyncError {
            Null = 0,
            StorageLimitExceed = 1,
            IncompatibleVersion = 2,
            NetworkError = 3,
        }
        impl SyncError {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Null => "Null",
                    Self::StorageLimitExceed => "StorageLimitExceed",
                    Self::IncompatibleVersion => "IncompatibleVersion",
                    Self::NetworkError => "NetworkError",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Null" => Some(Self::Null),
                    "StorageLimitExceed" => Some(Self::StorageLimitExceed),
                    "IncompatibleVersion" => Some(Self::IncompatibleVersion),
                    "NetworkError" => Some(Self::NetworkError),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct P2pStatus {}
    /// Nested message and enum types in `P2PStatus`.
    pub mod p2p_status {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Update {
            #[prost(string, tag = "1")]
            pub space_id: ::prost::alloc::string::String,
            #[prost(enumeration = "Status", tag = "2")]
            pub status: i32,
            #[prost(int64, tag = "3")]
            pub devices_counter: i64,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Status {
            NotConnected = 0,
            NotPossible = 1,
            Connected = 2,
            /// only for ios for now, fallback to NotPossible if not
            Restricted = 3,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::NotConnected => "NotConnected",
                    Self::NotPossible => "NotPossible",
                    Self::Connected => "Connected",
                    Self::Restricted => "Restricted",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NotConnected" => Some(Self::NotConnected),
                    "NotPossible" => Some(Self::NotPossible),
                    "Connected" => Some(Self::Connected),
                    "Restricted" => Some(Self::Restricted),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Import {}
    /// Nested message and enum types in `Import`.
    pub mod import {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Finish {
            #[prost(string, tag = "1")]
            pub root_collection_id: ::prost::alloc::string::String,
            #[prost(int64, tag = "2")]
            pub objects_count: i64,
            #[prost(enumeration = "crate::model::import::Type", tag = "3")]
            pub import_type: i32,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseEvent {
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<event::Message>,
    #[prost(string, tag = "2")]
    pub context_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub trace_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Model {}
/// Nested message and enum types in `Model`.
pub mod model {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Process {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "process::State", tag = "3")]
        pub state: i32,
        #[prost(message, optional, tag = "4")]
        pub progress: ::core::option::Option<process::Progress>,
        #[prost(string, tag = "5")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub error: ::prost::alloc::string::String,
        #[prost(oneof = "process::Message", tags = "6, 7, 8, 9, 10, 12")]
        pub message: ::core::option::Option<process::Message>,
    }
    /// Nested message and enum types in `Process`.
    pub mod process {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DropFiles {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Import {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Export {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SaveFile {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Migration {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PreloadFile {}
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Progress {
            #[prost(int64, tag = "1")]
            pub total: i64,
            #[prost(int64, tag = "2")]
            pub done: i64,
            #[prost(string, tag = "3")]
            pub message: ::prost::alloc::string::String,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum State {
            None = 0,
            Running = 1,
            Done = 2,
            Canceled = 3,
            Error = 4,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "None",
                    Self::Running => "Running",
                    Self::Done => "Done",
                    Self::Canceled => "Canceled",
                    Self::Error => "Error",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "None" => Some(Self::None),
                    "Running" => Some(Self::Running),
                    "Done" => Some(Self::Done),
                    "Canceled" => Some(Self::Canceled),
                    "Error" => Some(Self::Error),
                    _ => None,
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Message {
            #[prost(message, tag = "6")]
            DropFiles(DropFiles),
            #[prost(message, tag = "7")]
            Import(Import),
            #[prost(message, tag = "8")]
            Export(Export),
            #[prost(message, tag = "9")]
            SaveFile(SaveFile),
            #[prost(message, tag = "10")]
            Migration(Migration),
            #[prost(message, tag = "12")]
            PreloadFile(PreloadFile),
        }
    }
}
/// Rpc is a namespace, that agregates all of the service commands between client and middleware.
/// Structure: Topic > Subtopic > Subsub... > Action > (Request, Response).
/// Request â€“ message from a client.
/// Response â€“ message from a middleware.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rpc {}
/// Nested message and enum types in `Rpc`.
pub mod rpc {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct App {}
    /// Nested message and enum types in `App`.
    pub mod app {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetVersion {}
        /// Nested message and enum types in `GetVersion`.
        pub mod get_version {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub version: ::prost::alloc::string::String,
                /// build date, branch and commit
                #[prost(string, tag = "3")]
                pub details: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetDeviceState {}
        /// Nested message and enum types in `SetDeviceState`.
        pub mod set_device_state {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(enumeration = "request::DeviceState", tag = "1")]
                pub device_state: i32,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum DeviceState {
                    /// went to background on mobile, hibernated on desktop
                    Background = 0,
                    /// went to foreground on mobile, woke from hibernation on desktop
                    Foreground = 1,
                }
                impl DeviceState {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Background => "BACKGROUND",
                            Self::Foreground => "FOREGROUND",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "BACKGROUND" => Some(Self::Background),
                            "FOREGROUND" => Some(Self::Foreground),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Shutdown {}
        /// Nested message and enum types in `Shutdown`.
        pub mod shutdown {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Space {}
    /// Nested message and enum types in `Space`.
    pub mod space {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LeaveApprove {}
        /// Nested message and enum types in `LeaveApprove`.
        pub mod leave_approve {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        NoApproveRequests = 105,
                        NotShareable = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NoApproveRequests => "NO_APPROVE_REQUESTS",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NO_APPROVE_REQUESTS" => Some(Self::NoApproveRequests),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MakeShareable {}
        /// Nested message and enum types in `MakeShareable`.
        pub mod make_shareable {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteChange {}
        /// Nested message and enum types in `InviteChange`.
        pub mod invite_change {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "2")]
                pub permissions: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        IncorrectPermissions = 105,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::IncorrectPermissions => "INCORRECT_PERMISSIONS",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "INCORRECT_PERMISSIONS" => Some(Self::IncorrectPermissions),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteGenerate {}
        /// Nested message and enum types in `InviteGenerate`.
        pub mod invite_generate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::InviteType", tag = "2")]
                pub invite_type: i32,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "3")]
                pub permissions: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub invite_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub invite_file_key: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::InviteType", tag = "4")]
                pub invite_type: i32,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "5")]
                pub permissions: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        NotShareable = 105,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct StopSharing {}
        /// Nested message and enum types in `StopSharing`.
        pub mod stop_sharing {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteGetCurrent {}
        /// Nested message and enum types in `InviteGetCurrent`.
        pub mod invite_get_current {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub invite_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub invite_file_key: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::InviteType", tag = "4")]
                pub invite_type: i32,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "5")]
                pub permissions: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoActiveInvite = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoActiveInvite => "NO_ACTIVE_INVITE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_ACTIVE_INVITE" => Some(Self::NoActiveInvite),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteGetGuest {}
        /// Nested message and enum types in `InviteGetGuest`.
        pub mod invite_get_guest {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub invite_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub invite_file_key: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InvalidSpaceType = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InvalidSpaceType => "INVALID_SPACE_TYPE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INVALID_SPACE_TYPE" => Some(Self::InvalidSpaceType),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteRevoke {}
        /// Nested message and enum types in `InviteRevoke`.
        pub mod invite_revoke {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        LimitReached = 103,
                        RequestFailed = 104,
                        NotShareable = 105,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct InviteView {}
        /// Nested message and enum types in `InviteView`.
        pub mod invite_view {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub invite_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub invite_file_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub space_name: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub space_icon_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub creator_name: ::prost::alloc::string::String,
                #[prost(string, tag = "10")]
                pub creator_icon_cid: ::prost::alloc::string::String,
                #[prost(uint32, tag = "8")]
                pub space_icon_option: u32,
                #[prost(uint32, tag = "9")]
                pub space_ux_type: u32,
                /// deprecated, use inviteType
                #[prost(bool, tag = "6")]
                pub is_guest_user_invite: bool,
                #[prost(enumeration = "crate::model::InviteType", tag = "7")]
                pub invite_type: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InviteNotFound = 101,
                        InviteBadContent = 102,
                        SpaceIsDeleted = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InviteNotFound => "INVITE_NOT_FOUND",
                                Self::InviteBadContent => "INVITE_BAD_CONTENT",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INVITE_NOT_FOUND" => Some(Self::InviteNotFound),
                                "INVITE_BAD_CONTENT" => Some(Self::InviteBadContent),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Join {}
        /// Nested message and enum types in `Join`.
        pub mod join {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// not-empty only for self-hosting
                #[prost(string, tag = "1")]
                pub network_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub invite_cid: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub invite_file_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        InviteNotFound = 103,
                        InviteBadContent = 104,
                        RequestFailed = 105,
                        LimitReached = 106,
                        NotShareable = 107,
                        DifferentNetwork = 108,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::InviteNotFound => "INVITE_NOT_FOUND",
                                Self::InviteBadContent => "INVITE_BAD_CONTENT",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NotShareable => "NOT_SHAREABLE",
                                Self::DifferentNetwork => "DIFFERENT_NETWORK",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "INVITE_NOT_FOUND" => Some(Self::InviteNotFound),
                                "INVITE_BAD_CONTENT" => Some(Self::InviteBadContent),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                "DIFFERENT_NETWORK" => Some(Self::DifferentNetwork),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct JoinCancel {}
        /// Nested message and enum types in `JoinCancel`.
        pub mod join_cancel {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        NoSuchRequest = 105,
                        NotShareable = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NoSuchRequest => "NO_SUCH_REQUEST",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NO_SUCH_REQUEST" => Some(Self::NoSuchRequest),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RequestApprove {}
        /// Nested message and enum types in `RequestApprove`.
        pub mod request_approve {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub identity: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "3")]
                pub permissions: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        NoSuchRequest = 103,
                        IncorrectPermissions = 104,
                        RequestFailed = 105,
                        LimitReached = 106,
                        NotShareable = 107,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::NoSuchRequest => "NO_SUCH_REQUEST",
                                Self::IncorrectPermissions => "INCORRECT_PERMISSIONS",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "NO_SUCH_REQUEST" => Some(Self::NoSuchRequest),
                                "INCORRECT_PERMISSIONS" => Some(Self::IncorrectPermissions),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RequestDecline {}
        /// Nested message and enum types in `RequestDecline`.
        pub mod request_decline {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub identity: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        NoSuchRequest = 105,
                        NotShareable = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NoSuchRequest => "NO_SUCH_REQUEST",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NO_SUCH_REQUEST" => Some(Self::NoSuchRequest),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParticipantRemove {}
        /// Nested message and enum types in `ParticipantRemove`.
        pub mod participant_remove {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub identities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        ParticipantNotFound = 103,
                        RequestFailed = 104,
                        LimitReached = 105,
                        NotShareable = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::ParticipantNotFound => "PARTICIPANT_NOT_FOUND",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "PARTICIPANT_NOT_FOUND" => Some(Self::ParticipantNotFound),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ParticipantPermissionsChange {}
        /// Nested message and enum types in `ParticipantPermissionsChange`.
        pub mod participant_permissions_change {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub changes: ::prost::alloc::vec::Vec<crate::model::ParticipantPermissionChange>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        ParticipantNotFound = 105,
                        IncorrectPermissions = 106,
                        NotShareable = 107,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::ParticipantNotFound => "PARTICIPANT_NOT_FOUND",
                                Self::IncorrectPermissions => "INCORRECT_PERMISSIONS",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "PARTICIPANT_NOT_FOUND" => Some(Self::ParticipantNotFound),
                                "INCORRECT_PERMISSIONS" => Some(Self::IncorrectPermissions),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Delete {}
        /// Nested message and enum types in `Delete`.
        pub mod delete {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(int64, tag = "2")]
                pub timestamp: i64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        LimitReached = 104,
                        NotShareable = 105,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::LimitReached => "LIMIT_REACHED",
                                Self::NotShareable => "NOT_SHAREABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "LIMIT_REACHED" => Some(Self::LimitReached),
                                "NOT_SHAREABLE" => Some(Self::NotShareable),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DeleteCorruptedBackup {}
        /// Nested message and enum types in `DeleteCorruptedBackup`.
        pub mod delete_corrupted_backup {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub backup_path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetOrder {}
        /// Nested message and enum types in `SetOrder`.
        pub mod set_order {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_view_id: ::prost::alloc::string::String,
                /// result order of space view ids
                #[prost(string, repeated, tag = "2")]
                pub space_view_order: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// final order of space view ids with their lexids
                #[prost(string, repeated, tag = "2")]
                pub space_view_order: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UnsetOrder {}
        /// Nested message and enum types in `UnsetOrder`.
        pub mod unset_order {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_view_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChangeOwnership {}
        /// Nested message and enum types in `ChangeOwnership`.
        pub mod change_ownership {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub new_owner_identity: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::ParticipantPermissions", tag = "3")]
                pub old_owner_permissions: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 101,
                        SpaceIsDeleted = 102,
                        RequestFailed = 103,
                        ParticipantNotFound = 105,
                        IncorrectPermissions = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::SpaceIsDeleted => "SPACE_IS_DELETED",
                                Self::RequestFailed => "REQUEST_FAILED",
                                Self::ParticipantNotFound => "PARTICIPANT_NOT_FOUND",
                                Self::IncorrectPermissions => "INCORRECT_PERMISSIONS",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "SPACE_IS_DELETED" => Some(Self::SpaceIsDeleted),
                                "REQUEST_FAILED" => Some(Self::RequestFailed),
                                "PARTICIPANT_NOT_FOUND" => Some(Self::ParticipantNotFound),
                                "INCORRECT_PERMISSIONS" => Some(Self::IncorrectPermissions),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Wallet {}
    /// Nested message and enum types in `Wallet`.
    pub mod wallet {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            /// *
            ///
            /// Front-end-to-middleware request to create a new wallet
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Path to a wallet directory
                #[prost(string, tag = "1")]
                pub root_path: ::prost::alloc::string::String,
                /// optional, default fts language
                #[prost(string, tag = "2")]
                pub fulltext_primary_language: ::prost::alloc::string::String,
            }
            /// *
            ///
            /// Middleware-to-front-end response, that can contain mnemonic of a created account and a NULL error or an empty mnemonic and a non-NULL error
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// Mnemonic of a new account (sequence of words, divided by spaces)
                #[prost(string, tag = "2")]
                pub mnemonic: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub account_key: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error; mnemonic should be non-empty
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Root path is wrong
                        BadInput = 2,
                        /// ...
                        FailedToCreateLocalRepo = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::FailedToCreateLocalRepo => "FAILED_TO_CREATE_LOCAL_REPO",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "FAILED_TO_CREATE_LOCAL_REPO" => {
                                    Some(Self::FailedToCreateLocalRepo)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Recover {}
        /// Nested message and enum types in `Recover`.
        pub mod recover {
            /// *
            ///
            /// Front end to middleware request-to-recover-a wallet with this mnemonic and a rootPath
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Path to a wallet directory
                #[prost(string, tag = "1")]
                pub root_path: ::prost::alloc::string::String,
                /// Mnemonic of a wallet to recover (mutually exclusive with accountKey)
                #[prost(string, tag = "2")]
                pub mnemonic: ::prost::alloc::string::String,
                /// optional, default fts language
                #[prost(string, tag = "3")]
                pub fulltext_primary_language: ::prost::alloc::string::String,
                /// optional: serialized account master node (base64 encoded), used to auth account instead of mnemonic
                #[prost(string, tag = "4")]
                pub account_key: ::prost::alloc::string::String,
            }
            /// *
            ///
            /// Middleware-to-front-end response, that can contain a NULL error or a non-NULL error
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to recover a wallet
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error; wallet successfully recovered
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Root path or mnemonic is wrong
                        BadInput = 2,
                        FailedToCreateLocalRepo = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::FailedToCreateLocalRepo => "FAILED_TO_CREATE_LOCAL_REPO",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "FAILED_TO_CREATE_LOCAL_REPO" => {
                                    Some(Self::FailedToCreateLocalRepo)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Convert {}
        /// Nested message and enum types in `Convert`.
        pub mod convert {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Mnemonic of a wallet to convert
                #[prost(string, tag = "1")]
                pub mnemonic: ::prost::alloc::string::String,
                /// entropy of a wallet to convert
                #[prost(string, tag = "2")]
                pub entropy: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to recover a wallet
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub entropy: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub mnemonic: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error; wallet successfully recovered
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// mnemonic is wrong
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateSession {}
        /// Nested message and enum types in `CreateSession`.
        pub mod create_session {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(oneof = "request::Auth", tags = "1, 2, 3, 4")]
                pub auth: ::core::option::Option<request::Auth>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Auth {
                    /// cold auth
                    #[prost(string, tag = "1")]
                    Mnemonic(::prost::alloc::string::String),
                    /// persistent app key, that can be used to restore session. Used for Local JSON API
                    #[prost(string, tag = "2")]
                    AppKey(::prost::alloc::string::String),
                    /// token from the previous session
                    #[prost(string, tag = "3")]
                    Token(::prost::alloc::string::String),
                    /// private key of specific account
                    #[prost(string, tag = "4")]
                    AccountKey(::prost::alloc::string::String),
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub token: ::prost::alloc::string::String,
                /// in case of mnemonic auth, need to be persisted by client
                #[prost(string, tag = "3")]
                pub app_token: ::prost::alloc::string::String,
                /// temp, should be replaced with AccountInfo message
                #[prost(string, tag = "4")]
                pub account_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// means the client logged into another account or the account directory has been cleaned
                        AppTokenNotFoundInTheCurrentAccount = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AppTokenNotFoundInTheCurrentAccount => {
                                    "APP_TOKEN_NOT_FOUND_IN_THE_CURRENT_ACCOUNT"
                                }
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "APP_TOKEN_NOT_FOUND_IN_THE_CURRENT_ACCOUNT" => {
                                    Some(Self::AppTokenNotFoundInTheCurrentAccount)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CloseSession {}
        /// Nested message and enum types in `CloseSession`.
        pub mod close_session {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub token: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Account {}
    /// Nested message and enum types in `Account`.
    pub mod account {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Config {
            #[prost(bool, tag = "1")]
            pub enable_dataview: bool,
            #[prost(bool, tag = "2")]
            pub enable_debug: bool,
            #[prost(bool, tag = "3")]
            pub enable_prerelease_channel: bool,
            #[prost(bool, tag = "4")]
            pub enable_spaces: bool,
            #[prost(message, optional, tag = "100")]
            pub extra: ::core::option::Option<::prost_types::Struct>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            /// *
            ///
            /// Front end to middleware request-to-create-an account
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Account name
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                /// Path to local storage
                #[prost(string, tag = "3")]
                pub store_path: ::prost::alloc::string::String,
                /// Option of pre-installed icon
                #[prost(int64, tag = "4")]
                pub icon: i64,
                /// Disable local network discovery
                #[prost(bool, tag = "5")]
                pub disable_local_network_sync: bool,
                /// optional, default is DefaultConfig
                #[prost(enumeration = "super::NetworkMode", tag = "6")]
                pub network_mode: i32,
                /// config path for the custom network mode            }
                #[prost(string, tag = "7")]
                pub network_custom_config_file_path: ::prost::alloc::string::String,
                /// optional, default is false, recommended in case of problems with QUIC transport
                #[prost(bool, tag = "8")]
                pub prefer_yamux_transport: bool,
                /// optional, if empty json api will not be started; 127.0.0.1:31009 should be the default one
                #[prost(string, tag = "9")]
                pub json_api_listen_addr: ::prost::alloc::string::String,
                /// anytype:// schema URL to join an embed stream
                #[prost(string, tag = "10")]
                pub join_stream_url: ::prost::alloc::string::String,
                /// if true - will run membership v2 polling loop, v2 methods will be available
                /// if false - will run membership v1 polling loop, v2 methods will return error
                ///
                /// optional, default is false
                #[prost(bool, tag = "11")]
                pub enable_membership_v2: bool,
                /// TODO: Remove if not needed, GO-1926
                #[prost(oneof = "request::Avatar", tags = "2")]
                pub avatar: ::core::option::Option<request::Avatar>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                /// TODO: Remove if not needed, GO-1926
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Avatar {
                    /// Path to an image, that will be used as an avatar of this account
                    #[prost(string, tag = "2")]
                    AvatarLocalPath(::prost::alloc::string::String),
                }
            }
            /// *
            ///
            /// Middleware-to-front-end response for an account creation request, that can contain a NULL error and created account or a non-NULL error and an empty account
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                /// Error while trying to create an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// A newly created account; In case of a failure, i.e. error is non-NULL, the account model should contain empty/default-value fields
                #[prost(message, optional, tag = "2")]
                pub account: ::core::option::Option<crate::model::Account>,
                /// deprecated, use account, GO-1926
                #[prost(message, optional, tag = "3")]
                pub config: ::core::option::Option<super::Config>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error; Account should be non-empty
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Avatar or name is not correct
                        BadInput = 2,
                        AccountCreatedButFailedToStartNode = 101,
                        AccountCreatedButFailedToSetName = 102,
                        FailedToStopRunningNode = 104,
                        FailedToWriteConfig = 105,
                        FailedToCreateLocalRepo = 106,
                        AccountCreationIsCanceled = 107,
                        ConfigFileNotFound = 200,
                        ConfigFileInvalid = 201,
                        ConfigFileNetworkIdMismatch = 202,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountCreatedButFailedToStartNode => {
                                    "ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE"
                                }
                                Self::AccountCreatedButFailedToSetName => {
                                    "ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME"
                                }
                                Self::FailedToStopRunningNode => "FAILED_TO_STOP_RUNNING_NODE",
                                Self::FailedToWriteConfig => "FAILED_TO_WRITE_CONFIG",
                                Self::FailedToCreateLocalRepo => "FAILED_TO_CREATE_LOCAL_REPO",
                                Self::AccountCreationIsCanceled => "ACCOUNT_CREATION_IS_CANCELED",
                                Self::ConfigFileNotFound => "CONFIG_FILE_NOT_FOUND",
                                Self::ConfigFileInvalid => "CONFIG_FILE_INVALID",
                                Self::ConfigFileNetworkIdMismatch => {
                                    "CONFIG_FILE_NETWORK_ID_MISMATCH"
                                }
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE" => {
                                    Some(Self::AccountCreatedButFailedToStartNode)
                                }
                                "ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME" => {
                                    Some(Self::AccountCreatedButFailedToSetName)
                                }
                                "FAILED_TO_STOP_RUNNING_NODE" => {
                                    Some(Self::FailedToStopRunningNode)
                                }
                                "FAILED_TO_WRITE_CONFIG" => Some(Self::FailedToWriteConfig),
                                "FAILED_TO_CREATE_LOCAL_REPO" => {
                                    Some(Self::FailedToCreateLocalRepo)
                                }
                                "ACCOUNT_CREATION_IS_CANCELED" => {
                                    Some(Self::AccountCreationIsCanceled)
                                }
                                "CONFIG_FILE_NOT_FOUND" => Some(Self::ConfigFileNotFound),
                                "CONFIG_FILE_INVALID" => Some(Self::ConfigFileInvalid),
                                "CONFIG_FILE_NETWORK_ID_MISMATCH" => {
                                    Some(Self::ConfigFileNetworkIdMismatch)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Recover {}
        /// Nested message and enum types in `Recover`.
        pub mod recover {
            /// *
            ///
            /// Front end to middleware request-to-start-search of an accounts for a recovered mnemonic.
            /// Each of an account that would be found will come with an AccountAdd event
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            /// *
            ///
            /// Middleware-to-front-end response to an account recover request, that can contain a NULL error and created account or a non-NULL error and an empty account
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to recover an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error;
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        BadInput = 2,
                        NeedToRecoverWalletFirst = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NeedToRecoverWalletFirst => "NEED_TO_RECOVER_WALLET_FIRST",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NEED_TO_RECOVER_WALLET_FIRST" => {
                                    Some(Self::NeedToRecoverWalletFirst)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Delete {}
        /// Nested message and enum types in `Delete`.
        pub mod delete {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to recover an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub status: ::core::option::Option<crate::model::account::Status>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error;
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsAlreadyDeleted = 101,
                        UnableToConnect = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsAlreadyDeleted => "ACCOUNT_IS_ALREADY_DELETED",
                                Self::UnableToConnect => "UNABLE_TO_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_ALREADY_DELETED" => Some(Self::AccountIsAlreadyDeleted),
                                "UNABLE_TO_CONNECT" => Some(Self::UnableToConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RevertDeletion {}
        /// Nested message and enum types in `RevertDeletion`.
        pub mod revert_deletion {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to recover an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub status: ::core::option::Option<crate::model::account::Status>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error;
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsActive = 101,
                        UnableToConnect = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsActive => "ACCOUNT_IS_ACTIVE",
                                Self::UnableToConnect => "UNABLE_TO_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_ACTIVE" => Some(Self::AccountIsActive),
                                "UNABLE_TO_CONNECT" => Some(Self::UnableToConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Migrate {}
        /// Nested message and enum types in `Migrate`.
        pub mod migrate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Id of a selected account
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub root_path: ::prost::alloc::string::String,
                /// optional, default fts language
                #[prost(string, tag = "3")]
                pub fulltext_primary_language: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                    #[prost(int64, tag = "3")]
                    pub required_space: i64,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Id or root path is wrong
                        BadInput = 2,
                        AccountNotFound = 101,
                        Canceled = 102,
                        /// TODO: \[storage\] Add specific error codes for migration problems
                        NotEnoughFreeSpace = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountNotFound => "ACCOUNT_NOT_FOUND",
                                Self::Canceled => "CANCELED",
                                Self::NotEnoughFreeSpace => "NOT_ENOUGH_FREE_SPACE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_NOT_FOUND" => Some(Self::AccountNotFound),
                                "CANCELED" => Some(Self::Canceled),
                                "NOT_ENOUGH_FREE_SPACE" => Some(Self::NotEnoughFreeSpace),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MigrateCancel {}
        /// Nested message and enum types in `MigrateCancel`.
        pub mod migrate_cancel {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Id of a selected account
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Id or root path is wrong
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Select {}
        /// Nested message and enum types in `Select`.
        pub mod select {
            /// *
            ///
            /// Front end to middleware request-to-launch-a specific account using account id and a root path
            /// User can select an account from those, that came with an AccountAdd events
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Id of a selected account
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                /// Root path is optional, set if this is a first request
                #[prost(string, tag = "2")]
                pub root_path: ::prost::alloc::string::String,
                /// Disable local network discovery
                #[prost(bool, tag = "3")]
                pub disable_local_network_sync: bool,
                /// optional, default is DefaultConfig
                #[prost(enumeration = "super::NetworkMode", tag = "4")]
                pub network_mode: i32,
                /// config path for the custom network mode
                #[prost(string, tag = "5")]
                pub network_custom_config_file_path: ::prost::alloc::string::String,
                /// optional, default is false, recommended in case of problems with QUIC transport
                #[prost(bool, tag = "6")]
                pub prefer_yamux_transport: bool,
                /// optional, if empty json api will not be started; 127.0.0.1:31009 should be the default one
                #[prost(string, tag = "7")]
                pub json_api_listen_addr: ::prost::alloc::string::String,
                /// optional, default fts language
                #[prost(string, tag = "8")]
                pub fulltext_primary_language: ::prost::alloc::string::String,
                /// anytype:// schema URL to join an embed stream
                #[prost(string, tag = "9")]
                pub join_stream_url: ::prost::alloc::string::String,
                /// if true - will run membership v2 polling loop, v2 methods will be available
                /// if false - will run membership v1 polling loop, v2 methods will return error
                ///
                /// optional, default is false
                #[prost(bool, tag = "10")]
                pub enable_membership_v2: bool,
            }
            /// *
            ///
            /// Middleware-to-front-end response for an account select request, that can contain a NULL error and selected account or a non-NULL error and an empty account
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                /// Error while trying to launch/select an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// Selected account
                #[prost(message, optional, tag = "2")]
                pub account: ::core::option::Option<crate::model::Account>,
                /// deprecated, use account, GO-1926
                #[prost(message, optional, tag = "3")]
                pub config: ::core::option::Option<super::Config>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Id or root path is wrong
                        BadInput = 2,
                        FailedToCreateLocalRepo = 101,
                        LocalRepoExistsButCorrupted = 102,
                        FailedToRunNode = 103,
                        FailedToFindAccountInfo = 104,
                        LocalRepoNotExistsAndMnemonicNotSet = 105,
                        FailedToStopSearcherNode = 106,
                        AnotherAnytypeProcessIsRunning = 108,
                        FailedToFetchRemoteNodeHasIncompatibleProtoVersion = 110,
                        AccountIsDeleted = 111,
                        AccountLoadIsCanceled = 112,
                        AccountStoreNotMigrated = 113,
                        ConfigFileNotFound = 200,
                        ConfigFileInvalid = 201,
                        ConfigFileNetworkIdMismatch = 202,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::FailedToCreateLocalRepo => "FAILED_TO_CREATE_LOCAL_REPO",
                                Self::LocalRepoExistsButCorrupted => {
                                    "LOCAL_REPO_EXISTS_BUT_CORRUPTED"
                                }
                                Self::FailedToRunNode => "FAILED_TO_RUN_NODE",
                                Self::FailedToFindAccountInfo => "FAILED_TO_FIND_ACCOUNT_INFO",
                                Self::LocalRepoNotExistsAndMnemonicNotSet => {
                                    "LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET"
                                }
                                Self::FailedToStopSearcherNode => "FAILED_TO_STOP_SEARCHER_NODE",
                                Self::AnotherAnytypeProcessIsRunning => {
                                    "ANOTHER_ANYTYPE_PROCESS_IS_RUNNING"
                                }
                                Self::FailedToFetchRemoteNodeHasIncompatibleProtoVersion => {
                                    "FAILED_TO_FETCH_REMOTE_NODE_HAS_INCOMPATIBLE_PROTO_VERSION"
                                }
                                Self::AccountIsDeleted => "ACCOUNT_IS_DELETED",
                                Self::AccountLoadIsCanceled => "ACCOUNT_LOAD_IS_CANCELED",
                                Self::AccountStoreNotMigrated => "ACCOUNT_STORE_NOT_MIGRATED",
                                Self::ConfigFileNotFound => "CONFIG_FILE_NOT_FOUND",
                                Self::ConfigFileInvalid => "CONFIG_FILE_INVALID",
                                Self::ConfigFileNetworkIdMismatch => {
                                    "CONFIG_FILE_NETWORK_ID_MISMATCH"
                                }
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "FAILED_TO_CREATE_LOCAL_REPO" => {
                                    Some(Self::FailedToCreateLocalRepo)
                                }
                                "LOCAL_REPO_EXISTS_BUT_CORRUPTED" => {
                                    Some(Self::LocalRepoExistsButCorrupted)
                                }
                                "FAILED_TO_RUN_NODE" => Some(Self::FailedToRunNode),
                                "FAILED_TO_FIND_ACCOUNT_INFO" => {
                                    Some(Self::FailedToFindAccountInfo)
                                }
                                "LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET" => {
                                    Some(Self::LocalRepoNotExistsAndMnemonicNotSet)
                                }
                                "FAILED_TO_STOP_SEARCHER_NODE" => {
                                    Some(Self::FailedToStopSearcherNode)
                                }
                                "ANOTHER_ANYTYPE_PROCESS_IS_RUNNING" => {
                                    Some(Self::AnotherAnytypeProcessIsRunning)
                                }
                                "FAILED_TO_FETCH_REMOTE_NODE_HAS_INCOMPATIBLE_PROTO_VERSION" => {
                                    Some(Self::FailedToFetchRemoteNodeHasIncompatibleProtoVersion)
                                }
                                "ACCOUNT_IS_DELETED" => Some(Self::AccountIsDeleted),
                                "ACCOUNT_LOAD_IS_CANCELED" => Some(Self::AccountLoadIsCanceled),
                                "ACCOUNT_STORE_NOT_MIGRATED" => Some(Self::AccountStoreNotMigrated),
                                "CONFIG_FILE_NOT_FOUND" => Some(Self::ConfigFileNotFound),
                                "CONFIG_FILE_INVALID" => Some(Self::ConfigFileInvalid),
                                "CONFIG_FILE_NETWORK_ID_MISMATCH" => {
                                    Some(Self::ConfigFileNetworkIdMismatch)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Stop {}
        /// Nested message and enum types in `Stop`.
        pub mod stop {
            /// *
            ///
            /// Front end to middleware request to stop currently running account node and optionally remove the locally stored data
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(bool, tag = "1")]
                pub remove_data: bool,
            }
            /// *
            ///
            /// Middleware-to-front-end response for an account stop request
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// Error while trying to launch/select an account
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        /// No error
                        Null = 0,
                        /// Any other errors
                        UnknownError = 1,
                        /// Id or root path is wrong
                        BadInput = 2,
                        AccountIsNotRunning = 101,
                        FailedToStopNode = 102,
                        FailedToRemoveAccountData = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                Self::FailedToStopNode => "FAILED_TO_STOP_NODE",
                                Self::FailedToRemoveAccountData => "FAILED_TO_REMOVE_ACCOUNT_DATA",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                "FAILED_TO_STOP_NODE" => Some(Self::FailedToStopNode),
                                "FAILED_TO_REMOVE_ACCOUNT_DATA" => {
                                    Some(Self::FailedToRemoveAccountData)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Move {}
        /// Nested message and enum types in `Move`.
        pub mod r#move {
            /// *
            ///
            /// Front-end-to-middleware request to move a account to a new disk location
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub new_path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        FailedToStopNode = 101,
                        FailedToIdentifyAccountDir = 102,
                        FailedToRemoveAccountData = 103,
                        FailedToCreateLocalRepo = 104,
                        FailedToWriteConfig = 105,
                        FailedToGetConfig = 106,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::FailedToStopNode => "FAILED_TO_STOP_NODE",
                                Self::FailedToIdentifyAccountDir => {
                                    "FAILED_TO_IDENTIFY_ACCOUNT_DIR"
                                }
                                Self::FailedToRemoveAccountData => "FAILED_TO_REMOVE_ACCOUNT_DATA",
                                Self::FailedToCreateLocalRepo => "FAILED_TO_CREATE_LOCAL_REPO",
                                Self::FailedToWriteConfig => "FAILED_TO_WRITE_CONFIG",
                                Self::FailedToGetConfig => "FAILED_TO_GET_CONFIG",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "FAILED_TO_STOP_NODE" => Some(Self::FailedToStopNode),
                                "FAILED_TO_IDENTIFY_ACCOUNT_DIR" => {
                                    Some(Self::FailedToIdentifyAccountDir)
                                }
                                "FAILED_TO_REMOVE_ACCOUNT_DATA" => {
                                    Some(Self::FailedToRemoveAccountData)
                                }
                                "FAILED_TO_CREATE_LOCAL_REPO" => {
                                    Some(Self::FailedToCreateLocalRepo)
                                }
                                "FAILED_TO_WRITE_CONFIG" => Some(Self::FailedToWriteConfig),
                                "FAILED_TO_GET_CONFIG" => Some(Self::FailedToGetConfig),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ConfigUpdate {}
        /// Nested message and enum types in `ConfigUpdate`.
        pub mod config_update {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "2")]
                pub ipfs_storage_addr: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsNotRunning = 101,
                        FailedToWriteConfig = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                Self::FailedToWriteConfig => "FAILED_TO_WRITE_CONFIG",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                "FAILED_TO_WRITE_CONFIG" => Some(Self::FailedToWriteConfig),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Timezones {
                Gmt = 0,
                Ect = 1,
                Eet = 2,
                Eat = 3,
                Met = 4,
                Net = 5,
                Plt = 6,
                Ist = 7,
                Bst = 8,
                Vst = 9,
                Ctt = 10,
                Jst = 11,
                Act = 12,
                Aet = 13,
                Sst = 14,
                Nst = 15,
                Mit = 16,
                Hst = 17,
                Ast = 18,
                Pst = 19,
                Mst = 20,
                Cst = 21,
                Iet = 22,
                Prt = 23,
                Cnt = 24,
                Bet = 25,
                Brt = 26,
                Cat = 27,
            }
            impl Timezones {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Gmt => "GMT",
                        Self::Ect => "ECT",
                        Self::Eet => "EET",
                        Self::Eat => "EAT",
                        Self::Met => "MET",
                        Self::Net => "NET",
                        Self::Plt => "PLT",
                        Self::Ist => "IST",
                        Self::Bst => "BST",
                        Self::Vst => "VST",
                        Self::Ctt => "CTT",
                        Self::Jst => "JST",
                        Self::Act => "ACT",
                        Self::Aet => "AET",
                        Self::Sst => "SST",
                        Self::Nst => "NST",
                        Self::Mit => "MIT",
                        Self::Hst => "HST",
                        Self::Ast => "AST",
                        Self::Pst => "PST",
                        Self::Mst => "MST",
                        Self::Cst => "CST",
                        Self::Iet => "IET",
                        Self::Prt => "PRT",
                        Self::Cnt => "CNT",
                        Self::Bet => "BET",
                        Self::Brt => "BRT",
                        Self::Cat => "CAT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "GMT" => Some(Self::Gmt),
                        "ECT" => Some(Self::Ect),
                        "EET" => Some(Self::Eet),
                        "EAT" => Some(Self::Eat),
                        "MET" => Some(Self::Met),
                        "NET" => Some(Self::Net),
                        "PLT" => Some(Self::Plt),
                        "IST" => Some(Self::Ist),
                        "BST" => Some(Self::Bst),
                        "VST" => Some(Self::Vst),
                        "CTT" => Some(Self::Ctt),
                        "JST" => Some(Self::Jst),
                        "ACT" => Some(Self::Act),
                        "AET" => Some(Self::Aet),
                        "SST" => Some(Self::Sst),
                        "NST" => Some(Self::Nst),
                        "MIT" => Some(Self::Mit),
                        "HST" => Some(Self::Hst),
                        "AST" => Some(Self::Ast),
                        "PST" => Some(Self::Pst),
                        "MST" => Some(Self::Mst),
                        "CST" => Some(Self::Cst),
                        "IET" => Some(Self::Iet),
                        "PRT" => Some(Self::Prt),
                        "CNT" => Some(Self::Cnt),
                        "BET" => Some(Self::Bet),
                        "BRT" => Some(Self::Brt),
                        "CAT" => Some(Self::Cat),
                        _ => None,
                    }
                }
            }
        }
        /// TODO: Remove this request if we do not need it, GO-1926
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetConfig {}
        /// Nested message and enum types in `GetConfig`.
        pub mod get_config {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Get {}
            /// Nested message and enum types in `Get`.
            pub mod get {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {}
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RecoverFromLegacyExport {}
        /// Nested message and enum types in `RecoverFromLegacyExport`.
        pub mod recover_from_legacy_export {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub root_path: ::prost::alloc::string::String,
                #[prost(int64, tag = "3")]
                pub icon: i64,
                /// optional, default fts language
                #[prost(string, tag = "4")]
                pub fulltext_primary_language: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(string, tag = "1")]
                pub account_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub personal_space_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        DifferentAccount = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::DifferentAccount => "DIFFERENT_ACCOUNT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "DIFFERENT_ACCOUNT" => Some(Self::DifferentAccount),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EnableLocalNetworkSync {}
        /// Nested message and enum types in `EnableLocalNetworkSync`.
        pub mod enable_local_network_sync {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsNotRunning = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChangeJsonApiAddr {}
        /// Nested message and enum types in `ChangeJsonApiAddr`.
        pub mod change_json_api_addr {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// make sure to use 127.0.0.1:x to not listen on all interfaces; recommended value is 127.0.0.1:31009
                #[prost(string, tag = "1")]
                pub listen_addr: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsNotRunning = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChangeNetworkConfigAndRestart {}
        /// Nested message and enum types in `ChangeNetworkConfigAndRestart`.
        pub mod change_network_config_and_restart {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(enumeration = "super::NetworkMode", tag = "1")]
                pub network_mode: i32,
                #[prost(string, tag = "2")]
                pub network_custom_config_file_path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        AccountIsNotRunning = 4,
                        AccountFailedToStop = 100,
                        ConfigFileNotFound = 200,
                        ConfigFileInvalid = 201,
                        ConfigFileNetworkIdMismatch = 202,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                Self::AccountFailedToStop => "ACCOUNT_FAILED_TO_STOP",
                                Self::ConfigFileNotFound => "CONFIG_FILE_NOT_FOUND",
                                Self::ConfigFileInvalid => "CONFIG_FILE_INVALID",
                                Self::ConfigFileNetworkIdMismatch => {
                                    "CONFIG_FILE_NETWORK_ID_MISMATCH"
                                }
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                "ACCOUNT_FAILED_TO_STOP" => Some(Self::AccountFailedToStop),
                                "CONFIG_FILE_NOT_FOUND" => Some(Self::ConfigFileNotFound),
                                "CONFIG_FILE_INVALID" => Some(Self::ConfigFileInvalid),
                                "CONFIG_FILE_NETWORK_ID_MISMATCH" => {
                                    Some(Self::ConfigFileNetworkIdMismatch)
                                }
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LocalLink {}
        /// Nested message and enum types in `LocalLink`.
        pub mod local_link {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct NewChallenge {}
            /// Nested message and enum types in `NewChallenge`.
            pub mod new_challenge {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    /// just for info, not secure to rely on
                    #[prost(string, tag = "1")]
                    pub app_name: ::prost::alloc::string::String,
                    #[prost(enumeration = "crate::model::account::auth::LocalApiScope", tag = "2")]
                    pub scope: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(string, tag = "2")]
                    pub challenge_id: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            AccountIsNotRunning = 101,
                            /// protection from overuse
                            TooManyRequests = 102,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                    Self::TooManyRequests => "TOO_MANY_REQUESTS",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                    "TOO_MANY_REQUESTS" => Some(Self::TooManyRequests),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SolveChallenge {}
            /// Nested message and enum types in `SolveChallenge`.
            pub mod solve_challenge {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub challenge_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub answer: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    /// ephemeral token for the session
                    #[prost(string, tag = "2")]
                    pub session_token: ::prost::alloc::string::String,
                    /// persistent key, that can be used to restore session via CreateSession
                    #[prost(string, tag = "3")]
                    pub app_key: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            AccountIsNotRunning = 101,
                            InvalidChallengeId = 102,
                            ChallengeAttemptsExceeded = 103,
                            IncorrectAnswer = 104,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                    Self::InvalidChallengeId => "INVALID_CHALLENGE_ID",
                                    Self::ChallengeAttemptsExceeded => {
                                        "CHALLENGE_ATTEMPTS_EXCEEDED"
                                    }
                                    Self::IncorrectAnswer => "INCORRECT_ANSWER",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                    "INVALID_CHALLENGE_ID" => Some(Self::InvalidChallengeId),
                                    "CHALLENGE_ATTEMPTS_EXCEEDED" => {
                                        Some(Self::ChallengeAttemptsExceeded)
                                    }
                                    "INCORRECT_ANSWER" => Some(Self::IncorrectAnswer),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ListApps {}
            /// Nested message and enum types in `ListApps`.
            pub mod list_apps {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {}
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, repeated, tag = "2")]
                    pub app: ::prost::alloc::vec::Vec<crate::model::account::auth::AppInfo>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            AccountIsNotRunning = 101,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct CreateApp {}
            /// Nested message and enum types in `CreateApp`.
            pub mod create_app {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(message, optional, tag = "1")]
                    pub app: ::core::option::Option<crate::model::account::auth::AppInfo>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    /// persistent key, that can be used to restore session via CreateSession or for JSON API
                    #[prost(string, tag = "2")]
                    pub app_key: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            AccountIsNotRunning = 101,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct RevokeApp {}
            /// Nested message and enum types in `RevokeApp`.
            pub mod revoke_app {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub app_hash: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            NotFound = 3,
                            AccountIsNotRunning = 101,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::NotFound => "NOT_FOUND",
                                    Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "NOT_FOUND" => Some(Self::NotFound),
                                    "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum NetworkMode {
            /// use network config that embedded in binary
            DefaultConfig = 0,
            /// disable any-sync network and use only local p2p nodes
            LocalOnly = 1,
            /// use config provided in networkConfigFilePath
            CustomConfig = 2,
        }
        impl NetworkMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::DefaultConfig => "DefaultConfig",
                    Self::LocalOnly => "LocalOnly",
                    Self::CustomConfig => "CustomConfig",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "DefaultConfig" => Some(Self::DefaultConfig),
                    "LocalOnly" => Some(Self::LocalOnly),
                    "CustomConfig" => Some(Self::CustomConfig),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Workspace {}
    /// Nested message and enum types in `Workspace`.
    pub mod workspace {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetCurrent {}
        /// Nested message and enum types in `GetCurrent`.
        pub mod get_current {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub workspace_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetAll {}
        /// Nested message and enum types in `GetAll`.
        pub mod get_all {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub workspace_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// object details
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// use case
                #[prost(
                    enumeration = "super::super::object::import_use_case::request::UseCase",
                    tag = "2"
                )]
                pub use_case: i32,
                /// deprecated, use spaceUxType
                #[prost(bool, tag = "3")]
                pub with_chat: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub starting_object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Open {}
        /// Nested message and enum types in `Open`.
        pub mod open {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                /// deprecated, chat will be created automatically if space is shared
                #[prost(bool, tag = "2")]
                pub with_chat: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub info: ::core::option::Option<crate::model::account::Info>,
                /// backup paths for corrupted space storage
                #[prost(string, repeated, tag = "3")]
                pub corrupted_backup_paths:
                    ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        FailedToLoad = 100,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::FailedToLoad => "FAILED_TO_LOAD",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "FAILED_TO_LOAD" => Some(Self::FailedToLoad),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Object {}
        /// Nested message and enum types in `Object`.
        pub mod object {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "2")]
                    pub space_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "1")]
                    pub object_id: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(string, tag = "2")]
                    pub object_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "3")]
                    pub details: ::core::option::Option<::prost_types::Struct>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ListAdd {}
            /// Nested message and enum types in `ListAdd`.
            pub mod list_add {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "2")]
                    pub space_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "1")]
                    pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(string, repeated, tag = "2")]
                    pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ListRemove {}
            /// Nested message and enum types in `ListRemove`.
            pub mod list_remove {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, repeated, tag = "1")]
                    pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(string, repeated, tag = "2")]
                    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetInfo {}
        /// Nested message and enum types in `SetInfo`.
        pub mod set_info {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Select {}
        /// Nested message and enum types in `Select`.
        pub mod select {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub workspace_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Export {}
        /// Nested message and enum types in `Export`.
        pub mod export {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// the path where export files will place
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub workspace_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Publishing {}
    /// Nested message and enum types in `Publishing`.
    pub mod publishing {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PublishState {
            #[prost(string, tag = "1")]
            pub space_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub object_id: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub uri: ::prost::alloc::string::String,
            #[prost(enumeration = "PublishStatus", tag = "4")]
            pub status: i32,
            #[prost(string, tag = "5")]
            pub version: ::prost::alloc::string::String,
            #[prost(int64, tag = "6")]
            pub timestamp: i64,
            #[prost(int64, tag = "7")]
            pub size: i64,
            #[prost(bool, tag = "8")]
            pub join_space: bool,
            #[prost(message, optional, tag = "9")]
            pub details: ::core::option::Option<::prost_types::Struct>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub uri: ::prost::alloc::string::String,
                #[prost(bool, tag = "4")]
                pub join_space: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub uri: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchObject = 101,
                        NoSuchSpace = 102,
                        LimitExceeded = 103,
                        UrlAlreadyTaken = 409,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchObject => "NO_SUCH_OBJECT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                                Self::LimitExceeded => "LIMIT_EXCEEDED",
                                Self::UrlAlreadyTaken => "URL_ALREADY_TAKEN",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_OBJECT" => Some(Self::NoSuchObject),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                "LIMIT_EXCEEDED" => Some(Self::LimitExceeded),
                                "URL_ALREADY_TAKEN" => Some(Self::UrlAlreadyTaken),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Remove {}
        /// Nested message and enum types in `Remove`.
        pub mod remove {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchObject = 101,
                        NoSuchSpace = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchObject => "NO_SUCH_OBJECT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_OBJECT" => Some(Self::NoSuchObject),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct List {}
        /// Nested message and enum types in `List`.
        pub mod list {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub publishes: ::prost::alloc::vec::Vec<super::PublishState>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchSpace = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResolveUri {}
        /// Nested message and enum types in `ResolveUri`.
        pub mod resolve_uri {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub uri: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub publish: ::core::option::Option<super::PublishState>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchUri = 101,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchUri => "NO_SUCH_URI",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_URI" => Some(Self::NoSuchUri),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetStatus {}
        /// Nested message and enum types in `GetStatus`.
        pub mod get_status {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub publish: ::core::option::Option<super::PublishState>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoSuchObject = 101,
                        NoSuchSpace = 102,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoSuchObject => "NO_SUCH_OBJECT",
                                Self::NoSuchSpace => "NO_SUCH_SPACE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_SUCH_OBJECT" => Some(Self::NoSuchObject),
                                "NO_SUCH_SPACE" => Some(Self::NoSuchSpace),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum PublishStatus {
            /// PublishStatusCreated means publish is created but not uploaded yet
            Created = 0,
            /// PublishStatusCreated means publish is active
            Published = 1,
        }
        impl PublishStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Created => "PublishStatusCreated",
                    Self::Published => "PublishStatusPublished",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PublishStatusCreated" => Some(Self::Created),
                    "PublishStatusPublished" => Some(Self::Published),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Object {}
    /// Nested message and enum types in `Object`.
    pub mod object {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Refresh {}
        /// Nested message and enum types in `Refresh`.
        pub mod refresh {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        ObjectDeleted = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::ObjectDeleted => "OBJECT_DELETED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "OBJECT_DELETED" => Some(Self::ObjectDeleted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Open {}
        /// Nested message and enum types in `Open`.
        pub mod open {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context blo1k
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub trace_id: ::prost::alloc::string::String,
                /// Required only for date objects
                #[prost(string, tag = "5")]
                pub space_id: ::prost::alloc::string::String,
                /// some clients may set this option instead if having the single subscription to all relations
                #[prost(bool, tag = "4")]
                pub include_relations_as_dependent_objects: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub object_view: ::core::option::Option<crate::model::ObjectView>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotFound = 3,
                        /// failed to read unknown data format â€“ need to upgrade anytype
                        AnytypeNeedsUpgrade = 10,
                        /// ...
                        ObjectDeleted = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotFound => "NOT_FOUND",
                                Self::AnytypeNeedsUpgrade => "ANYTYPE_NEEDS_UPGRADE",
                                Self::ObjectDeleted => "OBJECT_DELETED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_FOUND" => Some(Self::NotFound),
                                "ANYTYPE_NEEDS_UPGRADE" => Some(Self::AnytypeNeedsUpgrade),
                                "OBJECT_DELETED" => Some(Self::ObjectDeleted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Close {}
        /// Nested message and enum types in `Close`.
        pub mod close {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// deprecated, GO-1926
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                /// Required only for date objects
                #[prost(string, tag = "3")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Show {}
        /// Nested message and enum types in `Show`.
        pub mod show {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// deprecated, GO-1926
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub trace_id: ::prost::alloc::string::String,
                /// Required only for date objects
                #[prost(string, tag = "5")]
                pub space_id: ::prost::alloc::string::String,
                /// some clients may set this option instead if having the single subscription to all relations
                #[prost(bool, tag = "4")]
                pub include_relations_as_dependent_objects: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub object_view: ::core::option::Option<crate::model::ObjectView>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotFound = 3,
                        ObjectDeleted = 4,
                        /// failed to read unknown data format â€“ need to upgrade anytype
                        AnytypeNeedsUpgrade = 10,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotFound => "NOT_FOUND",
                                Self::ObjectDeleted => "OBJECT_DELETED",
                                Self::AnytypeNeedsUpgrade => "ANYTYPE_NEEDS_UPGRADE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_FOUND" => Some(Self::NotFound),
                                "OBJECT_DELETED" => Some(Self::ObjectDeleted),
                                "ANYTYPE_NEEDS_UPGRADE" => Some(Self::AnytypeNeedsUpgrade),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// object details
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(message, repeated, tag = "2")]
                pub internal_flags: ::prost::alloc::vec::Vec<crate::model::InternalFlag>,
                #[prost(string, tag = "3")]
                pub template_id: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub object_type_unique_key: ::prost::alloc::string::String,
                #[prost(bool, tag = "6")]
                pub with_chat: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "3")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "5")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateBookmark {}
        /// Nested message and enum types in `CreateBookmark`.
        pub mod create_bookmark {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub with_chat: bool,
                #[prost(string, tag = "4")]
                pub template_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateRelation {}
        /// Nested message and enum types in `CreateRelation`.
        pub mod create_relation {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub key: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateRelationOption {}
        /// Nested message and enum types in `CreateRelationOption`.
        pub mod create_relation_option {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateSet {}
        /// Nested message and enum types in `CreateSet`.
        pub mod create_set {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// if omitted the name of page will be the same with object type
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// optional template id for creating from template
                #[prost(string, tag = "3")]
                pub template_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub internal_flags: ::prost::alloc::vec::Vec<crate::model::InternalFlag>,
                #[prost(string, tag = "5")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "6")]
                pub with_chat: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "3")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "5")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        UnknownObjectTypeUrl = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::UnknownObjectTypeUrl => "UNKNOWN_OBJECT_TYPE_URL",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "UNKNOWN_OBJECT_TYPE_URL" => Some(Self::UnknownObjectTypeUrl),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateObjectType {}
        /// Nested message and enum types in `CreateObjectType`.
        pub mod create_object_type {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(message, repeated, tag = "2")]
                pub internal_flags: ::prost::alloc::vec::Vec<crate::model::InternalFlag>,
                #[prost(string, tag = "3")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, tag = "3")]
                pub object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateFromUrl {}
        /// Nested message and enum types in `CreateFromUrl`.
        pub mod create_from_url {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_type_unique_key: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub url: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(bool, tag = "5")]
                pub add_page_content: bool,
                #[prost(bool, tag = "6")]
                pub with_chat: bool,
                #[prost(string, tag = "7")]
                pub template_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(string, tag = "4")]
                pub chat_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChatAdd {}
        /// Nested message and enum types in `ChatAdd`.
        pub mod chat_add {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub chat_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct BookmarkFetch {}
        /// Nested message and enum types in `BookmarkFetch`.
        pub mod bookmark_fetch {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub url: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Duplicate {}
        /// Nested message and enum types in `Duplicate`.
        pub mod duplicate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// created template id
                #[prost(string, tag = "2")]
                pub id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct OpenBreadcrumbs {}
        /// Nested message and enum types in `OpenBreadcrumbs`.
        pub mod open_breadcrumbs {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// deprecated, GO-1926
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub trace_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "4")]
                pub object_view: ::core::option::Option<crate::model::ObjectView>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetBreadcrumbs {}
        /// Nested message and enum types in `SetBreadcrumbs`.
        pub mod set_breadcrumbs {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub breadcrumbs_id: ::prost::alloc::string::String,
                /// page ids
                #[prost(string, repeated, tag = "2")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ShareByLink {}
        /// Nested message and enum types in `ShareByLink`.
        pub mod share_by_link {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(string, tag = "1")]
                pub link: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// deprecated in favor of SearchWithMeta
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Search {}
        /// Nested message and enum types in `Search`.
        pub mod search {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "8")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "1")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                #[prost(message, repeated, tag = "2")]
                pub sorts: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Sort>,
                #[prost(string, tag = "3")]
                pub full_text: ::prost::alloc::string::String,
                #[prost(int32, tag = "4")]
                pub offset: i32,
                #[prost(int32, tag = "5")]
                pub limit: i32,
                /// additional filter by objectTypes
                ///
                /// DEPRECATED, GO-1926
                #[prost(string, repeated, tag = "6")]
                pub object_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// needed keys in details for return, when empty - will return all
                #[prost(string, repeated, tag = "7")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SearchWithMeta {}
        /// Nested message and enum types in `SearchWithMeta`.
        pub mod search_with_meta {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "11")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "1")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                #[prost(message, repeated, tag = "2")]
                pub sorts: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Sort>,
                #[prost(string, tag = "3")]
                pub full_text: ::prost::alloc::string::String,
                #[prost(int32, tag = "4")]
                pub offset: i32,
                #[prost(int32, tag = "5")]
                pub limit: i32,
                /// additional filter by objectTypes
                ///
                /// DEPRECATED, GO-1926
                #[prost(string, repeated, tag = "6")]
                pub object_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// needed keys in details for return, when empty - will return all
                #[prost(string, repeated, tag = "7")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// add ResultMeta to each result
                #[prost(bool, tag = "8")]
                pub return_meta: bool,
                /// add relation option details to meta
                #[prost(bool, tag = "9")]
                pub return_meta_relation_details: bool,
                /// DEPRECATED
                #[prost(bool, tag = "10")]
                pub return_html_highlights_instead_of_ranges: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub results: ::prost::alloc::vec::Vec<crate::model::search::Result>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Graph {}
        /// Nested message and enum types in `Graph`.
        pub mod graph {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, repeated, tag = "1")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                #[prost(int32, tag = "2")]
                pub limit: i32,
                /// additional filter by objectTypes
                ///
                /// DEPRECATED, GO-1926
                #[prost(string, repeated, tag = "3")]
                pub object_type_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, repeated, tag = "4")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "5")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "6")]
                pub collection_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "7")]
                pub set_source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "8")]
                pub include_type_edges: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Edge {
                #[prost(string, tag = "1")]
                pub source: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
                #[prost(enumeration = "edge::Type", tag = "4")]
                pub r#type: i32,
                #[prost(string, tag = "5")]
                pub description: ::prost::alloc::string::String,
                #[prost(string, tag = "6")]
                pub icon_image: ::prost::alloc::string::String,
                #[prost(string, tag = "7")]
                pub icon_emoji: ::prost::alloc::string::String,
                #[prost(bool, tag = "8")]
                pub hidden: bool,
            }
            /// Nested message and enum types in `Edge`.
            pub mod edge {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Type {
                    Link = 0,
                    Relation = 1,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Link => "Link",
                            Self::Relation => "Relation",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Link" => Some(Self::Link),
                            "Relation" => Some(Self::Relation),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub nodes: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(message, repeated, tag = "3")]
                pub edges: ::prost::alloc::vec::Vec<Edge>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SearchSubscribe {}
        /// Nested message and enum types in `SearchSubscribe`.
        pub mod search_subscribe {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "15")]
                pub space_id: ::prost::alloc::string::String,
                /// (optional) subscription identifier
                /// client can provide some string or middleware will generate it automatically
                /// if subId is already registered on middleware, the new query will replace previous subscription
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                /// filters
                #[prost(message, repeated, tag = "2")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                /// sorts
                #[prost(message, repeated, tag = "3")]
                pub sorts: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Sort>,
                /// results limit
                #[prost(int64, tag = "5")]
                pub limit: i64,
                /// initial offset; middleware will find afterId
                #[prost(int64, tag = "6")]
                pub offset: i64,
                /// (required)  needed keys in details for return, for object fields mw will return (and subscribe) objects as dependent
                #[prost(string, repeated, tag = "7")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// (optional) pagination: middleware will return results after given id
                #[prost(string, tag = "8")]
                pub after_id: ::prost::alloc::string::String,
                /// (optional) pagination: middleware will return results before given id
                #[prost(string, tag = "9")]
                pub before_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "10")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// disable dependent subscription
                #[prost(bool, tag = "13")]
                pub no_dep_subscription: bool,
                #[prost(string, tag = "14")]
                pub collection_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(message, repeated, tag = "3")]
                pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(string, tag = "4")]
                pub sub_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub counters: ::core::option::Option<
                    super::super::super::event::object::subscription::Counters,
                >,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CrossSpaceSearchSubscribe {}
        /// Nested message and enum types in `CrossSpaceSearchSubscribe`.
        pub mod cross_space_search_subscribe {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// (optional) subscription identifier
                /// client can provide some string or middleware will generate it automatically
                /// if subId is already registered on middleware, the new query will replace previous subscription
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                /// filters
                #[prost(message, repeated, tag = "2")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                /// sorts
                #[prost(message, repeated, tag = "3")]
                pub sorts: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Sort>,
                /// (required)  needed keys in details for return, for object fields mw will return (and subscribe) objects as dependent
                #[prost(string, repeated, tag = "7")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, repeated, tag = "10")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// disable dependent subscription
                #[prost(bool, tag = "13")]
                pub no_dep_subscription: bool,
                #[prost(string, tag = "14")]
                pub collection_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(message, repeated, tag = "3")]
                pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(string, tag = "4")]
                pub sub_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub counters: ::core::option::Option<
                    super::super::super::event::object::subscription::Counters,
                >,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CrossSpaceSearchUnsubscribe {}
        /// Nested message and enum types in `CrossSpaceSearchUnsubscribe`.
        pub mod cross_space_search_unsubscribe {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GroupsSubscribe {}
        /// Nested message and enum types in `GroupsSubscribe`.
        pub mod groups_subscribe {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "6")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub filters:
                    ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Filter>,
                #[prost(string, repeated, tag = "4")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "5")]
                pub collection_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub groups: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::Group>,
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SubscribeIds {}
        /// Nested message and enum types in `SubscribeIds`.
        pub mod subscribe_ids {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "13")]
                pub space_id: ::prost::alloc::string::String,
                /// (optional) subscription identifier
                /// client can provide some string or middleware will generate it automatically
                /// if subId is already registered on middleware, the new query will replace previous subscription
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
                /// ids for subscribe
                #[prost(string, repeated, tag = "2")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// sorts
                /// (required)  needed keys in details for return, for object fields mw will return (and subscribe) objects as dependent
                #[prost(string, repeated, tag = "3")]
                pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// disable dependent subscription
                #[prost(bool, tag = "12")]
                pub no_dep_subscription: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub records: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(message, repeated, tag = "3")]
                pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                #[prost(string, tag = "4")]
                pub sub_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SearchUnsubscribe {}
        /// Nested message and enum types in `SearchUnsubscribe`.
        pub mod search_unsubscribe {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetLayout {}
        /// Nested message and enum types in `SetLayout`.
        pub mod set_layout {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::object_type::Layout", tag = "3")]
                pub layout: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetIsFavorite {}
        /// Nested message and enum types in `SetIsFavorite`.
        pub mod set_is_favorite {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub is_favorite: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetIsArchived {}
        /// Nested message and enum types in `SetIsArchived`.
        pub mod set_is_archived {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub is_archived: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetSource {}
        /// Nested message and enum types in `SetSource`.
        pub mod set_source {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "4")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct WorkspaceSetDashboard {}
        /// Nested message and enum types in `WorkspaceSetDashboard`.
        pub mod workspace_set_dashboard {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(string, tag = "3")]
                pub object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetObjectType {}
        /// Nested message and enum types in `SetObjectType`.
        pub mod set_object_type {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub object_type_unique_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetInternalFlags {}
        /// Nested message and enum types in `SetInternalFlags`.
        pub mod set_internal_flags {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "7")]
                pub internal_flags: ::prost::alloc::vec::Vec<crate::model::InternalFlag>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetDetails {}
        /// Nested message and enum types in `SetDetails`.
        pub mod set_details {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub details: ::prost::alloc::vec::Vec<crate::model::Detail>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ToSet {}
        /// Nested message and enum types in `ToSet`.
        pub mod to_set {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ToCollection {}
        /// Nested message and enum types in `ToCollection`.
        pub mod to_collection {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// Available undo/redo operations
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UndoRedoCounter {
            #[prost(int32, tag = "1")]
            pub undo: i32,
            #[prost(int32, tag = "2")]
            pub redo: i32,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Undo {}
        /// Nested message and enum types in `Undo`.
        pub mod undo {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "3")]
                pub counters: ::core::option::Option<super::UndoRedoCounter>,
                #[prost(string, tag = "4")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub range: ::core::option::Option<crate::model::Range>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        CanNotMove = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotMove => "CAN_NOT_MOVE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_MOVE" => Some(Self::CanNotMove),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Redo {}
        /// Nested message and enum types in `Redo`.
        pub mod redo {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "3")]
                pub counters: ::core::option::Option<super::UndoRedoCounter>,
                #[prost(string, tag = "4")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub range: ::core::option::Option<crate::model::Range>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        CanNotMove = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotMove => "CAN_NOT_MOVE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_MOVE" => Some(Self::CanNotMove),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListDuplicate {}
        /// Nested message and enum types in `ListDuplicate`.
        pub mod list_duplicate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListDelete {}
        /// Nested message and enum types in `ListDelete`.
        pub mod list_delete {
            /// Deletes the object, keys from the local store and unsubscribe from remote changes. Also offloads all orphan files
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// objects to remove
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetIsArchived {}
        /// Nested message and enum types in `ListSetIsArchived`.
        pub mod list_set_is_archived {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "2")]
                pub is_archived: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetIsFavorite {}
        /// Nested message and enum types in `ListSetIsFavorite`.
        pub mod list_set_is_favorite {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "2")]
                pub is_favorite: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetObjectType {}
        /// Nested message and enum types in `ListSetObjectType`.
        pub mod list_set_object_type {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "2")]
                pub object_type_unique_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetDetails {}
        /// Nested message and enum types in `ListSetDetails`.
        pub mod list_set_details {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(message, repeated, tag = "2")]
                pub details: ::prost::alloc::vec::Vec<crate::model::Detail>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListModifyDetailValues {}
        /// Nested message and enum types in `ListModifyDetailValues`.
        pub mod list_modify_detail_values {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(message, repeated, tag = "2")]
                pub operations: ::prost::alloc::vec::Vec<request::Operation>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Operation {
                    #[prost(string, tag = "1")]
                    pub relation_key: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "2")]
                    pub add: ::core::option::Option<::prost_types::Value>,
                    #[prost(message, optional, tag = "3")]
                    pub set: ::core::option::Option<::prost_types::Value>,
                    #[prost(message, optional, tag = "4")]
                    pub remove: ::core::option::Option<::prost_types::Value>,
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ApplyTemplate {}
        /// Nested message and enum types in `ApplyTemplate`.
        pub mod apply_template {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of template
                #[prost(string, tag = "2")]
                pub template_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListExport {}
        /// Nested message and enum types in `ListExport`.
        pub mod list_export {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "10")]
                pub space_id: ::prost::alloc::string::String,
                /// the path where export files will place
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
                /// ids of documents for export, when empty - will export all available docs
                #[prost(string, repeated, tag = "2")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// export format
                #[prost(enumeration = "crate::model::export::Format", tag = "3")]
                pub format: i32,
                /// save as zip file
                #[prost(bool, tag = "4")]
                pub zip: bool,
                /// include all nested
                #[prost(bool, tag = "5")]
                pub include_nested: bool,
                /// include all files
                #[prost(bool, tag = "6")]
                pub include_files: bool,
                /// for protobuf export
                #[prost(bool, tag = "7")]
                pub is_json: bool,
                /// for migration
                #[prost(bool, tag = "9")]
                pub include_archived: bool,
                /// for integrations like raycast and web publishing
                #[prost(bool, tag = "11")]
                pub no_progress: bool,
                #[prost(message, optional, tag = "12")]
                pub links_state_filters: ::core::option::Option<StateFilters>,
                #[prost(bool, tag = "13")]
                pub include_backlinks: bool,
                #[prost(bool, tag = "14")]
                pub include_space: bool,
                /// include properties frontmatter and schema in directory for markdown export
                #[prost(bool, tag = "15")]
                pub md_include_properties_and_schema: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct StateFilters {
                #[prost(message, repeated, tag = "1")]
                pub relations_white_list: ::prost::alloc::vec::Vec<RelationsWhiteList>,
                #[prost(bool, tag = "2")]
                pub remove_blocks: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct RelationsWhiteList {
                #[prost(enumeration = "crate::model::object_type::Layout", tag = "1")]
                pub layout: i32,
                #[prost(string, repeated, tag = "2")]
                pub allowed_relations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                #[prost(int32, tag = "4")]
                pub succeed: i32,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Export {}
        /// Nested message and enum types in `Export`.
        pub mod export {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "10")]
                pub space_id: ::prost::alloc::string::String,
                /// ids of documents for export, when empty - will export all available docs
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                /// export format
                #[prost(enumeration = "crate::model::export::Format", tag = "3")]
                pub format: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub result: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Import {}
        /// Nested message and enum types in `Import`.
        pub mod import {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "14")]
                pub space_id: ::prost::alloc::string::String,
                /// optional, for external developers usage
                #[prost(message, repeated, tag = "8")]
                pub snapshots: ::prost::alloc::vec::Vec<request::Snapshot>,
                #[prost(bool, tag = "9")]
                pub update_existing_objects: bool,
                #[prost(enumeration = "crate::model::import::Type", tag = "10")]
                pub r#type: i32,
                #[prost(enumeration = "request::Mode", tag = "11")]
                pub mode: i32,
                #[prost(bool, tag = "12")]
                pub no_progress: bool,
                #[prost(bool, tag = "13")]
                pub is_migration: bool,
                #[prost(bool, tag = "15")]
                pub is_new_space: bool,
                #[prost(oneof = "request::Params", tags = "1, 2, 3, 4, 5, 6, 7")]
                pub params: ::core::option::Option<request::Params>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct NotionParams {
                    #[prost(string, tag = "1")]
                    pub api_key: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct MarkdownParams {
                    #[prost(string, repeated, tag = "1")]
                    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    #[prost(bool, tag = "2")]
                    pub create_directory_pages: bool,
                    #[prost(bool, tag = "3")]
                    pub include_properties_as_block: bool,
                    #[prost(bool, tag = "4")]
                    pub no_collection: bool,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct BookmarksParams {
                    #[prost(string, tag = "1")]
                    pub url: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct HtmlParams {
                    #[prost(string, repeated, tag = "1")]
                    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct TxtParams {
                    #[prost(string, repeated, tag = "1")]
                    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct PbParams {
                    #[prost(string, repeated, tag = "1")]
                    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    #[prost(bool, tag = "2")]
                    pub no_collection: bool,
                    #[prost(string, tag = "3")]
                    pub collection_title: ::prost::alloc::string::String,
                    #[prost(enumeration = "pb_params::Type", tag = "4")]
                    pub import_type: i32,
                }
                /// Nested message and enum types in `PbParams`.
                pub mod pb_params {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Type {
                        Space = 0,
                        Experience = 1,
                    }
                    impl Type {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Space => "SPACE",
                                Self::Experience => "EXPERIENCE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "SPACE" => Some(Self::Space),
                                "EXPERIENCE" => Some(Self::Experience),
                                _ => None,
                            }
                        }
                    }
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct CsvParams {
                    #[prost(string, repeated, tag = "1")]
                    pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    #[prost(enumeration = "csv_params::Mode", tag = "2")]
                    pub mode: i32,
                    #[prost(bool, tag = "3")]
                    pub use_first_row_for_relations: bool,
                    #[prost(string, tag = "4")]
                    pub delimiter: ::prost::alloc::string::String,
                    #[prost(bool, tag = "5")]
                    pub transpose_rows_and_columns: bool,
                }
                /// Nested message and enum types in `CsvParams`.
                pub mod csv_params {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Mode {
                        Collection = 0,
                        Table = 1,
                    }
                    impl Mode {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Collection => "COLLECTION",
                                Self::Table => "TABLE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "COLLECTION" => Some(Self::Collection),
                                "TABLE" => Some(Self::Table),
                                _ => None,
                            }
                        }
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Snapshot {
                    #[prost(string, tag = "1")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "2")]
                    pub snapshot: ::core::option::Option<crate::model::SmartBlockSnapshotBase>,
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Mode {
                    AllOrNothing = 0,
                    IgnoreErrors = 1,
                }
                impl Mode {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::AllOrNothing => "ALL_OR_NOTHING",
                            Self::IgnoreErrors => "IGNORE_ERRORS",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "ALL_OR_NOTHING" => Some(Self::AllOrNothing),
                            "IGNORE_ERRORS" => Some(Self::IgnoreErrors),
                            _ => None,
                        }
                    }
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Params {
                    #[prost(message, tag = "1")]
                    NotionParams(NotionParams),
                    /// for internal use
                    #[prost(message, tag = "2")]
                    BookmarksParams(BookmarksParams),
                    #[prost(message, tag = "3")]
                    MarkdownParams(MarkdownParams),
                    #[prost(message, tag = "4")]
                    HtmlParams(HtmlParams),
                    #[prost(message, tag = "5")]
                    TxtParams(TxtParams),
                    #[prost(message, tag = "6")]
                    PbParams(PbParams),
                    #[prost(message, tag = "7")]
                    CsvParams(CsvParams),
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                /// deprecated
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// deprecated
                #[prost(string, tag = "2")]
                pub collection_id: ::prost::alloc::string::String,
                /// deprecated
                #[prost(int64, tag = "3")]
                pub objects_count: i64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                        NoObjectsToImport = 5,
                        ImportIsCanceled = 6,
                        LimitOfRowsOrRelationsExceeded = 7,
                        FileLoadError = 8,
                        InsufficientPermissions = 9,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                                Self::NoObjectsToImport => "NO_OBJECTS_TO_IMPORT",
                                Self::ImportIsCanceled => "IMPORT_IS_CANCELED",
                                Self::LimitOfRowsOrRelationsExceeded => {
                                    "LIMIT_OF_ROWS_OR_RELATIONS_EXCEEDED"
                                }
                                Self::FileLoadError => "FILE_LOAD_ERROR",
                                Self::InsufficientPermissions => "INSUFFICIENT_PERMISSIONS",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                "NO_OBJECTS_TO_IMPORT" => Some(Self::NoObjectsToImport),
                                "IMPORT_IS_CANCELED" => Some(Self::ImportIsCanceled),
                                "LIMIT_OF_ROWS_OR_RELATIONS_EXCEEDED" => {
                                    Some(Self::LimitOfRowsOrRelationsExceeded)
                                }
                                "FILE_LOAD_ERROR" => Some(Self::FileLoadError),
                                "INSUFFICIENT_PERMISSIONS" => Some(Self::InsufficientPermissions),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Notion {}
            /// Nested message and enum types in `Notion`.
            pub mod notion {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ValidateToken {}
                /// Nested message and enum types in `ValidateToken`.
                pub mod validate_token {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Request {
                        #[prost(string, tag = "1")]
                        pub token: ::prost::alloc::string::String,
                    }
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Response {
                        #[prost(message, optional, tag = "1")]
                        pub error: ::core::option::Option<response::Error>,
                    }
                    /// Nested message and enum types in `Response`.
                    pub mod response {
                        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                        pub struct Error {
                            #[prost(enumeration = "error::Code", tag = "1")]
                            pub code: i32,
                            #[prost(string, tag = "2")]
                            pub description: ::prost::alloc::string::String,
                        }
                        /// Nested message and enum types in `Error`.
                        pub mod error {
                            #[derive(
                                Clone,
                                Copy,
                                Debug,
                                PartialEq,
                                Eq,
                                Hash,
                                PartialOrd,
                                Ord,
                                ::prost::Enumeration,
                            )]
                            #[repr(i32)]
                            pub enum Code {
                                Null = 0,
                                UnknownError = 1,
                                BadInput = 2,
                                InternalError = 3,
                                Unauthorized = 4,
                                Forbidden = 5,
                                ServiceUnavailable = 6,
                                AccountIsNotRunning = 7,
                            }
                            impl Code {
                                /// String value of the enum field names used in the ProtoBuf definition.
                                ///
                                /// The values are not transformed in any way and thus are considered stable
                                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                                pub fn as_str_name(&self) -> &'static str {
                                    match self {
                                        Self::Null => "NULL",
                                        Self::UnknownError => "UNKNOWN_ERROR",
                                        Self::BadInput => "BAD_INPUT",
                                        Self::InternalError => "INTERNAL_ERROR",
                                        Self::Unauthorized => "UNAUTHORIZED",
                                        Self::Forbidden => "FORBIDDEN",
                                        Self::ServiceUnavailable => "SERVICE_UNAVAILABLE",
                                        Self::AccountIsNotRunning => "ACCOUNT_IS_NOT_RUNNING",
                                    }
                                }
                                /// Creates an enum from field names used in the ProtoBuf definition.
                                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                    match value {
                                        "NULL" => Some(Self::Null),
                                        "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                        "BAD_INPUT" => Some(Self::BadInput),
                                        "INTERNAL_ERROR" => Some(Self::InternalError),
                                        "UNAUTHORIZED" => Some(Self::Unauthorized),
                                        "FORBIDDEN" => Some(Self::Forbidden),
                                        "SERVICE_UNAVAILABLE" => Some(Self::ServiceUnavailable),
                                        "ACCOUNT_IS_NOT_RUNNING" => Some(Self::AccountIsNotRunning),
                                        _ => None,
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ImportList {}
        /// Nested message and enum types in `ImportList`.
        pub mod import_list {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub response: ::prost::alloc::vec::Vec<ImportResponse>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ImportResponse {
                #[prost(enumeration = "import_response::Type", tag = "1")]
                pub r#type: i32,
            }
            /// Nested message and enum types in `ImportResponse`.
            pub mod import_response {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Type {
                    Notion = 0,
                    Markdown = 1,
                    Html = 2,
                    Txt = 3,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Notion => "Notion",
                            Self::Markdown => "Markdown",
                            Self::Html => "Html",
                            Self::Txt => "Txt",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Notion" => Some(Self::Notion),
                            "Markdown" => Some(Self::Markdown),
                            "Html" => Some(Self::Html),
                            "Txt" => Some(Self::Txt),
                            _ => None,
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ImportUseCase {}
        /// Nested message and enum types in `ImportUseCase`.
        pub mod import_use_case {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(enumeration = "request::UseCase", tag = "1")]
                pub use_case: i32,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum UseCase {
                    None = 0,
                    GetStarted = 1,
                    DataSpace = 2,
                    /// only the guide without other tables
                    GuideOnly = 3,
                    GetStartedMobile = 4,
                    ChatSpace = 5,
                    DataSpaceMobile = 6,
                }
                impl UseCase {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::None => "NONE",
                            Self::GetStarted => "GET_STARTED",
                            Self::DataSpace => "DATA_SPACE",
                            Self::GuideOnly => "GUIDE_ONLY",
                            Self::GetStartedMobile => "GET_STARTED_MOBILE",
                            Self::ChatSpace => "CHAT_SPACE",
                            Self::DataSpaceMobile => "DATA_SPACE_MOBILE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "NONE" => Some(Self::None),
                            "GET_STARTED" => Some(Self::GetStarted),
                            "DATA_SPACE" => Some(Self::DataSpace),
                            "GUIDE_ONLY" => Some(Self::GuideOnly),
                            "GET_STARTED_MOBILE" => Some(Self::GetStartedMobile),
                            "CHAT_SPACE" => Some(Self::ChatSpace),
                            "DATA_SPACE_MOBILE" => Some(Self::DataSpaceMobile),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(string, tag = "3")]
                pub starting_object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ImportExperience {}
        /// Nested message and enum types in `ImportExperience`.
        pub mod import_experience {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub url: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub title: ::prost::alloc::string::String,
                #[prost(bool, tag = "4")]
                pub is_new_space: bool,
                #[prost(bool, tag = "5")]
                pub is_ai: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InsufficientPermission = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InsufficientPermission => "INSUFFICIENT_PERMISSION",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INSUFFICIENT_PERMISSION" => Some(Self::InsufficientPermission),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DateByTimestamp {}
        /// Nested message and enum types in `DateByTimestamp`.
        pub mod date_by_timestamp {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(int64, tag = "2")]
                pub timestamp: i64,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ObjectCollection {}
    /// Nested message and enum types in `ObjectCollection`.
    pub mod object_collection {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Add {}
        /// Nested message and enum types in `Add`.
        pub mod add {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub after_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "3")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Remove {}
        /// Nested message and enum types in `Remove`.
        pub mod remove {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Sort {}
        /// Nested message and enum types in `Sort`.
        pub mod sort {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ObjectRelation {}
    /// Nested message and enum types in `ObjectRelation`.
    pub mod object_relation {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Add {}
        /// Nested message and enum types in `Add`.
        pub mod add {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Delete {}
        /// Nested message and enum types in `Delete`.
        pub mod delete {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListAvailable {}
        /// Nested message and enum types in `ListAvailable`.
        pub mod list_available {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub relations: ::prost::alloc::vec::Vec<crate::model::Relation>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AddFeatured {}
        /// Nested message and enum types in `AddFeatured`.
        pub mod add_featured {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RemoveFeatured {}
        /// Nested message and enum types in `RemoveFeatured`.
        pub mod remove_featured {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub relations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ObjectType {}
    /// Nested message and enum types in `ObjectType`.
    pub mod object_type {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Relation {}
        /// Nested message and enum types in `Relation`.
        pub mod relation {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub object_type_url: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, repeated, tag = "2")]
                    pub relations: ::prost::alloc::vec::Vec<crate::model::Relation>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            /// ...
                            ReadonlyObjectType = 3,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::ReadonlyObjectType => "READONLY_OBJECT_TYPE",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "READONLY_OBJECT_TYPE" => Some(Self::ReadonlyObjectType),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {}
            /// Nested message and enum types in `Remove`.
            pub mod remove {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub object_type_url: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            /// ...
                            ReadonlyObjectType = 3,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::ReadonlyObjectType => "READONLY_OBJECT_TYPE",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "READONLY_OBJECT_TYPE" => Some(Self::ReadonlyObjectType),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Recommended {}
        /// Nested message and enum types in `Recommended`.
        pub mod recommended {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct RelationsSet {}
            /// Nested message and enum types in `RelationsSet`.
            pub mod relations_set {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub type_object_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub relation_object_ids:
                        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            /// ...
                            ReadonlyObjectType = 3,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::ReadonlyObjectType => "READONLY_OBJECT_TYPE",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "READONLY_OBJECT_TYPE" => Some(Self::ReadonlyObjectType),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct FeaturedRelationsSet {}
            /// Nested message and enum types in `FeaturedRelationsSet`.
            pub mod featured_relations_set {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub type_object_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub relation_object_ids:
                        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            /// ...
                            ReadonlyObjectType = 3,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::ReadonlyObjectType => "READONLY_OBJECT_TYPE",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "READONLY_OBJECT_TYPE" => Some(Self::ReadonlyObjectType),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListConflictingRelations {}
        /// Nested message and enum types in `ListConflictingRelations`.
        pub mod list_conflicting_relations {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub type_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub relation_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        ReadonlyObjectType = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::ReadonlyObjectType => "READONLY_OBJECT_TYPE",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "READONLY_OBJECT_TYPE" => Some(Self::ReadonlyObjectType),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResolveLayoutConflicts {}
        /// Nested message and enum types in `ResolveLayoutConflicts`.
        pub mod resolve_layout_conflicts {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub type_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetOrder {}
        /// Nested message and enum types in `SetOrder`.
        pub mod set_order {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub type_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// final list of order ids
                #[prost(string, repeated, tag = "2")]
                pub order_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Relation {}
    /// Nested message and enum types in `Relation`.
    pub mod relation {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListRemoveOption {}
        /// Nested message and enum types in `ListRemoveOption`.
        pub mod list_remove_option {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub option_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "2")]
                pub check_in_objects: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        OptionUsedByObjects = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::OptionUsedByObjects => "OPTION_USED_BY_OBJECTS",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "OPTION_USED_BY_OBJECTS" => Some(Self::OptionUsedByObjects),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Options {}
        /// Nested message and enum types in `Options`.
        pub mod options {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub relation_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub options: ::core::option::Option<crate::model::RelationOptions>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Option {}
        /// Nested message and enum types in `Option`.
        pub mod option {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SetOrder {}
            /// Nested message and enum types in `SetOrder`.
            pub mod set_order {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub space_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub relation_key: ::prost::alloc::string::String,
                    /// result order of relation option ids
                    #[prost(string, repeated, tag = "3")]
                    pub relation_option_order:
                        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    /// final order of relation option ids with their lexids
                    #[prost(string, repeated, tag = "2")]
                    pub relation_option_order:
                        ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListWithValue {}
        /// Nested message and enum types in `ListWithValue`.
        pub mod list_with_value {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub value: ::core::option::Option<::prost_types::Value>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub list: ::prost::alloc::vec::Vec<response::ResponseItem>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ResponseItem {
                    #[prost(string, tag = "1")]
                    pub relation_key: ::prost::alloc::string::String,
                    #[prost(int64, tag = "2")]
                    pub counter: i64,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct History {}
    /// Nested message and enum types in `History`.
    pub mod history {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Version {
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub previous_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, tag = "3")]
            pub author_id: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub author_name: ::prost::alloc::string::String,
            #[prost(int64, tag = "5")]
            pub time: i64,
            #[prost(int64, tag = "6")]
            pub group_id: i64,
        }
        /// returns list of versions (changes)
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetVersions {}
        /// Nested message and enum types in `GetVersions`.
        pub mod get_versions {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                /// when indicated, results will include versions before given id
                #[prost(string, tag = "2")]
                pub last_version_id: ::prost::alloc::string::String,
                /// desired count of versions
                #[prost(int32, tag = "3")]
                pub limit: i32,
                #[prost(bool, tag = "4")]
                pub not_include_version: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub versions: ::prost::alloc::vec::Vec<super::Version>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// returns blockShow event for given version
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ShowVersion {}
        /// Nested message and enum types in `ShowVersion`.
        pub mod show_version {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub version_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub trace_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub object_view: ::core::option::Option<crate::model::ObjectView>,
                #[prost(message, optional, tag = "3")]
                pub version: ::core::option::Option<super::Version>,
                #[prost(string, tag = "4")]
                pub trace_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetVersion {}
        /// Nested message and enum types in `SetVersion`.
        pub mod set_version {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub version_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DiffVersions {}
        /// Nested message and enum types in `DiffVersions`.
        pub mod diff_versions {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub current_version: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub previous_version: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub history_events: ::prost::alloc::vec::Vec<super::super::super::event::Message>,
                #[prost(message, optional, tag = "3")]
                pub object_view: ::core::option::Option<crate::model::ObjectView>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct File {}
    /// Nested message and enum types in `File`.
    pub mod file {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Reconcile {}
        /// Nested message and enum types in `Reconcile`.
        pub mod reconcile {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Offload {}
        /// Nested message and enum types in `Offload`.
        pub mod offload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub include_not_pinned: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(uint64, tag = "2")]
                pub bytes_offloaded: u64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        NodeNotStarted = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NodeNotStarted => "NODE_NOT_STARTED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NODE_NOT_STARTED" => Some(Self::NodeNotStarted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SpaceOffload {}
        /// Nested message and enum types in `SpaceOffload`.
        pub mod space_offload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(int32, tag = "2")]
                pub files_offloaded: i32,
                #[prost(uint64, tag = "3")]
                pub bytes_offloaded: u64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        NodeNotStarted = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NodeNotStarted => "NODE_NOT_STARTED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NODE_NOT_STARTED" => Some(Self::NodeNotStarted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListOffload {}
        /// Nested message and enum types in `ListOffload`.
        pub mod list_offload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// empty means all
                #[prost(string, repeated, tag = "1")]
                pub only_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// false mean not-yet-pinned files will be not
                #[prost(bool, tag = "2")]
                pub include_not_pinned: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(int32, tag = "2")]
                pub files_offloaded: i32,
                #[prost(uint64, tag = "3")]
                pub bytes_offloaded: u64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        NodeNotStarted = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NodeNotStarted => "NODE_NOT_STARTED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NODE_NOT_STARTED" => Some(Self::NodeNotStarted),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Upload {}
        /// Nested message and enum types in `Upload`.
        pub mod upload {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "6")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "1")]
                pub url: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub local_path: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::content::file::Type", tag = "3")]
                pub r#type: i32,
                /// deprecated, has no affect, GO-1926
                #[prost(bool, tag = "4")]
                pub disable_encryption: bool,
                #[prost(enumeration = "crate::model::block::content::file::Style", tag = "5")]
                pub style: i32,
                /// additional details for file object
                #[prost(message, optional, tag = "7")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                #[prost(enumeration = "crate::model::ObjectOrigin", tag = "8")]
                pub origin: i32,
                #[prost(enumeration = "crate::model::ImageKind", tag = "9")]
                pub image_kind: i32,
                /// if true, only async preload the file without creating object
                #[prost(bool, tag = "10")]
                pub preload_only: bool,
                /// if set, reuse already preloaded file with this id. May block if async preload operation is not finished yet
                #[prost(string, tag = "11")]
                pub preload_file_id: ::prost::alloc::string::String,
                /// Object ID where the file was initially created
                #[prost(string, tag = "12")]
                pub created_in_context: ::prost::alloc::string::String,
                /// Block ID where the file was initially created
                #[prost(string, tag = "13")]
                pub created_in_context_ref: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// returned when preloadOnly is true, can be passed back in subsequent requests
                #[prost(string, tag = "4")]
                pub preload_file_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DiscardPreload {}
        /// Nested message and enum types in `DiscardPreload`.
        pub mod discard_preload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub file_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Download {}
        /// Nested message and enum types in `Download`.
        pub mod download {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                /// path to save file. Temp directory is used if empty
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub local_path: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Drop {}
        /// Nested message and enum types in `Drop`.
        pub mod drop {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the simple block to insert considering position
                #[prost(string, tag = "2")]
                pub drop_target_id: ::prost::alloc::string::String,
                /// position relatively to the dropTargetId simple block
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
                #[prost(enumeration = "crate::model::block::content::file::Style", tag = "5")]
                pub style: i32,
                #[prost(string, repeated, tag = "4")]
                pub local_file_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SpaceUsage {}
        /// Nested message and enum types in `SpaceUsage`.
        pub mod space_usage {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub usage: ::core::option::Option<response::Usage>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Usage {
                    #[prost(uint64, tag = "1")]
                    pub files_count: u64,
                    #[prost(uint64, tag = "2")]
                    pub cids_count: u64,
                    #[prost(uint64, tag = "3")]
                    pub bytes_usage: u64,
                    #[prost(uint64, tag = "4")]
                    pub bytes_left: u64,
                    #[prost(uint64, tag = "5")]
                    pub bytes_limit: u64,
                    #[prost(uint64, tag = "6")]
                    pub local_bytes_usage: u64,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NodeUsage {}
        /// Nested message and enum types in `NodeUsage`.
        pub mod node_usage {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub usage: ::core::option::Option<response::Usage>,
                #[prost(message, repeated, tag = "3")]
                pub spaces: ::prost::alloc::vec::Vec<response::Space>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Usage {
                    #[prost(uint64, tag = "1")]
                    pub files_count: u64,
                    #[prost(uint64, tag = "2")]
                    pub cids_count: u64,
                    #[prost(uint64, tag = "3")]
                    pub bytes_usage: u64,
                    #[prost(uint64, tag = "4")]
                    pub bytes_left: u64,
                    #[prost(uint64, tag = "5")]
                    pub bytes_limit: u64,
                    #[prost(uint64, tag = "6")]
                    pub local_bytes_usage: u64,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Space {
                    #[prost(string, tag = "1")]
                    pub space_id: ::prost::alloc::string::String,
                    #[prost(uint64, tag = "2")]
                    pub files_count: u64,
                    #[prost(uint64, tag = "3")]
                    pub cids_count: u64,
                    #[prost(uint64, tag = "4")]
                    pub bytes_usage: u64,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetAutoDownload {}
        /// Nested message and enum types in `SetAutoDownload`.
        pub mod set_auto_download {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(bool, tag = "1")]
                pub enabled: bool,
                #[prost(bool, tag = "2")]
                pub wifi_only: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CacheDownload {}
        /// Nested message and enum types in `CacheDownload`.
        pub mod cache_download {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub file_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CacheCancelDownload {}
        /// Nested message and enum types in `CacheCancelDownload`.
        pub mod cache_cancel_download {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub file_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AutoDownloadSetLimit {}
        /// Nested message and enum types in `AutoDownloadSetLimit`.
        pub mod auto_download_set_limit {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// 0 = no limit, >0 = max file size in mebibytes
                #[prost(int64, tag = "1")]
                pub size_limit_mebibytes: i64,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Navigation {}
    /// Nested message and enum types in `Navigation`.
    pub mod navigation {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListObjects {}
        /// Nested message and enum types in `ListObjects`.
        pub mod list_objects {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(enumeration = "super::Context", tag = "1")]
                pub context: i32,
                #[prost(string, tag = "2")]
                pub full_text: ::prost::alloc::string::String,
                #[prost(int32, tag = "3")]
                pub limit: i32,
                #[prost(int32, tag = "4")]
                pub offset: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub objects: ::prost::alloc::vec::Vec<crate::model::ObjectInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// Get the info for page alongside with info for all inbound and outbound links from/to this page
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetObjectInfoWithLinks {}
        /// Nested message and enum types in `GetObjectInfoWithLinks`.
        pub mod get_object_info_with_links {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(enumeration = "super::Context", tag = "2")]
                pub context: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub object: ::core::option::Option<crate::model::ObjectInfoWithLinks>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Context {
            Navigation = 0,
            /// do not show sets/archive
            MoveTo = 1,
            /// same for mention, do not show sets/archive
            LinkTo = 2,
        }
        impl Context {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Navigation => "Navigation",
                    Self::MoveTo => "MoveTo",
                    Self::LinkTo => "LinkTo",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Navigation" => Some(Self::Navigation),
                    "MoveTo" => Some(Self::MoveTo),
                    "LinkTo" => Some(Self::LinkTo),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Template {}
    /// Nested message and enum types in `Template`.
    pub mod template {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateFromObject {}
        /// Nested message and enum types in `CreateFromObject`.
        pub mod create_from_object {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of block for making them template
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// created template id
                #[prost(string, tag = "2")]
                pub id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Clone {}
        /// Nested message and enum types in `Clone`.
        pub mod clone {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of template block for cloning
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// created template id
                #[prost(string, tag = "2")]
                pub id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ExportAll {}
        /// Nested message and enum types in `ExportAll`.
        pub mod export_all {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// the path where export files will place
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LinkPreview {}
    /// Nested message and enum types in `LinkPreview`.
    pub mod link_preview {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Request {
            #[prost(string, tag = "1")]
            pub url: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Response {
            #[prost(message, optional, tag = "1")]
            pub error: ::core::option::Option<response::Error>,
            #[prost(message, optional, tag = "2")]
            pub link_preview: ::core::option::Option<crate::model::LinkPreview>,
        }
        /// Nested message and enum types in `Response`.
        pub mod response {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Error {
                #[prost(enumeration = "error::Code", tag = "1")]
                pub code: i32,
                #[prost(string, tag = "2")]
                pub description: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Error`.
            pub mod error {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Code {
                    Null = 0,
                    UnknownError = 1,
                    BadInput = 2,
                    PrivateLink = 3,
                }
                impl Code {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Null => "NULL",
                            Self::UnknownError => "UNKNOWN_ERROR",
                            Self::BadInput => "BAD_INPUT",
                            Self::PrivateLink => "PRIVATE_LINK",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "NULL" => Some(Self::Null),
                            "UNKNOWN_ERROR" => Some(Self::UnknownError),
                            "BAD_INPUT" => Some(Self::BadInput),
                            "PRIVATE_LINK" => Some(Self::PrivateLink),
                            _ => None,
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Unsplash {}
    /// Nested message and enum types in `Unsplash`.
    pub mod unsplash {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Search {}
        /// Nested message and enum types in `Search`.
        pub mod search {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// empty means random images
                #[prost(string, tag = "1")]
                pub query: ::prost::alloc::string::String,
                /// may be omitted if the request was cached previously with another limit
                #[prost(int32, tag = "2")]
                pub limit: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub pictures: ::prost::alloc::vec::Vec<response::Picture>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Picture {
                    #[prost(string, tag = "1")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub url: ::prost::alloc::string::String,
                    #[prost(string, tag = "3")]
                    pub artist: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub artist_url: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        RateLimitExceeded = 100,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Download {}
        /// Nested message and enum types in `Download`.
        pub mod download {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub picture_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::ImageKind", tag = "3")]
                pub image_kind: i32,
                /// Object ID where the file was initially created
                #[prost(string, tag = "4")]
                pub created_in_context: ::prost::alloc::string::String,
                /// Block ID where the file was initially created
                #[prost(string, tag = "5")]
                pub created_in_context_ref: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// ...
                        RateLimitExceeded = 100,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Ai {}
    /// Nested message and enum types in `AI`.
    pub mod ai {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct WritingTools {}
        /// Nested message and enum types in `WritingTools`.
        pub mod writing_tools {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<super::ProviderConfig>,
                #[prost(enumeration = "request::WritingMode", tag = "2")]
                pub mode: i32,
                #[prost(enumeration = "request::Language", tag = "3")]
                pub language: i32,
                #[prost(string, tag = "4")]
                pub text: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum WritingMode {
                    Default = 0,
                    Summarize = 1,
                    Grammar = 2,
                    Shorten = 3,
                    Expand = 4,
                    Bullet = 5,
                    Table = 6,
                    Casual = 7,
                    Funny = 8,
                    Confident = 9,
                    Straightforward = 10,
                    Professional = 11,
                    /// ...
                    Translate = 12,
                }
                impl WritingMode {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Default => "DEFAULT",
                            Self::Summarize => "SUMMARIZE",
                            Self::Grammar => "GRAMMAR",
                            Self::Shorten => "SHORTEN",
                            Self::Expand => "EXPAND",
                            Self::Bullet => "BULLET",
                            Self::Table => "TABLE",
                            Self::Casual => "CASUAL",
                            Self::Funny => "FUNNY",
                            Self::Confident => "CONFIDENT",
                            Self::Straightforward => "STRAIGHTFORWARD",
                            Self::Professional => "PROFESSIONAL",
                            Self::Translate => "TRANSLATE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "DEFAULT" => Some(Self::Default),
                            "SUMMARIZE" => Some(Self::Summarize),
                            "GRAMMAR" => Some(Self::Grammar),
                            "SHORTEN" => Some(Self::Shorten),
                            "EXPAND" => Some(Self::Expand),
                            "BULLET" => Some(Self::Bullet),
                            "TABLE" => Some(Self::Table),
                            "CASUAL" => Some(Self::Casual),
                            "FUNNY" => Some(Self::Funny),
                            "CONFIDENT" => Some(Self::Confident),
                            "STRAIGHTFORWARD" => Some(Self::Straightforward),
                            "PROFESSIONAL" => Some(Self::Professional),
                            "TRANSLATE" => Some(Self::Translate),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Language {
                    En = 0,
                    Es = 1,
                    Fr = 2,
                    De = 3,
                    It = 4,
                    Pt = 5,
                    Hi = 6,
                    /// ...
                    Th = 7,
                }
                impl Language {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::En => "EN",
                            Self::Es => "ES",
                            Self::Fr => "FR",
                            Self::De => "DE",
                            Self::It => "IT",
                            Self::Pt => "PT",
                            Self::Hi => "HI",
                            Self::Th => "TH",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "EN" => Some(Self::En),
                            "ES" => Some(Self::Es),
                            "FR" => Some(Self::Fr),
                            "DE" => Some(Self::De),
                            "IT" => Some(Self::It),
                            "PT" => Some(Self::Pt),
                            "HI" => Some(Self::Hi),
                            "TH" => Some(Self::Th),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub text: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        RateLimitExceeded = 100,
                        EndpointNotReachable = 101,
                        ModelNotFound = 102,
                        AuthRequired = 103,
                        /// ...
                        LanguageNotSupported = 104,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                                Self::EndpointNotReachable => "ENDPOINT_NOT_REACHABLE",
                                Self::ModelNotFound => "MODEL_NOT_FOUND",
                                Self::AuthRequired => "AUTH_REQUIRED",
                                Self::LanguageNotSupported => "LANGUAGE_NOT_SUPPORTED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                "ENDPOINT_NOT_REACHABLE" => Some(Self::EndpointNotReachable),
                                "MODEL_NOT_FOUND" => Some(Self::ModelNotFound),
                                "AUTH_REQUIRED" => Some(Self::AuthRequired),
                                "LANGUAGE_NOT_SUPPORTED" => Some(Self::LanguageNotSupported),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Autofill {}
        /// Nested message and enum types in `Autofill`.
        pub mod autofill {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<super::ProviderConfig>,
                #[prost(enumeration = "request::AutofillMode", tag = "2")]
                pub mode: i32,
                #[prost(string, repeated, tag = "3")]
                pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, repeated, tag = "4")]
                pub context: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum AutofillMode {
                    Tag = 0,
                    Relation = 1,
                    Type = 2,
                    Title = 3,
                    /// ...
                    Description = 4,
                }
                impl AutofillMode {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Tag => "TAG",
                            Self::Relation => "RELATION",
                            Self::Type => "TYPE",
                            Self::Title => "TITLE",
                            Self::Description => "DESCRIPTION",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "TAG" => Some(Self::Tag),
                            "RELATION" => Some(Self::Relation),
                            "TYPE" => Some(Self::Type),
                            "TITLE" => Some(Self::Title),
                            "DESCRIPTION" => Some(Self::Description),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub text: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        RateLimitExceeded = 100,
                        EndpointNotReachable = 101,
                        ModelNotFound = 102,
                        /// ...
                        AuthRequired = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                                Self::EndpointNotReachable => "ENDPOINT_NOT_REACHABLE",
                                Self::ModelNotFound => "MODEL_NOT_FOUND",
                                Self::AuthRequired => "AUTH_REQUIRED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                "ENDPOINT_NOT_REACHABLE" => Some(Self::EndpointNotReachable),
                                "MODEL_NOT_FOUND" => Some(Self::ModelNotFound),
                                "AUTH_REQUIRED" => Some(Self::AuthRequired),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSummary {}
        /// Nested message and enum types in `ListSummary`.
        pub mod list_summary {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<super::ProviderConfig>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "3")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "4")]
                pub prompt: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        RateLimitExceeded = 100,
                        EndpointNotReachable = 101,
                        ModelNotFound = 102,
                        /// ...
                        AuthRequired = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                                Self::EndpointNotReachable => "ENDPOINT_NOT_REACHABLE",
                                Self::ModelNotFound => "MODEL_NOT_FOUND",
                                Self::AuthRequired => "AUTH_REQUIRED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                "ENDPOINT_NOT_REACHABLE" => Some(Self::EndpointNotReachable),
                                "MODEL_NOT_FOUND" => Some(Self::ModelNotFound),
                                "AUTH_REQUIRED" => Some(Self::AuthRequired),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ObjectCreateFromUrl {}
        /// Nested message and enum types in `ObjectCreateFromUrl`.
        pub mod object_create_from_url {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(message, optional, tag = "1")]
                pub config: ::core::option::Option<super::ProviderConfig>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub url: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        RateLimitExceeded = 100,
                        EndpointNotReachable = 101,
                        ModelNotFound = 102,
                        /// ...
                        AuthRequired = 103,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::RateLimitExceeded => "RATE_LIMIT_EXCEEDED",
                                Self::EndpointNotReachable => "ENDPOINT_NOT_REACHABLE",
                                Self::ModelNotFound => "MODEL_NOT_FOUND",
                                Self::AuthRequired => "AUTH_REQUIRED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "RATE_LIMIT_EXCEEDED" => Some(Self::RateLimitExceeded),
                                "ENDPOINT_NOT_REACHABLE" => Some(Self::EndpointNotReachable),
                                "MODEL_NOT_FOUND" => Some(Self::ModelNotFound),
                                "AUTH_REQUIRED" => Some(Self::AuthRequired),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ProviderConfig {
            #[prost(enumeration = "Provider", tag = "1")]
            pub provider: i32,
            #[prost(string, tag = "2")]
            pub endpoint: ::prost::alloc::string::String,
            #[prost(string, tag = "3")]
            pub model: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub token: ::prost::alloc::string::String,
            #[prost(float, tag = "5")]
            pub temperature: f32,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Provider {
            Ollama = 0,
            Openai = 1,
            Lmstudio = 2,
            /// ...
            Llamacpp = 3,
        }
        impl Provider {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Ollama => "OLLAMA",
                    Self::Openai => "OPENAI",
                    Self::Lmstudio => "LMSTUDIO",
                    Self::Llamacpp => "LLAMACPP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OLLAMA" => Some(Self::Ollama),
                    "OPENAI" => Some(Self::Openai),
                    "LMSTUDIO" => Some(Self::Lmstudio),
                    "LLAMACPP" => Some(Self::Llamacpp),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Gallery {}
    /// Nested message and enum types in `Gallery`.
    pub mod gallery {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DownloadManifest {}
        /// Nested message and enum types in `DownloadManifest`.
        pub mod download_manifest {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub url: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub info: ::core::option::Option<crate::model::ManifestInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DownloadIndex {}
        /// Nested message and enum types in `DownloadIndex`.
        pub mod download_index {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub categories: ::prost::alloc::vec::Vec<response::Category>,
                #[prost(message, repeated, tag = "3")]
                pub experiences: ::prost::alloc::vec::Vec<crate::model::ManifestInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        UnmarshallingError = 3,
                        DownloadError = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::UnmarshallingError => "UNMARSHALLING_ERROR",
                                Self::DownloadError => "DOWNLOAD_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "UNMARSHALLING_ERROR" => Some(Self::UnmarshallingError),
                                "DOWNLOAD_ERROR" => Some(Self::DownloadError),
                                _ => None,
                            }
                        }
                    }
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Category {
                    #[prost(string, tag = "1")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "2")]
                    pub experiences: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                    #[prost(string, tag = "3")]
                    pub icon: ::prost::alloc::string::String,
                }
            }
        }
    }
    /// Block commands
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Block {}
    /// Nested message and enum types in `Block`.
    pub mod block {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Replace {}
        /// Nested message and enum types in `Replace`.
        pub mod replace {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub block: ::core::option::Option<crate::model::Block>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Split {}
        /// Nested message and enum types in `Split`.
        pub mod split {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub range: ::core::option::Option<crate::model::Range>,
                #[prost(enumeration = "crate::model::block::content::text::Style", tag = "4")]
                pub style: i32,
                #[prost(enumeration = "request::Mode", tag = "5")]
                pub mode: i32,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Mode {
                    /// new block will be created under existing
                    Bottom = 0,
                    /// new block will be created above existing
                    Top = 1,
                    /// new block will be created as the first children of existing
                    Inner = 2,
                    /// new block will be created after header (not required for set at client side, will auto set for title block)
                    Title = 3,
                }
                impl Mode {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Bottom => "BOTTOM",
                            Self::Top => "TOP",
                            Self::Inner => "INNER",
                            Self::Title => "TITLE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "BOTTOM" => Some(Self::Bottom),
                            "TOP" => Some(Self::Top),
                            "INNER" => Some(Self::Inner),
                            "TITLE" => Some(Self::Title),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Merge {}
        /// Nested message and enum types in `Merge`.
        pub mod merge {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub first_block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub second_block_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Copy {}
        /// Nested message and enum types in `Copy`.
        pub mod copy {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
                #[prost(message, optional, tag = "3")]
                pub selected_text_range: ::core::option::Option<crate::model::Range>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub text_slot: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub html_slot: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub any_slot: ::prost::alloc::vec::Vec<crate::model::Block>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Paste {}
        /// Nested message and enum types in `Paste`.
        pub mod paste {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub focused_block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub selected_text_range: ::core::option::Option<crate::model::Range>,
                #[prost(string, repeated, tag = "4")]
                pub selected_block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "5")]
                pub is_part_of_block: bool,
                #[prost(string, tag = "6")]
                pub text_slot: ::prost::alloc::string::String,
                #[prost(string, tag = "7")]
                pub html_slot: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "8")]
                pub any_slot: ::prost::alloc::vec::Vec<crate::model::Block>,
                #[prost(message, repeated, tag = "9")]
                pub file_slot: ::prost::alloc::vec::Vec<request::File>,
                #[prost(string, tag = "10")]
                pub url: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct File {
                    #[prost(string, tag = "1")]
                    pub name: ::prost::alloc::string::String,
                    #[prost(bytes = "vec", tag = "2")]
                    pub data: ::prost::alloc::vec::Vec<u8>,
                    #[prost(string, tag = "3")]
                    pub local_path: ::prost::alloc::string::String,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(int32, tag = "3")]
                pub caret_position: i32,
                #[prost(bool, tag = "4")]
                pub is_same_block_caret: bool,
                #[prost(message, optional, tag = "5")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Cut {}
        /// Nested message and enum types in `Cut`.
        pub mod cut {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
                #[prost(message, optional, tag = "3")]
                pub selected_text_range: ::core::option::Option<crate::model::Range>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub text_slot: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub html_slot: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub any_slot: ::prost::alloc::vec::Vec<crate::model::Block>,
                #[prost(message, optional, tag = "5")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Upload {}
        /// Nested message and enum types in `Upload`.
        pub mod upload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub file_path: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub url: ::prost::alloc::string::String,
                #[prost(bytes = "vec", tag = "5")]
                pub bytes: ::prost::alloc::vec::Vec<u8>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Download {}
        /// Nested message and enum types in `Download`.
        pub mod download {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// Create a Smart/Internal block. Request can contain a block with a content, or it can be an empty block with a specific block.content.
        /// **Example scenario**
        ///       1A. Create Page on a dashboard
        ///    1. Front -> MW: Rpc.Block.Create.Request(blockId:dashboard.id, position:bottom, block: emtpy block with page content and id = "")
        ///    2. Front -> MW: Rpc.Block.Close.Request(block: dashboard.id)
        ///    3. Front \<- MW: Rpc.Block.Close.Response(err)
        ///    4. Front \<- MW: Rpc.Block.Create.Response(page.id)
        ///    5. Front \<- MW: Rpc.Block.Open.Response(err)
        ///    6. Front \<- MW: Event.Block.Show(page)
        ///       1B. Create Page on a Page
        ///    1. Front -> MW: Rpc.Block.Create.Request(blockId:dashboard.id, position:bottom, block: emtpy block with page content and id = "")
        ///    2. Front \<- MW: Rpc.Block.Create.Response(newPage.id)
        ///    3. Front \<- MW: Event.Block.Show(newPage)
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            /// common simple block command
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest block
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub block: ::core::option::Option<crate::model::Block>,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateWidget {}
        /// Nested message and enum types in `CreateWidget`.
        pub mod create_widget {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest block
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub block: ::core::option::Option<crate::model::Block>,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
                #[prost(
                    enumeration = "crate::model::block::content::widget::Layout",
                    tag = "5"
                )]
                pub widget_layout: i32,
                #[prost(int32, tag = "6")]
                pub object_limit: i32,
                #[prost(string, tag = "7")]
                pub view_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// Remove blocks from the childrenIds of its parents
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListDelete {}
        /// Nested message and enum types in `ListDelete`.
        pub mod list_delete {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// targets to remove
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetFields {}
        /// Nested message and enum types in `SetFields`.
        pub mod set_fields {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetAlign {}
        /// Nested message and enum types in `ListSetAlign`.
        pub mod list_set_align {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// when empty - align will be applied as layoutAlign
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::Align", tag = "3")]
                pub align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetVerticalAlign {}
        /// Nested message and enum types in `ListSetVerticalAlign`.
        pub mod list_set_vertical_align {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::VerticalAlign", tag = "3")]
                pub vertical_align: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetFields {}
        /// Nested message and enum types in `ListSetFields`.
        pub mod list_set_fields {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub block_fields: ::prost::alloc::vec::Vec<request::BlockField>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct BlockField {
                    #[prost(string, tag = "1")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "2")]
                    pub fields: ::core::option::Option<::prost_types::Struct>,
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// Makes blocks copy by given ids and paste it to shown place
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListDuplicate {}
        /// Nested message and enum types in `ListDuplicate`.
        pub mod list_duplicate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest block
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                /// id of block for duplicate
                #[prost(string, repeated, tag = "3")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
                #[prost(string, tag = "5")]
                pub target_context_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListUpdate {}
        /// Nested message and enum types in `ListUpdate`.
        pub mod list_update {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(oneof = "request::Field", tags = "3, 4, 5, 6, 7, 8")]
                pub field: ::core::option::Option<request::Field>,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Text {
                    #[prost(oneof = "text::Field", tags = "1, 2, 3")]
                    pub field: ::core::option::Option<text::Field>,
                }
                /// Nested message and enum types in `Text`.
                pub mod text {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                    pub enum Field {
                        #[prost(
                            enumeration = "crate::model::block::content::text::Style",
                            tag = "1"
                        )]
                        Style(i32),
                        #[prost(string, tag = "2")]
                        Color(::prost::alloc::string::String),
                        #[prost(message, tag = "3")]
                        Mark(crate::model::block::content::text::Mark),
                    }
                }
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Field {
                    #[prost(message, tag = "3")]
                    Text(Text),
                    #[prost(string, tag = "4")]
                    BackgroundColor(::prost::alloc::string::String),
                    #[prost(enumeration = "crate::model::block::Align", tag = "5")]
                    Align(i32),
                    #[prost(message, tag = "6")]
                    Fields(::prost_types::Struct),
                    #[prost(enumeration = "crate::model::block::content::div::Style", tag = "7")]
                    DivStyle(i32),
                    #[prost(enumeration = "crate::model::block::content::file::Style", tag = "8")]
                    FileStyle(i32),
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListConvertToObjects {}
        /// Nested message and enum types in `ListConvertToObjects`.
        pub mod list_convert_to_objects {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub object_type_unique_key: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub template_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "5")]
                pub block: ::core::option::Option<crate::model::Block>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub link_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListMoveToExistingObject {}
        /// Nested message and enum types in `ListMoveToExistingObject`.
        pub mod list_move_to_existing_object {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub target_context_id: ::prost::alloc::string::String,
                /// id of the simple block to insert considering position
                #[prost(string, tag = "4")]
                pub drop_target_id: ::prost::alloc::string::String,
                /// position relatively to the dropTargetId simple block
                #[prost(enumeration = "crate::model::block::Position", tag = "5")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListMoveToNewObject {}
        /// Nested message and enum types in `ListMoveToNewObject`.
        pub mod list_move_to_new_object {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                /// new object details
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// id of the simple block to insert considering position
                #[prost(string, tag = "4")]
                pub drop_target_id: ::prost::alloc::string::String,
                /// position relatively to the dropTargetId simple block
                #[prost(enumeration = "crate::model::block::Position", tag = "5")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub link_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListTurnInto {}
        /// Nested message and enum types in `ListTurnInto`.
        pub mod list_turn_into {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::content::text::Style", tag = "3")]
                pub style: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetBackgroundColor {}
        /// Nested message and enum types in `ListSetBackgroundColor`.
        pub mod list_set_background_color {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Export {}
        /// Nested message and enum types in `Export`.
        pub mod export {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetCarriage {}
        /// Nested message and enum types in `SetCarriage`.
        pub mod set_carriage {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub range: ::core::option::Option<crate::model::Range>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Preview {}
        /// Nested message and enum types in `Preview`.
        pub mod preview {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub html: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub url: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockLatex {}
    /// Nested message and enum types in `BlockLatex`.
    pub mod block_latex {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetText {}
        /// Nested message and enum types in `SetText`.
        pub mod set_text {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub text: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::model::block::content::latex::Processor",
                    tag = "4"
                )]
                pub processor: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetProcessor {}
        /// Nested message and enum types in `SetProcessor`.
        pub mod set_processor {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::model::block::content::latex::Processor",
                    tag = "3"
                )]
                pub processor: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockText {}
    /// Nested message and enum types in `BlockText`.
    pub mod block_text {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetText {}
        /// Nested message and enum types in `SetText`.
        pub mod set_text {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub text: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub marks: ::core::option::Option<crate::model::block::content::text::Marks>,
                #[prost(message, optional, tag = "5")]
                pub selected_text_range: ::core::option::Option<crate::model::Range>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetColor {}
        /// Nested message and enum types in `SetColor`.
        pub mod set_color {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetMarks {}
        /// Nested message and enum types in `SetMarks`.
        pub mod set_marks {
            /// Get marks list in the selected range in text block.
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Get {}
            /// Nested message and enum types in `Get`.
            pub mod get {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "3")]
                    pub range: ::core::option::Option<crate::model::Range>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetStyle {}
        /// Nested message and enum types in `SetStyle`.
        pub mod set_style {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::content::text::Style", tag = "3")]
                pub style: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetChecked {}
        /// Nested message and enum types in `SetChecked`.
        pub mod set_checked {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub checked: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetIcon {}
        /// Nested message and enum types in `SetIcon`.
        pub mod set_icon {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                /// in case both image and emoji are set, image has a priority to show
                #[prost(string, tag = "3")]
                pub icon_image: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub icon_emoji: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetStyle {}
        /// Nested message and enum types in `ListSetStyle`.
        pub mod list_set_style {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::content::text::Style", tag = "3")]
                pub style: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetColor {}
        /// Nested message and enum types in `ListSetColor`.
        pub mod list_set_color {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetMark {}
        /// Nested message and enum types in `ListSetMark`.
        pub mod list_set_mark {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(message, optional, tag = "3")]
                pub mark: ::core::option::Option<crate::model::block::content::text::Mark>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListClearStyle {}
        /// Nested message and enum types in `ListClearStyle`.
        pub mod list_clear_style {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListClearContent {}
        /// Nested message and enum types in `ListClearContent`.
        pub mod list_clear_content {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockTable {}
    /// Nested message and enum types in `BlockTable`.
    pub mod block_table {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Create {}
        /// Nested message and enum types in `Create`.
        pub mod create {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest block
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
                #[prost(uint32, tag = "4")]
                pub rows: u32,
                #[prost(uint32, tag = "5")]
                pub columns: u32,
                #[prost(bool, tag = "6")]
                pub with_header_row: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowCreate {}
        /// Nested message and enum types in `RowCreate`.
        pub mod row_create {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest row
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowSetHeader {}
        /// Nested message and enum types in `RowSetHeader`.
        pub mod row_set_header {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(bool, tag = "3")]
                pub is_header: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowListFill {}
        /// Nested message and enum types in `RowListFill`.
        pub mod row_list_fill {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowListClean {}
        /// Nested message and enum types in `RowListClean`.
        pub mod row_list_clean {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ColumnListFill {}
        /// Nested message and enum types in `ColumnListFill`.
        pub mod column_list_fill {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ColumnCreate {}
        /// Nested message and enum types in `ColumnCreate`.
        pub mod column_create {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest column
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowDelete {}
        /// Nested message and enum types in `RowDelete`.
        pub mod row_delete {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest row
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ColumnDelete {}
        /// Nested message and enum types in `ColumnDelete`.
        pub mod column_delete {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// id of the closest column
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ColumnMove {}
        /// Nested message and enum types in `ColumnMove`.
        pub mod column_move {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub drop_target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RowDuplicate {}
        /// Nested message and enum types in `RowDuplicate`.
        pub mod row_duplicate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                /// block to duplicate
                #[prost(string, tag = "3")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ColumnDuplicate {}
        /// Nested message and enum types in `ColumnDuplicate`.
        pub mod column_duplicate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                /// block to duplicate
                #[prost(string, tag = "3")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Expand {}
        /// Nested message and enum types in `Expand`.
        pub mod expand {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                /// number of columns to append
                #[prost(uint32, tag = "3")]
                pub columns: u32,
                /// number of rows to append
                #[prost(uint32, tag = "4")]
                pub rows: u32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Sort {}
        /// Nested message and enum types in `Sort`.
        pub mod sort {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub column_id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::model::block::content::dataview::sort::Type",
                    tag = "3"
                )]
                pub r#type: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockFile {}
    /// Nested message and enum types in `BlockFile`.
    pub mod block_file {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetName {}
        /// Nested message and enum types in `SetName`.
        pub mod set_name {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetTargetObjectId {}
        /// Nested message and enum types in `SetTargetObjectId`.
        pub mod set_target_object_id {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateAndUpload {}
        /// Nested message and enum types in `CreateAndUpload`.
        pub mod create_and_upload {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
                #[prost(string, tag = "4")]
                pub url: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub local_path: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::content::file::Type", tag = "6")]
                pub file_type: i32,
                #[prost(enumeration = "crate::model::ImageKind", tag = "7")]
                pub image_kind: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetStyle {}
        /// Nested message and enum types in `ListSetStyle`.
        pub mod list_set_style {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::content::file::Style", tag = "3")]
                pub style: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockImage {}
    /// Nested message and enum types in `BlockImage`.
    pub mod block_image {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetName {}
        /// Nested message and enum types in `SetName`.
        pub mod set_name {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetWidth {}
        /// Nested message and enum types in `SetWidth`.
        pub mod set_width {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(int32, tag = "3")]
                pub width: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockVideo {}
    /// Nested message and enum types in `BlockVideo`.
    pub mod block_video {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetName {}
        /// Nested message and enum types in `SetName`.
        pub mod set_name {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetWidth {}
        /// Nested message and enum types in `SetWidth`.
        pub mod set_width {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(int32, tag = "3")]
                pub width: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockLink {}
    /// Nested message and enum types in `BlockLink`.
    pub mod block_link {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateWithObject {}
        /// Nested message and enum types in `CreateWithObject`.
        pub mod create_with_object {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                /// id of the context object
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                /// new object details
                #[prost(message, optional, tag = "3")]
                pub details: ::core::option::Option<::prost_types::Struct>,
                /// optional template id for creating from template
                #[prost(string, tag = "5")]
                pub template_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "7")]
                pub internal_flags: ::prost::alloc::vec::Vec<crate::model::InternalFlag>,
                #[prost(string, tag = "8")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "9")]
                pub object_type_unique_key: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "10")]
                pub block: ::core::option::Option<crate::model::Block>,
                /// link block params
                ///
                /// id of the closest simple block
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "4")]
                pub position: i32,
                /// deprecated link block fields
                #[prost(message, optional, tag = "6")]
                pub fields: ::core::option::Option<::prost_types::Struct>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "4")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "5")]
                pub details: ::core::option::Option<::prost_types::Struct>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetAppearance {}
        /// Nested message and enum types in `ListSetAppearance`.
        pub mod list_set_appearance {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(
                    enumeration = "crate::model::block::content::link::IconSize",
                    tag = "4"
                )]
                pub icon_size: i32,
                #[prost(
                    enumeration = "crate::model::block::content::link::CardStyle",
                    tag = "5"
                )]
                pub card_style: i32,
                #[prost(
                    enumeration = "crate::model::block::content::link::Description",
                    tag = "6"
                )]
                pub description: i32,
                #[prost(string, repeated, tag = "7")]
                pub relations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockRelation {}
    /// Nested message and enum types in `BlockRelation`.
    pub mod block_relation {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetKey {}
        /// Nested message and enum types in `SetKey`.
        pub mod set_key {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Add {}
        /// Nested message and enum types in `Add`.
        pub mod add {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub relation_key: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockBookmark {}
    /// Nested message and enum types in `BlockBookmark`.
    pub mod block_bookmark {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Fetch {}
        /// Nested message and enum types in `Fetch`.
        pub mod fetch {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub url: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub template_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateAndFetch {}
        /// Nested message and enum types in `CreateAndFetch`.
        pub mod create_and_fetch {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub target_id: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::block::Position", tag = "3")]
                pub position: i32,
                #[prost(string, tag = "4")]
                pub url: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub template_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockDiv {}
    /// Nested message and enum types in `BlockDiv`.
    pub mod block_div {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ListSetStyle {}
        /// Nested message and enum types in `ListSetStyle`.
        pub mod list_set_style {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub block_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::block::content::div::Style", tag = "3")]
                pub style: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockDataview {}
    /// Nested message and enum types in `BlockDataview`.
    pub mod block_dataview {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct View {}
        /// Nested message and enum types in `View`.
        pub mod view {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Create {}
            /// Nested message and enum types in `Create`.
            pub mod create {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to insert the new block
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub view: ::core::option::Option<crate::model::block::content::dataview::View>,
                    #[prost(string, repeated, tag = "5")]
                    pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Update {}
            /// Nested message and enum types in `Update`.
            pub mod update {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub view: ::core::option::Option<crate::model::block::content::dataview::View>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Delete {}
            /// Nested message and enum types in `Delete`.
            pub mod delete {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    /// id of the context object
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of the dataview
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of the view to remove
                    #[prost(string, tag = "4")]
                    pub view_id: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SetPosition {}
            /// Nested message and enum types in `SetPosition`.
            pub mod set_position {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    /// id of the context object
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of the dataview
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of the view to remove
                    #[prost(string, tag = "4")]
                    pub view_id: ::prost::alloc::string::String,
                    /// index of view position (0 - means first)
                    #[prost(uint32, tag = "5")]
                    pub position: u32,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            /// ...
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            /// set the current active view locally
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SetActive {}
            /// Nested message and enum types in `SetActive`.
            pub mod set_active {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of active view
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Relation {}
        /// Nested message and enum types in `Relation`.
        pub mod relation {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Set {}
            /// Nested message and enum types in `Set`.
            pub mod set {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to set relation
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "3")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to add relation
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "3")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Delete {}
            /// Nested message and enum types in `Delete`.
            pub mod delete {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to add relation
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "3")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "3")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetSource {}
        /// Nested message and enum types in `SetSource`.
        pub mod set_source {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "3")]
                pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "4")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GroupOrder {}
        /// Nested message and enum types in `GroupOrder`.
        pub mod group_order {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Update {}
            /// Nested message and enum types in `Update`.
            pub mod update {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "3")]
                    pub group_order:
                        ::core::option::Option<crate::model::block::content::dataview::GroupOrder>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ObjectOrder {}
        /// Nested message and enum types in `ObjectOrder`.
        pub mod object_order {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Update {}
            /// Nested message and enum types in `Update`.
            pub mod update {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(message, repeated, tag = "3")]
                    pub object_orders: ::prost::alloc::vec::Vec<
                        crate::model::block::content::dataview::ObjectOrder,
                    >,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Move {}
            /// Nested message and enum types in `Move`.
            pub mod r#move {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub group_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "5")]
                    pub after_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "6")]
                    pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CreateFromExistingObject {}
        /// Nested message and enum types in `CreateFromExistingObject`.
        pub mod create_from_existing_object {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub target_object_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub target_object_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub view: ::prost::alloc::vec::Vec<crate::model::block::content::dataview::View>,
                #[prost(message, optional, tag = "5")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Filter {}
        /// Nested message and enum types in `Filter`.
        pub mod filter {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub filter:
                        ::core::option::Option<crate::model::block::content::dataview::Filter>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {}
            /// Nested message and enum types in `Remove`.
            pub mod remove {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "4")]
                    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Replace {}
            /// Nested message and enum types in `Replace`.
            pub mod replace {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "5")]
                    pub filter:
                        ::core::option::Option<crate::model::block::content::dataview::Filter>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Sort {}
            /// Nested message and enum types in `Sort`.
            pub mod sort {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    /// new order of filters
                    #[prost(string, repeated, tag = "4")]
                    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Sort {}
        /// Nested message and enum types in `Sort`.
        pub mod sort {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub sort: ::core::option::Option<crate::model::block::content::dataview::Sort>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {}
            /// Nested message and enum types in `Remove`.
            pub mod remove {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "4")]
                    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Replace {}
            /// Nested message and enum types in `Replace`.
            pub mod replace {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "5")]
                    pub sort: ::core::option::Option<crate::model::block::content::dataview::Sort>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SSort {}
            /// Nested message and enum types in `SSort`.
            pub mod s_sort {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    /// new order of sorts
                    #[prost(string, repeated, tag = "4")]
                    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ViewRelation {}
        /// Nested message and enum types in `ViewRelation`.
        pub mod view_relation {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Add {}
            /// Nested message and enum types in `Add`.
            pub mod add {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub relation:
                        ::core::option::Option<crate::model::block::content::dataview::Relation>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Remove {}
            /// Nested message and enum types in `Remove`.
            pub mod remove {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, repeated, tag = "4")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Replace {}
            /// Nested message and enum types in `Replace`.
            pub mod replace {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "4")]
                    pub relation_key: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "5")]
                    pub relation:
                        ::core::option::Option<crate::model::block::content::dataview::Relation>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Sort {}
            /// Nested message and enum types in `Sort`.
            pub mod sort {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(string, tag = "1")]
                    pub context_id: ::prost::alloc::string::String,
                    /// id of dataview block to update
                    #[prost(string, tag = "2")]
                    pub block_id: ::prost::alloc::string::String,
                    /// id of view to update
                    #[prost(string, tag = "3")]
                    pub view_id: ::prost::alloc::string::String,
                    /// new order of relations
                    #[prost(string, repeated, tag = "4")]
                    pub relation_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                }
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    #[prost(message, optional, tag = "2")]
                    pub event: ::core::option::Option<super::super::super::super::ResponseEvent>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockWidget {}
    /// Nested message and enum types in `BlockWidget`.
    pub mod block_widget {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetTargetId {}
        /// Nested message and enum types in `SetTargetId`.
        pub mod set_target_id {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub target_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetLayout {}
        /// Nested message and enum types in `SetLayout`.
        pub mod set_layout {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(
                    enumeration = "crate::model::block::content::widget::Layout",
                    tag = "3"
                )]
                pub layout: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetLimit {}
        /// Nested message and enum types in `SetLimit`.
        pub mod set_limit {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(int32, tag = "3")]
                pub limit: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetViewId {}
        /// Nested message and enum types in `SetViewId`.
        pub mod set_view_id {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub context_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub block_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub view_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Debug {}
    /// Nested message and enum types in `Debug`.
    pub mod debug {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeInfo {
            #[prost(string, tag = "1")]
            pub tree_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub head_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Stat {}
        /// Nested message and enum types in `Stat`.
        pub mod stat {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub json_stat: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TreeHeads {}
        /// Nested message and enum types in `TreeHeads`.
        pub mod tree_heads {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub tree_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub info: ::core::option::Option<super::TreeInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Tree {}
        /// Nested message and enum types in `Tree`.
        pub mod tree {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub tree_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                /// set to true to disable mocking of the actual data inside changes
                #[prost(bool, tag = "3")]
                pub unanonymized: bool,
                /// set to true to write both ZIP and SVG files
                #[prost(bool, tag = "4")]
                pub generate_svg: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub filename: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SpaceSummary {}
        /// Nested message and enum types in `SpaceSummary`.
        pub mod space_summary {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub infos: ::prost::alloc::vec::Vec<super::TreeInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct StackGoroutines {}
        /// Nested message and enum types in `StackGoroutines`.
        pub mod stack_goroutines {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ExportLocalstore {}
        /// Nested message and enum types in `ExportLocalstore`.
        pub mod export_localstore {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// the path where export files will place
                #[prost(string, tag = "1")]
                pub path: ::prost::alloc::string::String,
                /// ids of documents for export, when empty - will export all available docs
                #[prost(string, repeated, tag = "2")]
                pub doc_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(string, tag = "3")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Subscriptions {}
        /// Nested message and enum types in `Subscriptions`.
        pub mod subscriptions {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub subscriptions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct OpenedObjects {}
        /// Nested message and enum types in `OpenedObjects`.
        pub mod opened_objects {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, repeated, tag = "2")]
                pub object_i_ds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RunProfiler {}
        /// Nested message and enum types in `RunProfiler`.
        pub mod run_profiler {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(int32, tag = "1")]
                pub duration_in_seconds: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AccountSelectTrace {}
        /// Nested message and enum types in `AccountSelectTrace`.
        pub mod account_select_trace {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// empty means using OS-provided temp dir
                #[prost(string, tag = "1")]
                pub dir: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ExportLog {}
        /// Nested message and enum types in `ExportLog`.
        pub mod export_log {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// empty means using OS-provided temp dir
                #[prost(string, tag = "1")]
                pub dir: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub path: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NoFolder = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NoFolder => "NO_FOLDER",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NO_FOLDER" => Some(Self::NoFolder),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Ping {}
        /// Nested message and enum types in `Ping`.
        pub mod ping {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(int32, tag = "1")]
                pub index: i32,
                #[prost(int32, tag = "2")]
                pub number_of_events_to_send: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(int32, tag = "2")]
                pub index: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AnystoreObjectChanges {}
        /// Nested message and enum types in `AnystoreObjectChanges`.
        pub mod anystore_object_changes {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub object_id: ::prost::alloc::string::String,
                #[prost(enumeration = "request::OrderBy", tag = "2")]
                pub order_by: i32,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum OrderBy {
                    OrderId = 0,
                    IterationOrder = 1,
                }
                impl OrderBy {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::OrderId => "ORDER_ID",
                            Self::IterationOrder => "ITERATION_ORDER",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "ORDER_ID" => Some(Self::OrderId),
                            "ITERATION_ORDER" => Some(Self::IterationOrder),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub changes: ::prost::alloc::vec::Vec<response::Change>,
                #[prost(bool, tag = "3")]
                pub wrong_order: bool,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct Change {
                    #[prost(string, tag = "1")]
                    pub change_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub order_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "3")]
                    pub error: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "4")]
                    pub change: ::core::option::Option<::prost_types::Struct>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetCheck {}
        /// Nested message and enum types in `NetCheck`.
        pub mod net_check {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub client_yml: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub result: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Initial {}
    /// Nested message and enum types in `Initial`.
    pub mod initial {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetParameters {}
        /// Nested message and enum types in `SetParameters`.
        pub mod set_parameters {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub platform: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub version: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub workdir: ::prost::alloc::string::String,
                #[prost(string, tag = "4")]
                pub log_level: ::prost::alloc::string::String,
                #[prost(bool, tag = "5")]
                pub do_not_send_logs: bool,
                #[prost(bool, tag = "6")]
                pub do_not_save_logs: bool,
                #[prost(bool, tag = "7")]
                pub do_not_send_telemetry: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Log {}
    /// Nested message and enum types in `Log`.
    pub mod log {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Send {}
        /// Nested message and enum types in `Send`.
        pub mod send {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub message: ::prost::alloc::string::String,
                #[prost(enumeration = "request::Level", tag = "2")]
                pub level: i32,
            }
            /// Nested message and enum types in `Request`.
            pub mod request {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Level {
                    Debug = 0,
                    Error = 1,
                    Fatal = 2,
                    Info = 3,
                    Panic = 4,
                    Warning = 5,
                }
                impl Level {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Debug => "DEBUG",
                            Self::Error => "ERROR",
                            Self::Fatal => "FATAL",
                            Self::Info => "INFO",
                            Self::Panic => "PANIC",
                            Self::Warning => "WARNING",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "DEBUG" => Some(Self::Debug),
                            "ERROR" => Some(Self::Error),
                            "FATAL" => Some(Self::Fatal),
                            "INFO" => Some(Self::Info),
                            "PANIC" => Some(Self::Panic),
                            "WARNING" => Some(Self::Warning),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Process {}
    /// Nested message and enum types in `Process`.
    pub mod process {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Cancel {}
        /// Nested message and enum types in `Cancel`.
        pub mod cancel {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Subscribe {}
        /// Nested message and enum types in `Subscribe`.
        pub mod subscribe {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Unsubscribe {}
        /// Nested message and enum types in `Unsubscribe`.
        pub mod unsubscribe {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GenericErrorResponse {
        #[prost(message, optional, tag = "1")]
        pub error: ::core::option::Option<generic_error_response::Error>,
    }
    /// Nested message and enum types in `GenericErrorResponse`.
    pub mod generic_error_response {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Error {
            #[prost(enumeration = "error::Code", tag = "1")]
            pub code: i32,
            #[prost(string, tag = "2")]
            pub description: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `Error`.
        pub mod error {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Code {
                Null = 0,
                UnknownError = 1,
                /// ...
                BadInput = 2,
            }
            impl Code {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Null => "NULL",
                        Self::UnknownError => "UNKNOWN_ERROR",
                        Self::BadInput => "BAD_INPUT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NULL" => Some(Self::Null),
                        "UNKNOWN_ERROR" => Some(Self::UnknownError),
                        "BAD_INPUT" => Some(Self::BadInput),
                        _ => None,
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Notification {}
    /// Nested message and enum types in `Notification`.
    pub mod notification {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct List {}
        /// Nested message and enum types in `List`.
        pub mod list {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(bool, tag = "1")]
                pub include_read: bool,
                #[prost(int64, tag = "2")]
                pub limit: i64,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub notifications: ::prost::alloc::vec::Vec<crate::model::Notification>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Reply {}
        /// Nested message and enum types in `Reply`.
        pub mod reply {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "crate::model::notification::ActionType", tag = "2")]
                pub action_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Test {}
        /// Nested message and enum types in `Test`.
        pub mod test {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub notification: ::core::option::Option<crate::model::Notification>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    /// *
    ///
    /// A Membership is a bundle of several "Features"
    /// every user should have one and only one tier
    /// users can not have N tiers (no combining)
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Membership {}
    /// Nested message and enum types in `Membership`.
    pub mod membership {
        /// *
        ///
        /// Get the current status of the membership
        /// including the tier, status, dates, etc
        /// WARNING: this can be cached by Anytype heart
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetStatus {}
        /// Nested message and enum types in `GetStatus`.
        pub mod get_status {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// pass true to force the cache update
                /// by default this is false
                #[prost(bool, tag = "1")]
                pub no_cache: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub data: ::core::option::Option<crate::model::Membership>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        MembershipNotFound = 6,
                        MembershipWrongState = 7,
                        CanNotConnect = 8,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::MembershipNotFound => "MEMBERSHIP_NOT_FOUND",
                                Self::MembershipWrongState => "MEMBERSHIP_WRONG_STATE",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "MEMBERSHIP_NOT_FOUND" => Some(Self::MembershipNotFound),
                                "MEMBERSHIP_WRONG_STATE" => Some(Self::MembershipWrongState),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Check if the requested name is valid and vacant for the requested tier
        /// before requesting a payment link and paying
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct IsNameValid {}
        /// Nested message and enum types in `IsNameValid`.
        pub mod is_name_valid {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(uint32, tag = "1")]
                pub requested_tier: u32,
                #[prost(string, tag = "2")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "3")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        TooShort = 3,
                        TooLong = 4,
                        HasInvalidChars = 5,
                        TierFeaturesNoName = 6,
                        /// if everything is fine - "name is already taken" check should be done in the NS
                        /// see IsNameAvailable()
                        TierNotFound = 7,
                        NotLoggedIn = 8,
                        PaymentNodeError = 9,
                        CacheError = 10,
                        /// for some probable future use (if needed)
                        CanNotReserve = 11,
                        CanNotConnect = 12,
                        /// Same as if NameService.ResolveName returned that name is already
                        /// occupied by some user
                        NameIsReserved = 13,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::TooShort => "TOO_SHORT",
                                Self::TooLong => "TOO_LONG",
                                Self::HasInvalidChars => "HAS_INVALID_CHARS",
                                Self::TierFeaturesNoName => "TIER_FEATURES_NO_NAME",
                                Self::TierNotFound => "TIER_NOT_FOUND",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::CanNotReserve => "CAN_NOT_RESERVE",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::NameIsReserved => "NAME_IS_RESERVED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "TOO_SHORT" => Some(Self::TooShort),
                                "TOO_LONG" => Some(Self::TooLong),
                                "HAS_INVALID_CHARS" => Some(Self::HasInvalidChars),
                                "TIER_FEATURES_NO_NAME" => Some(Self::TierFeaturesNoName),
                                "TIER_NOT_FOUND" => Some(Self::TierNotFound),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "CAN_NOT_RESERVE" => Some(Self::CanNotReserve),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "NAME_IS_RESERVED" => Some(Self::NameIsReserved),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Generate a unique id for payment request (for mobile clients)
        /// Generate a link to Stripe/Crypto where user can pay for the membership (for desktop client)
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RegisterPaymentRequest {}
        /// Nested message and enum types in `RegisterPaymentRequest`.
        pub mod register_payment_request {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(uint32, tag = "1")]
                pub requested_tier: u32,
                #[prost(enumeration = "crate::model::membership::PaymentMethod", tag = "2")]
                pub payment_method: i32,
                /// if empty - then no name requested
                /// if non-empty - PP node will register that name on behalf of the user
                #[prost(string, tag = "3")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "4")]
                pub ns_name_type: i32,
                /// for some tiers and payment methods (like crypto) we need an e-mail
                /// please get if either from:
                ///
                ///    1. Membership.GetStatus() -> anytype.model.Membership.userEmail field
                ///    1. Ask user from the UI
                #[prost(string, tag = "5")]
                pub user_email: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// will feature current billing ID
                /// stripe.com/?client_reference_id=1234
                #[prost(string, tag = "2")]
                pub payment_url: ::prost::alloc::string::String,
                /// billingID is only needed for mobile clients
                #[prost(string, tag = "3")]
                pub billing_id: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        TierNotFound = 6,
                        TierInvalid = 7,
                        PaymentMethodInvalid = 8,
                        BadAnyname = 9,
                        MembershipAlreadyExists = 10,
                        CanNotConnect = 11,
                        /// for tiers and payment methods that require that
                        EmailWrongFormat = 12,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::TierNotFound => "TIER_NOT_FOUND",
                                Self::TierInvalid => "TIER_INVALID",
                                Self::PaymentMethodInvalid => "PAYMENT_METHOD_INVALID",
                                Self::BadAnyname => "BAD_ANYNAME",
                                Self::MembershipAlreadyExists => "MEMBERSHIP_ALREADY_EXISTS",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::EmailWrongFormat => "EMAIL_WRONG_FORMAT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "TIER_NOT_FOUND" => Some(Self::TierNotFound),
                                "TIER_INVALID" => Some(Self::TierInvalid),
                                "PAYMENT_METHOD_INVALID" => Some(Self::PaymentMethodInvalid),
                                "BAD_ANYNAME" => Some(Self::BadAnyname),
                                "MEMBERSHIP_ALREADY_EXISTS" => Some(Self::MembershipAlreadyExists),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "EMAIL_WRONG_FORMAT" => Some(Self::EmailWrongFormat),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Generate a link to the portal where user can:
        /// a) change his billing details
        /// b) see payment info, invoices, etc
        /// c) cancel membership
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetPortalLinkUrl {}
        /// Nested message and enum types in `GetPortalLinkUrl`.
        pub mod get_portal_link_url {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub portal_url: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        CanNotConnect = 6,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Finalize {}
        /// Nested message and enum types in `Finalize`.
        pub mod finalize {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// if empty - then no name requested
                /// if non-empty - PP node will register that name on behalf of the user
                #[prost(string, tag = "1")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "2")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        MembershipNotFound = 6,
                        MembershipWrongState = 7,
                        BadAnyname = 8,
                        CanNotConnect = 9,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::MembershipNotFound => "MEMBERSHIP_NOT_FOUND",
                                Self::MembershipWrongState => "MEMBERSHIP_WRONG_STATE",
                                Self::BadAnyname => "BAD_ANYNAME",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "MEMBERSHIP_NOT_FOUND" => Some(Self::MembershipNotFound),
                                "MEMBERSHIP_WRONG_STATE" => Some(Self::MembershipWrongState),
                                "BAD_ANYNAME" => Some(Self::BadAnyname),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Get the current status of the e-mail verification.
        /// Status can change if you call GetVerificationEmail or VerifyEmailCode
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetVerificationEmailStatus {}
        /// Nested message and enum types in `GetVerificationEmailStatus`.
        pub mod get_verification_email_status {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(
                    enumeration = "crate::model::membership::EmailVerificationStatus",
                    tag = "2"
                )]
                pub status: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CanNotConnect = 12,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Send an e-mail with verification code to the user
        /// can be called multiple times but with some timeout (N seconds) between calls
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetVerificationEmail {}
        /// Nested message and enum types in `GetVerificationEmail`.
        pub mod get_verification_email {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub email: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub subscribe_to_newsletter: bool,
                #[prost(bool, tag = "3")]
                pub insider_tips_and_tutorials: bool,
                /// if we are coming from the onboarding list
                #[prost(bool, tag = "4")]
                pub is_onboarding_list: bool,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        EmailWrongFormat = 6,
                        EmailAlreadyVerified = 7,
                        EmailAlredySent = 8,
                        EmailFailedToSend = 9,
                        MembershipAlreadyExists = 10,
                        CanNotConnect = 11,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::EmailWrongFormat => "EMAIL_WRONG_FORMAT",
                                Self::EmailAlreadyVerified => "EMAIL_ALREADY_VERIFIED",
                                Self::EmailAlredySent => "EMAIL_ALREDY_SENT",
                                Self::EmailFailedToSend => "EMAIL_FAILED_TO_SEND",
                                Self::MembershipAlreadyExists => "MEMBERSHIP_ALREADY_EXISTS",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "EMAIL_WRONG_FORMAT" => Some(Self::EmailWrongFormat),
                                "EMAIL_ALREADY_VERIFIED" => Some(Self::EmailAlreadyVerified),
                                "EMAIL_ALREDY_SENT" => Some(Self::EmailAlredySent),
                                "EMAIL_FAILED_TO_SEND" => Some(Self::EmailFailedToSend),
                                "MEMBERSHIP_ALREADY_EXISTS" => Some(Self::MembershipAlreadyExists),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Verify the e-mail address of the user
        /// need a correct code that was sent to the user when calling GetVerificationEmail
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct VerifyEmailCode {}
        /// Nested message and enum types in `VerifyEmailCode`.
        pub mod verify_email_code {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub code: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        EmailAlreadyVerified = 6,
                        Expired = 7,
                        Wrong = 8,
                        MembershipNotFound = 9,
                        MembershipAlreadyActive = 10,
                        CanNotConnect = 11,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::EmailAlreadyVerified => "EMAIL_ALREADY_VERIFIED",
                                Self::Expired => "CODE_EXPIRED",
                                Self::Wrong => "CODE_WRONG",
                                Self::MembershipNotFound => "MEMBERSHIP_NOT_FOUND",
                                Self::MembershipAlreadyActive => "MEMBERSHIP_ALREADY_ACTIVE",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "EMAIL_ALREADY_VERIFIED" => Some(Self::EmailAlreadyVerified),
                                "CODE_EXPIRED" => Some(Self::Expired),
                                "CODE_WRONG" => Some(Self::Wrong),
                                "MEMBERSHIP_NOT_FOUND" => Some(Self::MembershipNotFound),
                                "MEMBERSHIP_ALREADY_ACTIVE" => Some(Self::MembershipAlreadyActive),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Tiers can change on the backend so if you want to show users the latest data
        /// you can call this method to get the latest tiers
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetTiers {}
        /// Nested message and enum types in `GetTiers`.
        pub mod get_tiers {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// pass true to force the cache update
                /// by default this is false
                #[prost(bool, tag = "1")]
                pub no_cache: bool,
                #[prost(string, tag = "2")]
                pub locale: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub tiers: ::prost::alloc::vec::Vec<crate::model::MembershipTierData>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        CanNotConnect = 6,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct VerifyAppStoreReceipt {}
        /// Nested message and enum types in `VerifyAppStoreReceipt`.
        pub mod verify_app_store_receipt {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// receipt is a JWT-encoded string including info about subscription purchase
                #[prost(string, tag = "1")]
                pub receipt: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        InvalidReceipt = 6,
                        PurchaseRegistrationError = 7,
                        SubscriptionRenewError = 8,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::InvalidReceipt => "INVALID_RECEIPT",
                                Self::PurchaseRegistrationError => "PURCHASE_REGISTRATION_ERROR",
                                Self::SubscriptionRenewError => "SUBSCRIPTION_RENEW_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "INVALID_RECEIPT" => Some(Self::InvalidReceipt),
                                "PURCHASE_REGISTRATION_ERROR" => {
                                    Some(Self::PurchaseRegistrationError)
                                }
                                "SUBSCRIPTION_RENEW_ERROR" => Some(Self::SubscriptionRenewError),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CodeGetInfo {}
        /// Nested message and enum types in `CodeGetInfo`.
        pub mod code_get_info {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub code: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// which tier current code can unlock
                #[prost(uint32, tag = "2")]
                pub requested_tier: u32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        NotFound = 5,
                        AlreadyUsed = 6,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::NotFound => "CODE_NOT_FOUND",
                                Self::AlreadyUsed => "CODE_ALREADY_USED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CODE_NOT_FOUND" => Some(Self::NotFound),
                                "CODE_ALREADY_USED" => Some(Self::AlreadyUsed),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CodeRedeem {}
        /// Nested message and enum types in `CodeRedeem`.
        pub mod code_redeem {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub code: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "3")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// which tier does the current code unlock
                #[prost(uint32, tag = "2")]
                pub requested_tier: u32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        NotFound = 5,
                        AlreadyUsed = 6,
                        BadAnyname = 7,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::NotFound => "CODE_NOT_FOUND",
                                Self::AlreadyUsed => "CODE_ALREADY_USED",
                                Self::BadAnyname => "BAD_ANYNAME",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CODE_NOT_FOUND" => Some(Self::NotFound),
                                "CODE_ALREADY_USED" => Some(Self::AlreadyUsed),
                                "BAD_ANYNAME" => Some(Self::BadAnyname),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MembershipV2 {}
    /// Nested message and enum types in `MembershipV2`.
    pub mod membership_v2 {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetPortalLink {}
        /// Nested message and enum types in `GetPortalLink`.
        pub mod get_portal_link {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub url: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        AuthBad = 5,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 6,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::AuthBad => "AUTH_BAD",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "AUTH_BAD" => Some(Self::AuthBad),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetProducts {}
        /// Nested message and enum types in `GetProducts`.
        pub mod get_products {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// pass true to force the cache update
                /// by default this is false
                #[prost(bool, tag = "1")]
                pub no_cache: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub products: ::prost::alloc::vec::Vec<crate::model::membership_v2::Product>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        AuthBad = 5,
                        CacheError = 6,
                        CanNotConnect = 7,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 8,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::AuthBad => "AUTH_BAD",
                                Self::CacheError => "CACHE_ERROR",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "AUTH_BAD" => Some(Self::AuthBad),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetStatus {}
        /// Nested message and enum types in `GetStatus`.
        pub mod get_status {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// pass true to force the cache update
                /// by default this is false
                #[prost(bool, tag = "1")]
                pub no_cache: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub data: ::core::option::Option<crate::model::membership_v2::Data>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        MembershipNotFound = 6,
                        MembershipWrongState = 7,
                        CanNotConnect = 8,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 9,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::MembershipNotFound => "MEMBERSHIP_NOT_FOUND",
                                Self::MembershipWrongState => "MEMBERSHIP_WRONG_STATE",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "MEMBERSHIP_NOT_FOUND" => Some(Self::MembershipNotFound),
                                "MEMBERSHIP_WRONG_STATE" => Some(Self::MembershipWrongState),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        /// *
        ///
        /// Check if the requested name is valid and vacant for the requested tier
        /// before requesting a payment link and paying
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AnyNameIsValid {}
        /// Nested message and enum types in `AnyNameIsValid`.
        pub mod any_name_is_valid {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "2")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        TooShort = 3,
                        TooLong = 4,
                        HasInvalidChars = 5,
                        /// if nothing bought
                        AccountFeaturesNoName = 6,
                        NotLoggedIn = 8,
                        PaymentNodeError = 9,
                        CacheError = 10,
                        /// for some probable future use (if needed)
                        CanNotReserve = 11,
                        CanNotConnect = 12,
                        /// Same as if NameService.ResolveName returned that name is already
                        /// occupied by some user
                        NameIsReserved = 13,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 14,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::TooShort => "TOO_SHORT",
                                Self::TooLong => "TOO_LONG",
                                Self::HasInvalidChars => "HAS_INVALID_CHARS",
                                Self::AccountFeaturesNoName => "ACCOUNT_FEATURES_NO_NAME",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::CanNotReserve => "CAN_NOT_RESERVE",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::NameIsReserved => "NAME_IS_RESERVED",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "TOO_SHORT" => Some(Self::TooShort),
                                "TOO_LONG" => Some(Self::TooLong),
                                "HAS_INVALID_CHARS" => Some(Self::HasInvalidChars),
                                "ACCOUNT_FEATURES_NO_NAME" => Some(Self::AccountFeaturesNoName),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "CAN_NOT_RESERVE" => Some(Self::CanNotReserve),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "NAME_IS_RESERVED" => Some(Self::NameIsReserved),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AnyNameAllocate {}
        /// Nested message and enum types in `AnyNameAllocate`.
        pub mod any_name_allocate {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// PP node will register that name on behalf of the user
                #[prost(string, tag = "1")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "2")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        NotLoggedIn = 3,
                        PaymentNodeError = 4,
                        CacheError = 5,
                        MembershipNotFound = 6,
                        MembershipWrongState = 7,
                        BadAnyname = 8,
                        CanNotConnect = 9,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 10,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::NotLoggedIn => "NOT_LOGGED_IN",
                                Self::PaymentNodeError => "PAYMENT_NODE_ERROR",
                                Self::CacheError => "CACHE_ERROR",
                                Self::MembershipNotFound => "MEMBERSHIP_NOT_FOUND",
                                Self::MembershipWrongState => "MEMBERSHIP_WRONG_STATE",
                                Self::BadAnyname => "BAD_ANYNAME",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                "PAYMENT_NODE_ERROR" => Some(Self::PaymentNodeError),
                                "CACHE_ERROR" => Some(Self::CacheError),
                                "MEMBERSHIP_NOT_FOUND" => Some(Self::MembershipNotFound),
                                "MEMBERSHIP_WRONG_STATE" => Some(Self::MembershipWrongState),
                                "BAD_ANYNAME" => Some(Self::BadAnyname),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CartGet {}
        /// Nested message and enum types in `CartGet`.
        pub mod cart_get {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub cart: ::core::option::Option<crate::model::membership_v2::Cart>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CartUpdate {}
        /// Nested message and enum types in `CartUpdate`.
        pub mod cart_update {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, repeated, tag = "1")]
                pub product_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(bool, tag = "2")]
                pub is_yearly: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub cart: ::core::option::Option<crate::model::membership_v2::Cart>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                        BadProduct = 4,
                        /// set enableMembershipV2 in AccountCreate or AccountSelect
                        V2CallNotEnabled = 5,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::BadProduct => "BAD_PRODUCT",
                                Self::V2CallNotEnabled => "V2_CALL_NOT_ENABLED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "BAD_PRODUCT" => Some(Self::BadProduct),
                                "V2_CALL_NOT_ENABLED" => Some(Self::V2CallNotEnabled),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SubscribeToUpdates {}
        /// Nested message and enum types in `SubscribeToUpdates`.
        pub mod subscribe_to_updates {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub email: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::membership_v2::Platform", tag = "2")]
                pub platform: i32,
                /// if false - unsubscribe
                #[prost(bool, tag = "3")]
                pub subscribe: bool,
                /// additional data
                #[prost(string, tag = "4")]
                pub context: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                        PlatformNotSupported = 4,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                                Self::PlatformNotSupported => "PLATFORM_NOT_SUPPORTED",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                "PLATFORM_NOT_SUPPORTED" => Some(Self::PlatformNotSupported),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NameService {}
    /// Nested message and enum types in `NameService`.
    pub mod name_service {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResolveName {}
        /// Nested message and enum types in `ResolveName`.
        pub mod resolve_name {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "2")]
                pub ns_name_type: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(bool, tag = "2")]
                pub available: bool,
                /// EOA -> SCW -> name
                /// This field is non-empty only if name is "already registered"
                #[prost(string, tag = "3")]
                pub owner_scw_eth_address: ::prost::alloc::string::String,
                /// This field is non-empty only if name is "already registered"
                #[prost(string, tag = "4")]
                pub owner_eth_address: ::prost::alloc::string::String,
                /// A content hash attached to this name
                /// This field is non-empty only if name is "already registered"
                #[prost(string, tag = "5")]
                pub owner_any_address: ::prost::alloc::string::String,
                /// A SpaceId attached to this name
                /// This field is non-empty only if name is "already registered"
                #[prost(string, tag = "6")]
                pub space_id: ::prost::alloc::string::String,
                /// A timestamp when this name expires
                #[prost(int64, tag = "7")]
                pub name_expires: i64,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResolveAnyId {}
        /// Nested message and enum types in `ResolveAnyId`.
        pub mod resolve_any_id {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub any_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(bool, tag = "2")]
                pub found: bool,
                /// not including suffix
                #[prost(string, tag = "3")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "4")]
                pub ns_name_type: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResolveSpaceId {}
        /// Nested message and enum types in `ResolveSpaceId`.
        pub mod resolve_space_id {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(bool, tag = "2")]
                pub found: bool,
                /// not including suffix
                #[prost(string, tag = "3")]
                pub ns_name: ::prost::alloc::string::String,
                #[prost(enumeration = "crate::model::NameserviceNameType", tag = "4")]
                pub ns_name_type: i32,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        CanNotConnect = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::CanNotConnect => "CAN_NOT_CONNECT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UserAccount {}
        /// Nested message and enum types in `UserAccount`.
        pub mod user_account {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Get {}
            /// Nested message and enum types in `Get`.
            pub mod get {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {}
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "1")]
                    pub error: ::core::option::Option<response::Error>,
                    /// this will use ReverseResolve to get current name
                    /// user can buy many names, but
                    /// only 1 name can be set as "current": ETH address \<-> name
                    #[prost(string, tag = "2")]
                    pub ns_name_attached: ::prost::alloc::string::String,
                    #[prost(enumeration = "crate::model::NameserviceNameType", tag = "3")]
                    pub ns_name_type: i32,
                    /// Number of names that the user can reserve
                    #[prost(uint64, tag = "4")]
                    pub names_count_left: u64,
                    /// Number of operations: update name, add new data, etc
                    #[prost(uint64, tag = "5")]
                    pub operations_count_left: u64,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            NotLoggedIn = 3,
                            BadNameResolve = 4,
                            CanNotConnect = 5,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::NotLoggedIn => "NOT_LOGGED_IN",
                                    Self::BadNameResolve => "BAD_NAME_RESOLVE",
                                    Self::CanNotConnect => "CAN_NOT_CONNECT",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "NOT_LOGGED_IN" => Some(Self::NotLoggedIn),
                                    "BAD_NAME_RESOLVE" => Some(Self::BadNameResolve),
                                    "CAN_NOT_CONNECT" => Some(Self::CanNotConnect),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Broadcast {}
    /// Nested message and enum types in `Broadcast`.
    pub mod broadcast {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PayloadEvent {}
        /// Nested message and enum types in `PayloadEvent`.
        pub mod payload_event {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub payload: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
                #[prost(message, optional, tag = "2")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        InternalError = 3,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::InternalError => "INTERNAL_ERROR",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "INTERNAL_ERROR" => Some(Self::InternalError),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Device {}
    /// Nested message and enum types in `Device`.
    pub mod device {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetName {}
        /// Nested message and enum types in `SetName`.
        pub mod set_name {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub device_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub name: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct List {}
        /// Nested message and enum types in `List`.
        pub mod list {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub devices: ::prost::alloc::vec::Vec<crate::model::DeviceInfo>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct NetworkState {}
        /// Nested message and enum types in `NetworkState`.
        pub mod network_state {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Set {}
            /// Nested message and enum types in `Set`.
            pub mod set {
                #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Request {
                    #[prost(enumeration = "crate::model::DeviceNetworkType", tag = "1")]
                    pub device_network_type: i32,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Response {
                    #[prost(message, optional, tag = "2")]
                    pub error: ::core::option::Option<response::Error>,
                }
                /// Nested message and enum types in `Response`.
                pub mod response {
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct Error {
                        #[prost(enumeration = "error::Code", tag = "1")]
                        pub code: i32,
                        #[prost(string, tag = "2")]
                        pub description: ::prost::alloc::string::String,
                    }
                    /// Nested message and enum types in `Error`.
                    pub mod error {
                        #[derive(
                            Clone,
                            Copy,
                            Debug,
                            PartialEq,
                            Eq,
                            Hash,
                            PartialOrd,
                            Ord,
                            ::prost::Enumeration,
                        )]
                        #[repr(i32)]
                        pub enum Code {
                            Null = 0,
                            UnknownError = 1,
                            BadInput = 2,
                            InternalError = 3,
                        }
                        impl Code {
                            /// String value of the enum field names used in the ProtoBuf definition.
                            ///
                            /// The values are not transformed in any way and thus are considered stable
                            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                            pub fn as_str_name(&self) -> &'static str {
                                match self {
                                    Self::Null => "NULL",
                                    Self::UnknownError => "UNKNOWN_ERROR",
                                    Self::BadInput => "BAD_INPUT",
                                    Self::InternalError => "INTERNAL_ERROR",
                                }
                            }
                            /// Creates an enum from field names used in the ProtoBuf definition.
                            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                                match value {
                                    "NULL" => Some(Self::Null),
                                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                    "BAD_INPUT" => Some(Self::BadInput),
                                    "INTERNAL_ERROR" => Some(Self::InternalError),
                                    _ => None,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Chat {}
    /// Nested message and enum types in `Chat`.
    pub mod chat {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AddMessage {}
        /// Nested message and enum types in `AddMessage`.
        pub mod add_message {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "2")]
                pub message: ::core::option::Option<crate::model::ChatMessage>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(string, tag = "2")]
                pub message_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EditMessageContent {}
        /// Nested message and enum types in `EditMessageContent`.
        pub mod edit_message_content {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub message_id: ::prost::alloc::string::String,
                #[prost(message, optional, tag = "3")]
                pub edited_message: ::core::option::Option<crate::model::ChatMessage>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ToggleMessageReaction {}
        /// Nested message and enum types in `ToggleMessageReaction`.
        pub mod toggle_message_reaction {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub message_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub emoji: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// Added is true when reaction is added, false when removed
                #[prost(bool, tag = "2")]
                pub added: bool,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DeleteMessage {}
        /// Nested message and enum types in `DeleteMessage`.
        pub mod delete_message {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub message_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetMessages {}
        /// Nested message and enum types in `GetMessages`.
        pub mod get_messages {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                /// OrderId of the message after which to get messages
                #[prost(string, tag = "4")]
                pub after_order_id: ::prost::alloc::string::String,
                /// OrderId of the message before which to get messages
                #[prost(string, tag = "2")]
                pub before_order_id: ::prost::alloc::string::String,
                #[prost(int32, tag = "3")]
                pub limit: i32,
                /// If true, include a message at the boundary (afterOrderId or beforeOrderId)
                #[prost(bool, tag = "5")]
                pub include_boundary: bool,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub messages: ::prost::alloc::vec::Vec<crate::model::ChatMessage>,
                #[prost(message, optional, tag = "3")]
                pub chat_state: ::core::option::Option<crate::model::ChatState>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct GetMessagesByIds {}
        /// Nested message and enum types in `GetMessagesByIds`.
        pub mod get_messages_by_ids {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub message_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub messages: ::prost::alloc::vec::Vec<crate::model::ChatMessage>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SubscribeLastMessages {}
        /// Nested message and enum types in `SubscribeLastMessages`.
        pub mod subscribe_last_messages {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Identifier for the chat
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                /// Number of max last messages to return and subscribe
                #[prost(int32, tag = "2")]
                pub limit: i32,
                #[prost(string, tag = "3")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                /// List of messages
                #[prost(message, repeated, tag = "2")]
                pub messages: ::prost::alloc::vec::Vec<crate::model::ChatMessage>,
                /// Number of messages before the returned messages
                #[prost(int32, tag = "3")]
                pub num_messages_before: i32,
                /// Chat state
                #[prost(message, optional, tag = "4")]
                pub chat_state: ::core::option::Option<crate::model::ChatState>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Unsubscribe {}
        /// Nested message and enum types in `Unsubscribe`.
        pub mod unsubscribe {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                /// Identifier for the chat
                #[prost(string, tag = "1")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SubscribeToMessagePreviews {}
        /// Nested message and enum types in `SubscribeToMessagePreviews`.
        pub mod subscribe_to_message_previews {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub previews: ::prost::alloc::vec::Vec<response::ChatPreview>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ChatPreview {
                    #[prost(string, tag = "1")]
                    pub space_id: ::prost::alloc::string::String,
                    #[prost(string, tag = "2")]
                    pub chat_object_id: ::prost::alloc::string::String,
                    #[prost(message, optional, tag = "3")]
                    pub message: ::core::option::Option<crate::model::ChatMessage>,
                    #[prost(message, optional, tag = "4")]
                    pub state: ::core::option::Option<crate::model::ChatState>,
                    #[prost(message, repeated, tag = "5")]
                    pub dependencies: ::prost::alloc::vec::Vec<::prost_types::Struct>,
                }
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct UnsubscribeFromMessagePreviews {}
        /// Nested message and enum types in `UnsubscribeFromMessagePreviews`.
        pub mod unsubscribe_from_message_previews {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub sub_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ReadMessages {}
        /// Nested message and enum types in `ReadMessages`.
        pub mod read_messages {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(enumeration = "ReadType", tag = "1")]
                pub r#type: i32,
                /// id of the chat object
                #[prost(string, tag = "2")]
                pub chat_object_id: ::prost::alloc::string::String,
                /// read from this orderId; if empty - read from the beginning of the chat
                #[prost(string, tag = "3")]
                pub after_order_id: ::prost::alloc::string::String,
                /// read til this orderId
                #[prost(string, tag = "4")]
                pub before_order_id: ::prost::alloc::string::String,
                /// stateId from the last processed ChatState event(or GetMessages). Used to prevent race conditions
                #[prost(string, tag = "5")]
                pub last_state_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                        /// chat is empty or invalid beforeOrderId/lastDbState
                        MessagesNotFound = 100,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                                Self::MessagesNotFound => "MESSAGES_NOT_FOUND",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                "MESSAGES_NOT_FOUND" => Some(Self::MessagesNotFound),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ReadType {
                Messages = 0,
                Mentions = 1,
            }
            impl ReadType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Messages => "Messages",
                        Self::Mentions => "Mentions",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Messages" => Some(Self::Messages),
                        "Mentions" => Some(Self::Mentions),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Unread {}
        /// Nested message and enum types in `Unread`.
        pub mod unread {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(enumeration = "ReadType", tag = "1")]
                pub r#type: i32,
                #[prost(string, tag = "2")]
                pub chat_object_id: ::prost::alloc::string::String,
                #[prost(string, tag = "3")]
                pub after_order_id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum ReadType {
                Messages = 0,
                Mentions = 1,
            }
            impl ReadType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Messages => "Messages",
                        Self::Mentions => "Mentions",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Messages" => Some(Self::Messages),
                        "Mentions" => Some(Self::Mentions),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ReadAll {}
        /// Nested message and enum types in `ReadAll`.
        pub mod read_all {
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {}
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        /// ...
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Search {}
        /// Nested message and enum types in `Search`.
        pub mod search {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub chat_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "3")]
                pub sorts: ::prost::alloc::vec::Vec<crate::model::search::message::Sort>,
                #[prost(string, tag = "4")]
                pub full_text: ::prost::alloc::string::String,
                #[prost(int32, tag = "5")]
                pub offset: i32,
                #[prost(int32, tag = "6")]
                pub limit: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, repeated, tag = "2")]
                pub results: ::prost::alloc::vec::Vec<crate::model::search::message::Result>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PushNotification {}
    /// Nested message and enum types in `PushNotification`.
    pub mod push_notification {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RegisterToken {}
        /// Nested message and enum types in `RegisterToken`.
        pub mod register_token {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub token: ::prost::alloc::string::String,
                #[prost(enumeration = "Platform", tag = "2")]
                pub platform: i32,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Platform {
                Ios = 0,
                Android = 1,
            }
            impl Platform {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Ios => "IOS",
                        Self::Android => "Android",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "IOS" => Some(Self::Ios),
                        "Android" => Some(Self::Android),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetSpaceMode {}
        /// Nested message and enum types in `SetSpaceMode`.
        pub mod set_space_mode {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(enumeration = "super::Mode", tag = "2")]
                pub mode: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SetForceModeIds {}
        /// Nested message and enum types in `SetForceModeIds`.
        pub mod set_force_mode_ids {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub chat_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
                #[prost(enumeration = "super::Mode", tag = "3")]
                pub mode: i32,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ResetIds {}
        /// Nested message and enum types in `ResetIds`.
        pub mod reset_ids {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Request {
                #[prost(string, tag = "1")]
                pub space_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "2")]
                pub chat_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Response {
                #[prost(message, optional, tag = "1")]
                pub error: ::core::option::Option<response::Error>,
                #[prost(message, optional, tag = "2")]
                pub event: ::core::option::Option<super::super::super::ResponseEvent>,
            }
            /// Nested message and enum types in `Response`.
            pub mod response {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Error {
                    #[prost(enumeration = "error::Code", tag = "1")]
                    pub code: i32,
                    #[prost(string, tag = "2")]
                    pub description: ::prost::alloc::string::String,
                }
                /// Nested message and enum types in `Error`.
                pub mod error {
                    #[derive(
                        Clone,
                        Copy,
                        Debug,
                        PartialEq,
                        Eq,
                        Hash,
                        PartialOrd,
                        Ord,
                        ::prost::Enumeration,
                    )]
                    #[repr(i32)]
                    pub enum Code {
                        Null = 0,
                        UnknownError = 1,
                        BadInput = 2,
                    }
                    impl Code {
                        /// String value of the enum field names used in the ProtoBuf definition.
                        ///
                        /// The values are not transformed in any way and thus are considered stable
                        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                        pub fn as_str_name(&self) -> &'static str {
                            match self {
                                Self::Null => "NULL",
                                Self::UnknownError => "UNKNOWN_ERROR",
                                Self::BadInput => "BAD_INPUT",
                            }
                        }
                        /// Creates an enum from field names used in the ProtoBuf definition.
                        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                            match value {
                                "NULL" => Some(Self::Null),
                                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                                "BAD_INPUT" => Some(Self::BadInput),
                                _ => None,
                            }
                        }
                    }
                }
            }
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Mode {
            All = 0,
            Mentions = 1,
            Nothing = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::All => "All",
                    Self::Mentions => "Mentions",
                    Self::Nothing => "Nothing",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "All" => Some(Self::All),
                    "Mentions" => Some(Self::Mentions),
                    "Nothing" => Some(Self::Nothing),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamRequest {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod client_commands_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ClientCommandsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ClientCommandsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ClientCommandsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ClientCommandsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                    http::Request<tonic::body::Body>,
                    Response = http::Response<
                        <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                    >,
                >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ClientCommandsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn app_get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::app::get_version::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::app::get_version::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AppGetVersion");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AppGetVersion"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn app_set_device_state(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::app::set_device_state::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::app::set_device_state::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AppSetDeviceState");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AppSetDeviceState",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn app_shutdown(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::app::shutdown::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::app::shutdown::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AppShutdown");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AppShutdown"));
            self.inner.unary(req, path, codec).await
        }
        /// Wallet
        ///
        /// ---
        pub async fn wallet_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::wallet::create::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::wallet::create::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WalletCreate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WalletCreate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wallet_recover(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::wallet::recover::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::wallet::recover::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WalletRecover");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WalletRecover"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wallet_convert(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::wallet::convert::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::wallet::convert::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WalletConvert");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WalletConvert"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_local_link_new_challenge(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::local_link::new_challenge::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::local_link::new_challenge::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountLocalLinkNewChallenge",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountLocalLinkNewChallenge",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_local_link_solve_challenge(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::local_link::solve_challenge::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::local_link::solve_challenge::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountLocalLinkSolveChallenge",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountLocalLinkSolveChallenge",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_local_link_create_app(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::local_link::create_app::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::local_link::create_app::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountLocalLinkCreateApp",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountLocalLinkCreateApp",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_local_link_list_apps(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::local_link::list_apps::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::local_link::list_apps::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountLocalLinkListApps",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountLocalLinkListApps",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_local_link_revoke_app(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::local_link::revoke_app::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::local_link::revoke_app::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountLocalLinkRevokeApp",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountLocalLinkRevokeApp",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wallet_create_session(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::wallet::create_session::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::wallet::create_session::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WalletCreateSession");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WalletCreateSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn wallet_close_session(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::wallet::close_session::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::wallet::close_session::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WalletCloseSession");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WalletCloseSession",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Workspace
        ///
        /// ---
        pub async fn workspace_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceCreate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WorkspaceCreate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_open(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::open::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::open::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceOpen");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WorkspaceOpen"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_object_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::object::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::object::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceObjectAdd");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WorkspaceObjectAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_object_list_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::object::list_add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::object::list_add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/WorkspaceObjectListAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WorkspaceObjectListAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_object_list_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::object::list_remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::object::list_remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/WorkspaceObjectListRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WorkspaceObjectListRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_select(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::select::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::select::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceSelect");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WorkspaceSelect"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_get_current(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::get_current::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::get_current::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceGetCurrent");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WorkspaceGetCurrent",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_get_all(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::get_all::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::get_all::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceGetAll");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WorkspaceGetAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_set_info(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::set_info::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::set_info::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceSetInfo");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "WorkspaceSetInfo",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn workspace_export(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::workspace::export::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::workspace::export::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/WorkspaceExport");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "WorkspaceExport"));
            self.inner.unary(req, path, codec).await
        }
        /// Account
        ///
        /// ---
        pub async fn account_recover(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::recover::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::recover::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountRecover");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountRecover"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_migrate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::migrate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::migrate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountMigrate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountMigrate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_migrate_cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::migrate_cancel::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::migrate_cancel::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountMigrateCancel",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountMigrateCancel",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountCreate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountCreate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountDelete");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountDelete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_revert_deletion(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::revert_deletion::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::revert_deletion::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountRevertDeletion",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountRevertDeletion",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_select(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::select::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::select::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountSelect");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountSelect"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_enable_local_network_sync(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::enable_local_network_sync::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::enable_local_network_sync::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountEnableLocalNetworkSync",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountEnableLocalNetworkSync",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_change_json_api_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::change_json_api_addr::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::change_json_api_addr::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountChangeJsonApiAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountChangeJsonApiAddr",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_stop(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::stop::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::account::stop::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountStop");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountStop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_move(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::r#move::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::r#move::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountMove");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AccountMove"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_config_update(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::config_update::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::config_update::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AccountConfigUpdate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountConfigUpdate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_recover_from_legacy_export(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::account::recover_from_legacy_export::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::recover_from_legacy_export::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountRecoverFromLegacyExport",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountRecoverFromLegacyExport",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn account_change_network_config_and_restart(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::account::change_network_config_and_restart::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::account::change_network_config_and_restart::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AccountChangeNetworkConfigAndRestart",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AccountChangeNetworkConfigAndRestart",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Space
        ///
        /// ---
        pub async fn space_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::delete::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::space::delete::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceDelete");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceDelete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_generate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_generate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_generate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceInviteGenerate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceInviteGenerate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_change(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_change::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_change::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceInviteChange");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceInviteChange",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_get_current(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_get_current::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_get_current::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/SpaceInviteGetCurrent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceInviteGetCurrent",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_get_guest(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_get_guest::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_get_guest::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceInviteGetGuest");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceInviteGetGuest",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_revoke(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_revoke::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_revoke::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceInviteRevoke");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceInviteRevoke",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_invite_view(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::invite_view::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::invite_view::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceInviteView");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceInviteView"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_join(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::join::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::space::join::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceJoin");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceJoin"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_join_cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::join_cancel::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::join_cancel::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceJoinCancel");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceJoinCancel"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_stop_sharing(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::stop_sharing::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::stop_sharing::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceStopSharing");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceStopSharing",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_request_approve(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::request_approve::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::request_approve::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceRequestApprove");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceRequestApprove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_request_decline(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::request_decline::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::request_decline::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceRequestDecline");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceRequestDecline",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_leave_approve(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::leave_approve::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::leave_approve::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceLeaveApprove");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceLeaveApprove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_make_shareable(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::make_shareable::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::make_shareable::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceMakeShareable");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceMakeShareable",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_participant_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::participant_remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::participant_remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/SpaceParticipantRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceParticipantRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_participant_permissions_change(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::participant_permissions_change::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::participant_permissions_change::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/SpaceParticipantPermissionsChange",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceParticipantPermissionsChange",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_set_order(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::set_order::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::set_order::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceSetOrder");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceSetOrder"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_unset_order(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::unset_order::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::unset_order::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/SpaceUnsetOrder");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "SpaceUnsetOrder"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_change_ownership(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::change_ownership::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::change_ownership::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/SpaceChangeOwnership",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceChangeOwnership",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn space_delete_corrupted_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::space::delete_corrupted_backup::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::space::delete_corrupted_backup::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/SpaceDeleteCorruptedBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "SpaceDeleteCorruptedBackup",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Publishing
        ///
        /// ---
        pub async fn publishing_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::publishing::create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::publishing::create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/PublishingCreate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PublishingCreate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn publishing_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::publishing::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::publishing::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/PublishingRemove");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PublishingRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn publishing_list(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::publishing::list::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::publishing::list::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/PublishingList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "PublishingList"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn publishing_resolve_uri(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::publishing::resolve_uri::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::publishing::resolve_uri::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/PublishingResolveUri",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PublishingResolveUri",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn publishing_get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::publishing::get_status::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::publishing::get_status::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/PublishingGetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PublishingGetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Object
        ///
        /// ---
        pub async fn object_open(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::open::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::open::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectOpen");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectOpen"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_refresh(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::refresh::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::refresh::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectRefresh");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectRefresh"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_close(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::close::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::close::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectClose");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectClose"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_show(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::show::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::show::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectShow");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectShow"));
            self.inner.unary(req, path, codec).await
        }
        /// ObjectCreate just creates the new page, without adding the link to it from some other page
        pub async fn object_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::create::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectCreate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectCreate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_create_bookmark(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_bookmark::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_bookmark::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCreateBookmark",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCreateBookmark",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_create_from_url(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_from_url::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_from_url::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectCreateFromUrl");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCreateFromUrl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ObjectCreateSet just creates the new set, without adding the link to it from some other page
        pub async fn object_create_set(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_set::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_set::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectCreateSet");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectCreateSet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_graph(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::graph::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::graph::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectGraph");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectGraph"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_search(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::search::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::search::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSearch");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectSearch"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_search_with_meta(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::search_with_meta::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::search_with_meta::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectSearchWithMeta",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSearchWithMeta",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_search_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::search_subscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::search_subscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectSearchSubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSearchSubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_cross_space_search_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::cross_space_search_subscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::cross_space_search_subscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCrossSpaceSearchSubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCrossSpaceSearchSubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_cross_space_search_unsubscribe(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::object::cross_space_search_unsubscribe::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::cross_space_search_unsubscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCrossSpaceSearchUnsubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCrossSpaceSearchUnsubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_subscribe_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::subscribe_ids::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::subscribe_ids::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSubscribeIds");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSubscribeIds",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_groups_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::groups_subscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::groups_subscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectGroupsSubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectGroupsSubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_search_unsubscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::search_unsubscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::search_unsubscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectSearchUnsubscribe",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSearchUnsubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_details(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_details::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_details::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetDetails");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSetDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_duplicate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::duplicate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::duplicate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectDuplicate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectDuplicate"));
            self.inner.unary(req, path, codec).await
        }
        /// ObjectSetObjectType sets an existing object type to the object so it will appear in sets and suggests relations from this type
        pub async fn object_set_object_type(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_object_type::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_object_type::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetObjectType");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSetObjectType",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_layout(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_layout::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_layout::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetLayout");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectSetLayout"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_internal_flags(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_internal_flags::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_internal_flags::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectSetInternalFlags",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSetInternalFlags",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_is_favorite(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_is_favorite::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_is_favorite::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetIsFavorite");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSetIsFavorite",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_is_archived(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_is_archived::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_is_archived::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetIsArchived");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectSetIsArchived",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_set_source(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::set_source::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::set_source::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectSetSource");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectSetSource"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_workspace_set_dashboard(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::workspace_set_dashboard::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::workspace_set_dashboard::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectWorkspaceSetDashboard",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectWorkspaceSetDashboard",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_duplicate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_duplicate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_duplicate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectListDuplicate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListDuplicate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectListDelete");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_set_is_archived(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_set_is_archived::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_set_is_archived::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectListSetIsArchived",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListSetIsArchived",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_set_is_favorite(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_set_is_favorite::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_set_is_favorite::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectListSetIsFavorite",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListSetIsFavorite",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_set_object_type(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_set_object_type::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_set_object_type::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectListSetObjectType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListSetObjectType",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_set_details(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_set_details::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_set_details::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectListSetDetails",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListSetDetails",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_modify_detail_values(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_modify_detail_values::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_modify_detail_values::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectListModifyDetailValues",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListModifyDetailValues",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_apply_template(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::apply_template::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::apply_template::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectApplyTemplate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectApplyTemplate",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ObjectToSet creates new set from given object and removes object
        pub async fn object_to_set(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::to_set::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::to_set::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectToSet");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectToSet"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_to_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::to_collection::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::to_collection::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectToCollection");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectToCollection",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_share_by_link(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::share_by_link::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::share_by_link::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectShareByLink");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectShareByLink",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_undo(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::undo::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::undo::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectUndo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectUndo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_redo(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::redo::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::redo::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectRedo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectRedo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_list_export(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::list_export::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::list_export::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectListExport");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectListExport",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_export(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::export::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::export::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectExport");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectExport"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_bookmark_fetch(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::bookmark_fetch::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::bookmark_fetch::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectBookmarkFetch");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectBookmarkFetch",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_import(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::import::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::object::import::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectImport");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectImport"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_import_list(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::import_list::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::import_list::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectImportList");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectImportList",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_import_notion_validate_token(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::object::import::notion::validate_token::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::import::notion::validate_token::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectImportNotionValidateToken",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectImportNotionValidateToken",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_import_use_case(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::import_use_case::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::import_use_case::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectImportUseCase");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectImportUseCase",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_import_experience(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::import_experience::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::import_experience::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectImportExperience",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectImportExperience",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_date_by_timestamp(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::date_by_timestamp::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::date_by_timestamp::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectDateByTimestamp",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectDateByTimestamp",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Collections
        ///
        /// ---
        pub async fn object_collection_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_collection::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_collection::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectCollectionAdd");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCollectionAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_collection_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_collection::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_collection::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCollectionRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCollectionRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_collection_sort(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_collection::sort::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_collection::sort::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCollectionSort",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCollectionSort",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Relations
        ///
        /// ---
        pub async fn object_create_relation(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_relation::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_relation::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCreateRelation",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCreateRelation",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_create_relation_option(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_relation_option::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_relation_option::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCreateRelationOption",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCreateRelationOption",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn relation_list_remove_option(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::relation::list_remove_option::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::relation::list_remove_option::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/RelationListRemoveOption",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "RelationListRemoveOption",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn relation_options(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::relation::options::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::relation::options::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/RelationOptions");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "RelationOptions"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn relation_option_set_order(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::relation::option::set_order::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::relation::option::set_order::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/RelationOptionSetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "RelationOptionSetOrder",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn relation_list_with_value(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::relation::list_with_value::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::relation::list_with_value::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/RelationListWithValue",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "RelationListWithValue",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Object Relations
        ///
        /// ---
        pub async fn object_relation_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_relation::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_relation::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectRelationAdd");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectRelationAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_relation_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_relation::delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_relation::delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectRelationDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectRelationDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_relation_add_featured(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_relation::add_featured::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_relation::add_featured::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectRelationAddFeatured",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectRelationAddFeatured",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_relation_remove_featured(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_relation::remove_featured::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_relation::remove_featured::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectRelationRemoveFeatured",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectRelationRemoveFeatured",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_relation_list_available(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_relation::list_available::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_relation::list_available::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectRelationListAvailable",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectRelationListAvailable",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ObjectType commands
        ///
        /// ---
        pub async fn object_create_object_type(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::create_object_type::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::create_object_type::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectCreateObjectType",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectCreateObjectType",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_relation_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_type::relation::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::relation::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeRelationAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeRelationAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_relation_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_type::relation::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::relation::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeRelationRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeRelationRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_recommended_relations_set(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::object_type::recommended::relations_set::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::recommended::relations_set::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeRecommendedRelationsSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeRecommendedRelationsSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_recommended_featured_relations_set(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::object_type::recommended::featured_relations_set::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::recommended::featured_relations_set::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeRecommendedFeaturedRelationsSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeRecommendedFeaturedRelationsSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_list_conflicting_relations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::object_type::list_conflicting_relations::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::list_conflicting_relations::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeListConflictingRelations",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeListConflictingRelations",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_resolve_layout_conflicts(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_type::resolve_layout_conflicts::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::resolve_layout_conflicts::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ObjectTypeResolveLayoutConflicts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeResolveLayoutConflicts",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_type_set_order(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object_type::set_order::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object_type::set_order::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectTypeSetOrder");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ObjectTypeSetOrder",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn history_show_version(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::history::show_version::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::history::show_version::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/HistoryShowVersion");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "HistoryShowVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn history_get_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::history::get_versions::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::history::get_versions::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/HistoryGetVersions");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "HistoryGetVersions",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn history_set_version(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::history::set_version::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::history::set_version::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/HistorySetVersion");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "HistorySetVersion",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn history_diff_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::history::diff_versions::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::history::diff_versions::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/HistoryDiffVersions");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "HistoryDiffVersions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Files
        ///
        /// ---
        pub async fn file_space_offload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::space_offload::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::space_offload::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileSpaceOffload");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileSpaceOffload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_reconcile(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::reconcile::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::reconcile::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileReconcile");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileReconcile"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_list_offload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::list_offload::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::list_offload::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileListOffload");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileListOffload"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_upload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::upload::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::file::upload::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileUpload");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileUpload"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_download(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::download::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::file::download::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileDownload");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileDownload"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_discard_preload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::discard_preload::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::discard_preload::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileDiscardPreload");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileDiscardPreload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_drop(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::drop::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::file::drop::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileDrop");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileDrop"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_space_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::space_usage::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::space_usage::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileSpaceUsage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileSpaceUsage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_node_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::node_usage::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::node_usage::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileNodeUsage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "FileNodeUsage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_set_auto_download(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::set_auto_download::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::set_auto_download::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileSetAutoDownload");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileSetAutoDownload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_cache_download(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::cache_download::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::cache_download::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/FileCacheDownload");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileCacheDownload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_cache_cancel_download(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::cache_cancel_download::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::cache_cancel_download::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/FileCacheCancelDownload",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileCacheCancelDownload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn file_auto_download_set_limit(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::file::auto_download_set_limit::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::file::auto_download_set_limit::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/FileAutoDownloadSetLimit",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "FileAutoDownloadSetLimit",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn navigation_list_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::navigation::list_objects::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::navigation::list_objects::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/NavigationListObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NavigationListObjects",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn navigation_get_object_info_with_links(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::navigation::get_object_info_with_links::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::navigation::get_object_info_with_links::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/NavigationGetObjectInfoWithLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NavigationGetObjectInfoWithLinks",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn template_create_from_object(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::template::create_from_object::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::template::create_from_object::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/TemplateCreateFromObject",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "TemplateCreateFromObject",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn template_clone(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::template::clone::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::template::clone::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/TemplateClone");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "TemplateClone"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn template_export_all(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::template::export_all::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::template::export_all::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/TemplateExportAll");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "TemplateExportAll",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn link_preview(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::link_preview::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::link_preview::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/LinkPreview");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "LinkPreview"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unsplash_search(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::unsplash::search::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::unsplash::search::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/UnsplashSearch");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "UnsplashSearch"));
            self.inner.unary(req, path, codec).await
        }
        /// UnsplashDownload downloads picture from unsplash by ID, put it to the IPFS and returns the hash.
        /// The artist info is available in the object details
        pub async fn unsplash_download(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::unsplash::download::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::unsplash::download::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/UnsplashDownload");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "UnsplashDownload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn gallery_download_manifest(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::gallery::download_manifest::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::gallery::download_manifest::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/GalleryDownloadManifest",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "GalleryDownloadManifest",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn gallery_download_index(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::gallery::download_index::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::gallery::download_index::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/GalleryDownloadIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "GalleryDownloadIndex",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// General Block commands
        ///
        /// ---
        pub async fn block_upload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::upload::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::upload::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockUpload");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockUpload"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_replace(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::replace::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::replace::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockReplace");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockReplace"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::create::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::create::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockCreate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockCreate"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_split(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::split::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::split::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockSplit");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockSplit"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_merge(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::merge::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::merge::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockMerge");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockMerge"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_copy(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::copy::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::copy::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockCopy");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockCopy"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_paste(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::paste::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::paste::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockPaste");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockPaste"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_cut(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::cut::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::cut::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockCut");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockCut"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_set_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::set_fields::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::set_fields::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockSetFields");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockSetFields"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_export(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::export::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::export::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockExport");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockExport"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_set_carriage(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::set_carriage::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::set_carriage::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockSetCarriage");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockSetCarriage",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_preview(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::preview::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::block::preview::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockPreview");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockPreview"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockListDelete");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockListDelete"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_move_to_existing_object(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_move_to_existing_object::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_move_to_existing_object::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockListMoveToExistingObject",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListMoveToExistingObject",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_move_to_new_object(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_move_to_new_object::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_move_to_new_object::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockListMoveToNewObject",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListMoveToNewObject",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_convert_to_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_convert_to_objects::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_convert_to_objects::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockListConvertToObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListConvertToObjects",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_set_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_set_fields::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_set_fields::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockListSetFields");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListSetFields",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_duplicate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_duplicate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_duplicate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockListDuplicate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListDuplicate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_set_background_color(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_set_background_color::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_set_background_color::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockListSetBackgroundColor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListSetBackgroundColor",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_set_align(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_set_align::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_set_align::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockListSetAlign");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListSetAlign",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_set_vertical_align(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_set_vertical_align::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_set_vertical_align::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockListSetVerticalAlign",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListSetVerticalAlign",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_list_turn_into(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::list_turn_into::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::list_turn_into::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockListTurnInto");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockListTurnInto",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Text Block commands
        ///
        /// ---
        pub async fn block_text_set_text(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::set_text::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::set_text::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTextSetText");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextSetText",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_set_color(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::set_color::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::set_color::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTextSetColor");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextSetColor",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_set_style(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::set_style::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::set_style::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTextSetStyle");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextSetStyle",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_set_checked(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::set_checked::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::set_checked::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTextSetChecked");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextSetChecked",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_set_icon(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::set_icon::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::set_icon::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTextSetIcon");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextSetIcon",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_list_set_color(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::list_set_color::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::list_set_color::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTextListSetColor",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextListSetColor",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_list_set_mark(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::list_set_mark::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::list_set_mark::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTextListSetMark",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextListSetMark",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_list_set_style(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::list_set_style::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::list_set_style::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTextListSetStyle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextListSetStyle",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_list_clear_style(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::list_clear_style::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::list_clear_style::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTextListClearStyle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextListClearStyle",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_text_list_clear_content(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_text::list_clear_content::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_text::list_clear_content::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTextListClearContent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTextListClearContent",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// File block commands
        ///
        /// ---
        pub async fn block_file_set_name(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_file::set_name::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_file::set_name::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockFileSetName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockFileSetName",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_file_set_target_object_id(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_file::set_target_object_id::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_file::set_target_object_id::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockFileSetTargetObjectId",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockFileSetTargetObjectId",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_image_set_name(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_image::set_name::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_image::set_name::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockImageSetName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockImageSetName",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_video_set_name(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_video::set_name::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_video::set_name::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockVideoSetName");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockVideoSetName",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_file_create_and_upload(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_file::create_and_upload::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_file::create_and_upload::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockFileCreateAndUpload",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockFileCreateAndUpload",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_file_list_set_style(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_file::list_set_style::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_file::list_set_style::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockFileListSetStyle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockFileListSetStyle",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Dataview block commands
        ///
        /// ---
        pub async fn block_dataview_view_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view::create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view::create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewCreate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewCreate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view::delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view::delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_update(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view::update::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view::update::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewUpdate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_set_active(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view::set_active::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view::set_active::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewSetActive",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewSetActive",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_set_position(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view::set_position::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view::set_position::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewSetPosition",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewSetPosition",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_set_source(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::set_source::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::set_source::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewSetSource",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewSetSource",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_relation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::relation::set::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::relation::set::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewRelationSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewRelationSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_relation_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::relation::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::relation::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewRelationAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewRelationAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_relation_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::relation::delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::relation::delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewRelationDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewRelationDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_group_order_update(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::group_order::update::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::group_order::update::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewGroupOrderUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewGroupOrderUpdate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_object_order_update(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::object_order::update::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::object_order::update::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewObjectOrderUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewObjectOrderUpdate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_object_order_move(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::object_order::r#move::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::object_order::r#move::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewObjectOrderMove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewObjectOrderMove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_create_from_existing_object(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::block_dataview::create_from_existing_object::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::create_from_existing_object::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewCreateFromExistingObject",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewCreateFromExistingObject",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_filter_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::filter::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::filter::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewFilterAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewFilterAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_filter_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::filter::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::filter::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewFilterRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewFilterRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_filter_replace(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::filter::replace::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::filter::replace::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewFilterReplace",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewFilterReplace",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_filter_sort(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::filter::sort::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::filter::sort::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewFilterSort",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewFilterSort",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_sort_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::sort::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::sort::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewSortAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewSortAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_sort_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::sort::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::sort::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewSortRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewSortRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_sort_replace(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::sort::replace::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::sort::replace::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewSortReplace",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewSortReplace",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_sort_sort(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::sort::s_sort::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::sort::s_sort::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewSortSort",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewSortSort",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_relation_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view_relation::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view_relation::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewRelationAdd",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewRelationAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_relation_remove(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view_relation::remove::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view_relation::remove::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewRelationRemove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewRelationRemove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_relation_replace(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::block_dataview::view_relation::replace::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view_relation::replace::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewRelationReplace",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewRelationReplace",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_dataview_view_relation_sort(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_dataview::view_relation::sort::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_dataview::view_relation::sort::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDataviewViewRelationSort",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDataviewViewRelationSort",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Simple table block commands
        ///
        /// ---
        pub async fn block_table_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTableCreate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableCreate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_expand(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::expand::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::expand::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTableExpand");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableExpand",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTableRowCreate");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowCreate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTableRowDelete");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_duplicate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_duplicate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_duplicate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableRowDuplicate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowDuplicate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_set_header(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_set_header::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_set_header::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableRowSetHeader",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowSetHeader",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_column_create(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::column_create::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::column_create::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableColumnCreate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableColumnCreate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_column_move(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::column_move::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::column_move::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableColumnMove",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableColumnMove",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_column_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::column_delete::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::column_delete::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableColumnDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableColumnDelete",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_column_duplicate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::column_duplicate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::column_duplicate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableColumnDuplicate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableColumnDuplicate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_list_fill(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_list_fill::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_list_fill::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableRowListFill",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowListFill",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_row_list_clean(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::row_list_clean::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::row_list_clean::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableRowListClean",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableRowListClean",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_column_list_fill(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::column_list_fill::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::column_list_fill::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockTableColumnListFill",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockTableColumnListFill",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_table_sort(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_table::sort::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_table::sort::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockTableSort");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "BlockTableSort"));
            self.inner.unary(req, path, codec).await
        }
        /// Widget commands
        ///
        /// ---
        pub async fn block_create_widget(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block::create_widget::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block::create_widget::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockCreateWidget");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockCreateWidget",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_widget_set_target_id(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_widget::set_target_id::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_widget::set_target_id::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockWidgetSetTargetId",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockWidgetSetTargetId",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_widget_set_layout(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_widget::set_layout::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_widget::set_layout::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockWidgetSetLayout",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockWidgetSetLayout",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_widget_set_limit(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_widget::set_limit::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_widget::set_limit::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockWidgetSetLimit");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockWidgetSetLimit",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_widget_set_view_id(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_widget::set_view_id::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_widget::set_view_id::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockWidgetSetViewId",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockWidgetSetViewId",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Other specific block commands
        ///
        /// ---
        pub async fn block_link_create_with_object(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_link::create_with_object::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_link::create_with_object::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockLinkCreateWithObject",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockLinkCreateWithObject",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_link_list_set_appearance(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_link::list_set_appearance::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_link::list_set_appearance::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockLinkListSetAppearance",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockLinkListSetAppearance",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_bookmark_fetch(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_bookmark::fetch::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_bookmark::fetch::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockBookmarkFetch");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockBookmarkFetch",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_bookmark_create_and_fetch(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_bookmark::create_and_fetch::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_bookmark::create_and_fetch::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockBookmarkCreateAndFetch",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockBookmarkCreateAndFetch",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_relation_set_key(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_relation::set_key::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_relation::set_key::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockRelationSetKey");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockRelationSetKey",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_relation_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_relation::add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_relation::add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockRelationAdd");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockRelationAdd",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_div_list_set_style(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_div::list_set_style::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_div::list_set_style::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BlockDivListSetStyle",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockDivListSetStyle",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn block_latex_set_text(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::block_latex::set_text::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::block_latex::set_text::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/BlockLatexSetText");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BlockLatexSetText",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn process_cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::process::cancel::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::process::cancel::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ProcessCancel");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ProcessCancel"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn process_subscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::process::subscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::process::subscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ProcessSubscribe");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ProcessSubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn process_unsubscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::process::unsubscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::process::unsubscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ProcessUnsubscribe");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ProcessUnsubscribe",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn log_send(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::log::send::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::log::send::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/LogSend");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "LogSend"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_stat(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::stat::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::debug::stat::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugStat");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugStat"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::tree::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::debug::tree::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugTree");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugTree"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_tree_heads(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::tree_heads::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::tree_heads::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugTreeHeads");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugTreeHeads"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_space_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::space_summary::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::space_summary::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugSpaceSummary");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugSpaceSummary",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_stack_goroutines(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::stack_goroutines::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::stack_goroutines::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/DebugStackGoroutines",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugStackGoroutines",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_export_localstore(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::export_localstore::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::export_localstore::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/DebugExportLocalstore",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugExportLocalstore",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_ping(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::ping::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::debug::ping::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugPing");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugPing"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_subscriptions(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::subscriptions::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::subscriptions::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugSubscriptions");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugSubscriptions",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_opened_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::opened_objects::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::opened_objects::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugOpenedObjects");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugOpenedObjects",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_run_profiler(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::run_profiler::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::run_profiler::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugRunProfiler");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugRunProfiler",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_account_select_trace(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::account_select_trace::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::account_select_trace::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/DebugAccountSelectTrace",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugAccountSelectTrace",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_anystore_object_changes(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::anystore_object_changes::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::anystore_object_changes::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/DebugAnystoreObjectChanges",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DebugAnystoreObjectChanges",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_net_check(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::net_check::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::net_check::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugNetCheck");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugNetCheck"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn debug_export_log(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::debug::export_log::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::debug::export_log::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DebugExportLog");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DebugExportLog"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn initial_set_parameters(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::initial::set_parameters::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::initial::set_parameters::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/InitialSetParameters",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "InitialSetParameters",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// used only for lib-server via grpc
        pub async fn listen_session_events(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Event>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ListenSessionEvents");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ListenSessionEvents",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn notification_list(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::notification::list::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::notification::list::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/NotificationList");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NotificationList",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn notification_reply(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::notification::reply::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::notification::reply::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/NotificationReply");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NotificationReply",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn notification_test(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::notification::test::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::notification::test::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/NotificationTest");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NotificationTest",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Membership
        ///
        /// ---
        ///
        /// Get current subscription status (tier, expiration date, etc.)
        /// WARNING: can be cached by Anytype Heart
        pub async fn membership_get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::get_status::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::get_status::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/MembershipGetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipGetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Check if the requested name is valid and vacant for the requested tier
        pub async fn membership_is_name_valid(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::is_name_valid::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::is_name_valid::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipIsNameValid",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipIsNameValid",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Buy a subscription, will return a payment URL. The user should be redirected to this URL to complete the payment.
        pub async fn membership_register_payment_request(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::register_payment_request::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::register_payment_request::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipRegisterPaymentRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipRegisterPaymentRequest",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get a link to the user's subscription management portal. The user should be redirected to this URL to manage their subscription:
        /// a) change his billing details
        /// b) see payment info, invoices, etc
        /// c) cancel the subscription
        pub async fn membership_get_portal_link_url(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::get_portal_link_url::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::get_portal_link_url::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipGetPortalLinkUrl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipGetPortalLinkUrl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Check the current status of the verification email
        pub async fn membership_get_verification_email_status(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::membership::get_verification_email_status::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::get_verification_email_status::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipGetVerificationEmailStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipGetVerificationEmailStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Send a verification code to the user's email. The user should enter this code to verify his email.
        pub async fn membership_get_verification_email(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::get_verification_email::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::get_verification_email::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipGetVerificationEmail",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipGetVerificationEmail",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Verify the user's email with the code received in the previous step (MembershipGetVerificationEmail)
        pub async fn membership_verify_email_code(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::verify_email_code::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::verify_email_code::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipVerifyEmailCode",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipVerifyEmailCode",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// If your subscription is in PendingRequiresFinalization:
        /// please call MembershipFinalize to finish the process
        pub async fn membership_finalize(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::finalize::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::finalize::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/MembershipFinalize");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipFinalize",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_get_tiers(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::get_tiers::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::get_tiers::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/MembershipGetTiers");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipGetTiers",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_verify_app_store_receipt(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::verify_app_store_receipt::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::verify_app_store_receipt::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipVerifyAppStoreReceipt",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipVerifyAppStoreReceipt",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_code_get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::code_get_info::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::code_get_info::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipCodeGetInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipCodeGetInfo",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_code_redeem(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership::code_redeem::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership::code_redeem::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipCodeRedeem",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipCodeRedeem",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// enumerate all available for purchase products
        pub async fn membership_v2_get_products(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::get_products::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::get_products::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2GetProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2GetProducts",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::get_status::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::get_status::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2GetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_get_portal_link(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::get_portal_link::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::get_portal_link::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2GetPortalLink",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2GetPortalLink",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_any_name_is_valid(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::any_name_is_valid::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::any_name_is_valid::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2AnyNameIsValid",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2AnyNameIsValid",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_any_name_allocate(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::any_name_allocate::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::any_name_allocate::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2AnyNameAllocate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2AnyNameAllocate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_cart_get(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::cart_get::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::cart_get::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/MembershipV2CartGet");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2CartGet",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_cart_update(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::cart_update::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::cart_update::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2CartUpdate",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2CartUpdate",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn membership_v2_subscribe_to_updates(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::membership_v2::subscribe_to_updates::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::membership_v2::subscribe_to_updates::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/MembershipV2SubscribeToUpdates",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "MembershipV2SubscribeToUpdates",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Name Service:
        ///
        /// ---
        ///
        /// hello.any -> data
        pub async fn name_service_user_account_get(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::name_service::user_account::get::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::name_service::user_account::get::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/NameServiceUserAccountGet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NameServiceUserAccountGet",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn name_service_resolve_name(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::name_service::resolve_name::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::name_service::resolve_name::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/NameServiceResolveName",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NameServiceResolveName",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// 12D3KooWA8EXV3KjBxEU5EnsPfneLx84vMWAtTBQBeyooN82KSuS -> hello.any
        pub async fn name_service_resolve_any_id(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::name_service::resolve_any_id::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::name_service::resolve_any_id::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/NameServiceResolveAnyId",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "NameServiceResolveAnyId",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn broadcast_payload_event(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::broadcast::payload_event::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::broadcast::payload_event::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/BroadcastPayloadEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "BroadcastPayloadEvent",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn device_set_name(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::device::set_name::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::device::set_name::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DeviceSetName");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DeviceSetName"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn device_list(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::device::list::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::device::list::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/DeviceList");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "DeviceList"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn device_network_state_set(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::device::network_state::set::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::device::network_state::set::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/DeviceNetworkStateSet",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "DeviceNetworkStateSet",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Chats
        pub async fn chat_add_message(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::add_message::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::add_message::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatAddMessage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ChatAddMessage"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_edit_message_content(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::edit_message_content::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::edit_message_content::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatEditMessageContent",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatEditMessageContent",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_toggle_message_reaction(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::toggle_message_reaction::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::toggle_message_reaction::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatToggleMessageReaction",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatToggleMessageReaction",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_delete_message(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::delete_message::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::delete_message::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatDeleteMessage");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatDeleteMessage",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_get_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::get_messages::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::get_messages::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatGetMessages");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ChatGetMessages"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_get_messages_by_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::get_messages_by_ids::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::get_messages_by_ids::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatGetMessagesByIds",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatGetMessagesByIds",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_subscribe_last_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::subscribe_last_messages::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::subscribe_last_messages::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatSubscribeLastMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatSubscribeLastMessages",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_unsubscribe(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::unsubscribe::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::unsubscribe::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatUnsubscribe");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ChatUnsubscribe"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_read_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::read_messages::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::read_messages::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatReadMessages");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatReadMessages",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_unread_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::unread::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::chat::unread::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatUnreadMessages");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatUnreadMessages",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_subscribe_to_message_previews(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::subscribe_to_message_previews::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::subscribe_to_message_previews::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatSubscribeToMessagePreviews",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatSubscribeToMessagePreviews",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_unsubscribe_from_message_previews(
            &mut self,
            request: impl tonic::IntoRequest<
                super::rpc::chat::unsubscribe_from_message_previews::Request,
            >,
        ) -> std::result::Result<
            tonic::Response<super::rpc::chat::unsubscribe_from_message_previews::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/ChatUnsubscribeFromMessagePreviews",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "ChatUnsubscribeFromMessagePreviews",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn object_chat_add(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::object::chat_add::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::object::chat_add::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ObjectChatAdd");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ObjectChatAdd"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_read_all(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::read_all::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::chat::read_all::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatReadAll");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ChatReadAll"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn chat_search(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::chat::search::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::chat::search::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/ChatSearch");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "ChatSearch"));
            self.inner.unary(req, path, codec).await
        }
        /// mock AI RPCs for compatibility between branches. Not implemented in main
        pub async fn ai_writing_tools(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::ai::writing_tools::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::ai::writing_tools::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AIWritingTools");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AIWritingTools"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn ai_autofill(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::ai::autofill::Request>,
        ) -> std::result::Result<tonic::Response<super::rpc::ai::autofill::Response>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AIAutofill");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AIAutofill"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn ai_list_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::ai::list_summary::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::ai::list_summary::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/anytype.ClientCommands/AIListSummary");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("anytype.ClientCommands", "AIListSummary"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn ai_object_create_from_url(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::ai::object_create_from_url::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::ai::object_create_from_url::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/AIObjectCreateFromUrl",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "AIObjectCreateFromUrl",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Push
        pub async fn push_notification_register_token(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::push_notification::register_token::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::push_notification::register_token::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/PushNotificationRegisterToken",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PushNotificationRegisterToken",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn push_notification_set_space_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::push_notification::set_space_mode::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::push_notification::set_space_mode::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/PushNotificationSetSpaceMode",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PushNotificationSetSpaceMode",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn push_notification_set_force_mode_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::push_notification::set_force_mode_ids::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::push_notification::set_force_mode_ids::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/PushNotificationSetForceModeIds",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PushNotificationSetForceModeIds",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn push_notification_reset_ids(
            &mut self,
            request: impl tonic::IntoRequest<super::rpc::push_notification::reset_ids::Request>,
        ) -> std::result::Result<
            tonic::Response<super::rpc::push_notification::reset_ids::Response>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/anytype.ClientCommands/PushNotificationResetIds",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "anytype.ClientCommands",
                "PushNotificationResetIds",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// the element of change tree used to store and internal apply smartBlock history
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Change {
    /// set of actions to apply
    #[prost(message, repeated, tag = "3")]
    pub content: ::prost::alloc::vec::Vec<change::Content>,
    /// snapshot - when not null, the Content will be ignored
    #[prost(message, optional, tag = "4")]
    pub snapshot: ::core::option::Option<change::Snapshot>,
    /// file keys related to changes content
    #[prost(message, repeated, tag = "6")]
    pub file_keys: ::prost::alloc::vec::Vec<change::FileKeys>,
    /// creation timestamp
    #[prost(int64, tag = "7")]
    pub timestamp: i64,
    /// version of business logic
    #[prost(uint32, tag = "8")]
    pub version: u32,
    /// business-level type of change applied to object
    #[prost(uint32, tag = "9")]
    pub change_type: u32,
}
/// Nested message and enum types in `Change`.
pub mod change {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Snapshot {
        /// logId -> lastChangeId
        #[prost(map = "string, string", tag = "1")]
        pub log_heads: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        /// snapshot data
        #[prost(message, optional, tag = "2")]
        pub data: ::core::option::Option<crate::model::SmartBlockSnapshotBase>,
        /// all file keys related to doc
        #[prost(message, repeated, tag = "3")]
        pub file_keys: ::prost::alloc::vec::Vec<FileKeys>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FileKeys {
        #[prost(string, tag = "1")]
        pub hash: ::prost::alloc::string::String,
        #[prost(map = "string, string", tag = "2")]
        pub keys: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Content {
        #[prost(
            oneof = "content::Value",
            tags = "1, 2, 3, 4, 5, 50, 51, 100, 101, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115"
        )]
        pub value: ::core::option::Option<content::Value>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            #[prost(message, tag = "1")]
            BlockCreate(super::BlockCreate),
            #[prost(message, tag = "2")]
            BlockUpdate(super::BlockUpdate),
            #[prost(message, tag = "3")]
            BlockRemove(super::BlockRemove),
            #[prost(message, tag = "4")]
            BlockMove(super::BlockMove),
            #[prost(message, tag = "5")]
            BlockDuplicate(super::BlockDuplicate),
            #[prost(message, tag = "50")]
            RelationAdd(super::RelationAdd),
            #[prost(message, tag = "51")]
            RelationRemove(super::RelationRemove),
            #[prost(message, tag = "100")]
            DetailsSet(super::DetailsSet),
            #[prost(message, tag = "101")]
            DetailsUnset(super::DetailsUnset),
            #[prost(message, tag = "105")]
            ObjectTypeAdd(super::ObjectTypeAdd),
            #[prost(message, tag = "106")]
            ObjectTypeRemove(super::ObjectTypeRemove),
            #[prost(message, tag = "107")]
            StoreKeySet(super::StoreKeySet),
            #[prost(message, tag = "108")]
            StoreKeyUnset(super::StoreKeyUnset),
            #[prost(message, tag = "109")]
            StoreSliceUpdate(super::StoreSliceUpdate),
            #[prost(message, tag = "110")]
            OriginalCreatedTimestampSet(super::OriginalCreatedTimestampSet),
            #[prost(message, tag = "111")]
            SetFileInfo(super::SetFileInfo),
            #[prost(message, tag = "112")]
            NotificationCreate(super::NotificationCreate),
            #[prost(message, tag = "113")]
            NotificationUpdate(super::NotificationUpdate),
            #[prost(message, tag = "114")]
            DeviceAdd(super::DeviceAdd),
            #[prost(message, tag = "115")]
            DeviceUpdate(super::DeviceUpdate),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockCreate {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(enumeration = "crate::model::block::Position", tag = "2")]
        pub position: i32,
        #[prost(message, repeated, tag = "3")]
        pub blocks: ::prost::alloc::vec::Vec<crate::model::Block>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BlockUpdate {
        #[prost(message, repeated, tag = "2")]
        pub events: ::prost::alloc::vec::Vec<super::event::Message>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockRemove {
        #[prost(string, repeated, tag = "1")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockMove {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(enumeration = "crate::model::block::Position", tag = "2")]
        pub position: i32,
        #[prost(string, repeated, tag = "3")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockDuplicate {
        #[prost(string, tag = "1")]
        pub target_id: ::prost::alloc::string::String,
        #[prost(enumeration = "crate::model::block::Position", tag = "2")]
        pub position: i32,
        #[prost(string, repeated, tag = "3")]
        pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetailsSet {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<::prost_types::Value>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DetailsUnset {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RelationAdd {
        #[prost(message, repeated, tag = "1")]
        pub relation_links: ::prost::alloc::vec::Vec<crate::model::RelationLink>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RelationRemove {
        #[prost(string, repeated, tag = "1")]
        pub relation_key: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ObjectTypeAdd {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ObjectTypeRemove {
        #[prost(string, tag = "1")]
        pub url: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StoreKeySet {
        #[prost(string, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<::prost_types::Value>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StoreKeyUnset {
        #[prost(string, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StoreSliceUpdate {
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        #[prost(oneof = "store_slice_update::Operation", tags = "2, 3, 4")]
        pub operation: ::core::option::Option<store_slice_update::Operation>,
    }
    /// Nested message and enum types in `StoreSliceUpdate`.
    pub mod store_slice_update {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Add {
            #[prost(string, tag = "1")]
            pub after_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Remove {
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Move {
            #[prost(string, tag = "1")]
            pub after_id: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Operation {
            #[prost(message, tag = "2")]
            Add(Add),
            #[prost(message, tag = "3")]
            Remove(Remove),
            #[prost(message, tag = "4")]
            Move(Move),
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct OriginalCreatedTimestampSet {
        #[prost(int64, tag = "1")]
        pub ts: i64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetFileInfo {
        #[prost(message, optional, tag = "1")]
        pub file_info: ::core::option::Option<crate::model::FileInfo>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NotificationCreate {
        #[prost(message, optional, tag = "1")]
        pub notification: ::core::option::Option<crate::model::Notification>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NotificationUpdate {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(enumeration = "crate::model::notification::Status", tag = "2")]
        pub status: i32,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeviceAdd {
        #[prost(message, optional, tag = "1")]
        pub device: ::core::option::Option<crate::model::DeviceInfo>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DeviceUpdate {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeNoSnapshot {
    /// set of actions to apply
    #[prost(message, repeated, tag = "3")]
    pub content: ::prost::alloc::vec::Vec<change::Content>,
    /// file keys related to changes content
    #[prost(message, repeated, tag = "6")]
    pub file_keys: ::prost::alloc::vec::Vec<change::FileKeys>,
    /// creation timestamp
    #[prost(int64, tag = "7")]
    pub timestamp: i64,
    /// version of business logic
    #[prost(uint32, tag = "8")]
    pub version: u32,
    /// business-level type of change applied to object
    #[prost(uint32, tag = "9")]
    pub change_type: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreChange {
    #[prost(message, repeated, tag = "1")]
    pub change_set: ::prost::alloc::vec::Vec<StoreChangeContent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoreChangeContent {
    #[prost(oneof = "store_change_content::Change", tags = "1, 2, 3")]
    pub change: ::core::option::Option<store_change_content::Change>,
}
/// Nested message and enum types in `StoreChangeContent`.
pub mod store_change_content {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Change {
        #[prost(message, tag = "1")]
        Create(super::DocumentCreate),
        #[prost(message, tag = "2")]
        Modify(super::DocumentModify),
        #[prost(message, tag = "3")]
        Delete(super::DocumentDelete),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DocumentCreate {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    /// json
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentModify {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub keys: ::prost::alloc::vec::Vec<KeyModify>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct KeyModify {
    /// key path; example: \[user, email\]
    #[prost(string, repeated, tag = "1")]
    pub key_path: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// modify op: set, unset, inc, etc.
    #[prost(enumeration = "ModifyOp", tag = "3")]
    pub modify_op: i32,
    /// json value; example: '"new@email.com"'
    #[prost(string, tag = "4")]
    pub modify_value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DocumentDelete {
    #[prost(string, tag = "1")]
    pub collection: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ModifyOp {
    Set = 0,
    Unset = 1,
    Inc = 2,
    AddToSet = 3,
    Pull = 4,
}
impl ModifyOp {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Set => "Set",
            Self::Unset => "Unset",
            Self::Inc => "Inc",
            Self::AddToSet => "AddToSet",
            Self::Pull => "Pull",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Set" => Some(Self::Set),
            "Unset" => Some(Self::Unset),
            "Inc" => Some(Self::Inc),
            "AddToSet" => Some(Self::AddToSet),
            "Pull" => Some(Self::Pull),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotWithType {
    #[prost(enumeration = "crate::model::SmartBlockType", tag = "1")]
    pub sb_type: i32,
    #[prost(message, optional, tag = "2")]
    pub snapshot: ::core::option::Option<change::Snapshot>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Profile {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub avatar: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub space_dashboard_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub profile_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub analytics_id: ::prost::alloc::string::String,
    /// deprecated
    #[prost(string, tag = "8")]
    pub starting_page: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub widgets: ::prost::alloc::vec::Vec<WidgetBlock>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WidgetBlock {
    #[prost(
        enumeration = "crate::model::block::content::widget::Layout",
        tag = "1"
    )]
    pub layout: i32,
    #[prost(string, tag = "2")]
    pub target_object_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub object_limit: i32,
}
