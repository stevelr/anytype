// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmartBlockSnapshotBase {
    #[prost(message, repeated, tag = "1")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<::prost_types::Struct>,
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub file_keys: ::core::option::Option<::prost_types::Struct>,
    #[deprecated]
    #[prost(message, repeated, tag = "4")]
    pub extra_relations: ::prost::alloc::vec::Vec<Relation>,
    #[prost(string, repeated, tag = "5")]
    pub object_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub collections: ::core::option::Option<::prost_types::Struct>,
    #[prost(string, repeated, tag = "8")]
    pub removed_collection_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "7")]
    pub relation_links: ::prost::alloc::vec::Vec<RelationLink>,
    /// only used for pb backup purposes, ignored in other cases
    #[prost(string, tag = "9")]
    pub key: ::prost::alloc::string::String,
    /// ignored in import/export in favor of createdDate relation. Used to store original user-side object creation timestamp
    #[prost(int64, tag = "10")]
    pub original_created_timestamp: i64,
    #[prost(message, optional, tag = "11")]
    pub file_info: ::core::option::Option<FileInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Search {}
/// Nested message and enum types in `Search`.
pub mod search {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Result {
        #[prost(string, tag = "1")]
        pub object_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub details: ::core::option::Option<::prost_types::Struct>,
        /// meta information about the search result
        #[prost(message, repeated, tag = "3")]
        pub meta: ::prost::alloc::vec::Vec<Meta>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Meta {
        /// truncated text with highlights
        #[prost(string, tag = "1")]
        pub highlight: ::prost::alloc::string::String,
        /// ranges of the highlight in the text (using utf-16 runes)
        #[prost(message, repeated, tag = "2")]
        pub highlight_ranges: ::prost::alloc::vec::Vec<super::Range>,
        /// block id where the highlight has been found
        #[prost(string, tag = "3")]
        pub block_id: ::prost::alloc::string::String,
        /// relation key of the block where the highlight has been found
        #[prost(string, tag = "4")]
        pub relation_key: ::prost::alloc::string::String,
        /// contains details for dependent object. E.g. relation option or type. todo: rename to dependantDetails
        #[prost(message, optional, tag = "5")]
        pub relation_details: ::core::option::Option<::prost_types::Struct>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Message {}
    /// Nested message and enum types in `Message`.
    pub mod message {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Sort {
            #[prost(enumeration = "sort::Key", tag = "1")]
            pub key: i32,
            #[prost(enumeration = "sort::Type", tag = "2")]
            pub r#type: i32,
        }
        /// Nested message and enum types in `Sort`.
        pub mod sort {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Key {
                OrderId = 0,
                Score = 1,
                CreatedAt = 2,
                ModifiedAt = 3,
            }
            impl Key {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::OrderId => "ORDER_ID",
                        Self::Score => "SCORE",
                        Self::CreatedAt => "CREATED_AT",
                        Self::ModifiedAt => "MODIFIED_AT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "ORDER_ID" => Some(Self::OrderId),
                        "SCORE" => Some(Self::Score),
                        "CREATED_AT" => Some(Self::CreatedAt),
                        "MODIFIED_AT" => Some(Self::ModifiedAt),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Type {
                Asc = 0,
                Desc = 1,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Asc => "Asc",
                        Self::Desc => "Desc",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Asc" => Some(Self::Asc),
                        "Desc" => Some(Self::Desc),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Result {
            #[prost(string, tag = "1")]
            pub chat_id: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub message_id: ::prost::alloc::string::String,
            #[prost(int64, tag = "3")]
            pub score: i64,
            /// truncated text with highlights
            #[prost(string, tag = "4")]
            pub highlight: ::prost::alloc::string::String,
            /// ranges of the highlight in the text (using utf-16 runes)
            #[prost(message, repeated, tag = "5")]
            pub highlight_ranges: ::prost::alloc::vec::Vec<super::super::Range>,
            #[prost(message, optional, tag = "6")]
            pub message: ::core::option::Option<super::super::ChatMessage>,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub fields: ::core::option::Option<::prost_types::Struct>,
    #[prost(message, optional, tag = "3")]
    pub restrictions: ::core::option::Option<block::Restrictions>,
    #[prost(string, repeated, tag = "4")]
    pub children_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub background_color: ::prost::alloc::string::String,
    #[prost(enumeration = "block::Align", tag = "6")]
    pub align: i32,
    #[prost(enumeration = "block::VerticalAlign", tag = "7")]
    pub vertical_align: i32,
    #[prost(
        oneof = "block::ContentValue",
        tags = "11, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30"
    )]
    pub content_value: ::core::option::Option<block::ContentValue>,
}
/// Nested message and enum types in `Block`.
pub mod block {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Restrictions {
        #[prost(bool, tag = "1")]
        pub read: bool,
        #[prost(bool, tag = "2")]
        pub edit: bool,
        #[prost(bool, tag = "3")]
        pub remove: bool,
        #[prost(bool, tag = "4")]
        pub drag: bool,
        #[prost(bool, tag = "5")]
        pub drop_on: bool,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Content {}
    /// Nested message and enum types in `Content`.
    pub mod content {
        /// Layout have no visual representation, but affects on blocks, that it contains.
        /// Row/Column layout blocks creates only automatically, after some of a D&D operations, for example
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Layout {
            #[prost(enumeration = "layout::Style", tag = "1")]
            pub style: i32,
        }
        /// Nested message and enum types in `Layout`.
        pub mod layout {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Style {
                Row = 0,
                Column = 1,
                Div = 2,
                Header = 3,
                TableRows = 4,
                TableColumns = 5,
            }
            impl Style {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Row => "Row",
                        Self::Column => "Column",
                        Self::Div => "Div",
                        Self::Header => "Header",
                        Self::TableRows => "TableRows",
                        Self::TableColumns => "TableColumns",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Row" => Some(Self::Row),
                        "Column" => Some(Self::Column),
                        "Div" => Some(Self::Div),
                        "Header" => Some(Self::Header),
                        "TableRows" => Some(Self::TableRows),
                        "TableColumns" => Some(Self::TableColumns),
                        _ => None,
                    }
                }
            }
        }
        /// Link: block to link some content from an external sources.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Link {
            /// id of the target block
            #[prost(string, tag = "1")]
            pub target_block_id: ::prost::alloc::string::String,
            /// deprecated
            #[prost(enumeration = "link::Style", tag = "2")]
            pub style: i32,
            #[prost(message, optional, tag = "3")]
            pub fields: ::core::option::Option<::prost_types::Struct>,
            #[prost(enumeration = "link::IconSize", tag = "4")]
            pub icon_size: i32,
            #[prost(enumeration = "link::CardStyle", tag = "5")]
            pub card_style: i32,
            #[prost(enumeration = "link::Description", tag = "6")]
            pub description: i32,
            #[prost(string, repeated, tag = "7")]
            pub relations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        /// Nested message and enum types in `Link`.
        pub mod link {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum IconSize {
                SizeNone = 0,
                SizeSmall = 1,
                SizeMedium = 2,
            }
            impl IconSize {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::SizeNone => "SizeNone",
                        Self::SizeSmall => "SizeSmall",
                        Self::SizeMedium => "SizeMedium",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "SizeNone" => Some(Self::SizeNone),
                        "SizeSmall" => Some(Self::SizeSmall),
                        "SizeMedium" => Some(Self::SizeMedium),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Style {
                Page = 0,
                Dataview = 1,
                Dashboard = 2,
                /// ...
                Archive = 3,
            }
            impl Style {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Page => "Page",
                        Self::Dataview => "Dataview",
                        Self::Dashboard => "Dashboard",
                        Self::Archive => "Archive",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Page" => Some(Self::Page),
                        "Dataview" => Some(Self::Dataview),
                        "Dashboard" => Some(Self::Dashboard),
                        "Archive" => Some(Self::Archive),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Description {
                None = 0,
                Added = 1,
                Content = 2,
            }
            impl Description {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "None",
                        Self::Added => "Added",
                        Self::Content => "Content",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "None" => Some(Self::None),
                        "Added" => Some(Self::Added),
                        "Content" => Some(Self::Content),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum CardStyle {
                Text = 0,
                Card = 1,
                Inline = 2,
            }
            impl CardStyle {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Text => "Text",
                        Self::Card => "Card",
                        Self::Inline => "Inline",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Text" => Some(Self::Text),
                        "Card" => Some(Self::Card),
                        "Inline" => Some(Self::Inline),
                        _ => None,
                    }
                }
            }
        }
        /// Divider: block, that contains only one horizontal thin line
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Div {
            #[prost(enumeration = "div::Style", tag = "1")]
            pub style: i32,
        }
        /// Nested message and enum types in `Div`.
        pub mod div {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Style {
                Line = 0,
                Dots = 1,
            }
            impl Style {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Line => "Line",
                        Self::Dots => "Dots",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Line" => Some(Self::Line),
                        "Dots" => Some(Self::Dots),
                        _ => None,
                    }
                }
            }
        }
        /// Bookmark is to keep a web-link and to preview a content.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Bookmark {
            #[prost(string, tag = "1")]
            pub url: ::prost::alloc::string::String,
            /// Deprecated. Get this data from the target object.
            #[prost(string, tag = "2")]
            pub title: ::prost::alloc::string::String,
            /// Deprecated. Get this data from the target object.
            #[prost(string, tag = "3")]
            pub description: ::prost::alloc::string::String,
            /// Deprecated. Get this data from the target object.
            #[prost(string, tag = "4")]
            pub image_hash: ::prost::alloc::string::String,
            /// Deprecated. Get this data from the target object.
            #[prost(string, tag = "5")]
            pub favicon_hash: ::prost::alloc::string::String,
            #[prost(enumeration = "super::super::link_preview::Type", tag = "6")]
            pub r#type: i32,
            #[prost(string, tag = "7")]
            pub target_object_id: ::prost::alloc::string::String,
            #[prost(enumeration = "bookmark::State", tag = "8")]
            pub state: i32,
        }
        /// Nested message and enum types in `Bookmark`.
        pub mod bookmark {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum State {
                Empty = 0,
                Fetching = 1,
                Done = 2,
                Error = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Empty => "Empty",
                        Self::Fetching => "Fetching",
                        Self::Done => "Done",
                        Self::Error => "Error",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Empty" => Some(Self::Empty),
                        "Fetching" => Some(Self::Fetching),
                        "Done" => Some(Self::Done),
                        "Error" => Some(Self::Error),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Icon {
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct FeaturedRelations {}
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Text {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(enumeration = "text::Style", tag = "2")]
            pub style: i32,
            /// list of marks to apply to the text
            #[prost(message, optional, tag = "3")]
            pub marks: ::core::option::Option<text::Marks>,
            #[prost(bool, tag = "4")]
            pub checked: bool,
            #[prost(string, tag = "5")]
            pub color: ::prost::alloc::string::String,
            /// used with style Callout
            #[prost(string, tag = "6")]
            pub icon_emoji: ::prost::alloc::string::String,
            /// in case both image and emoji are set, image should has a priority in the UI
            #[prost(string, tag = "7")]
            pub icon_image: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `Text`.
        pub mod text {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Marks {
                #[prost(message, repeated, tag = "1")]
                pub marks: ::prost::alloc::vec::Vec<Mark>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Mark {
                /// range of symbols to apply this mark. From(symbol) To(symbol)
                #[prost(message, optional, tag = "1")]
                pub range: ::core::option::Option<super::super::super::Range>,
                #[prost(enumeration = "mark::Type", tag = "2")]
                pub r#type: i32,
                /// link, color, etc
                #[prost(string, tag = "3")]
                pub param: ::prost::alloc::string::String,
            }
            /// Nested message and enum types in `Mark`.
            pub mod mark {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Type {
                    Strikethrough = 0,
                    Keyboard = 1,
                    Italic = 2,
                    Bold = 3,
                    Underscored = 4,
                    Link = 5,
                    TextColor = 6,
                    BackgroundColor = 7,
                    Mention = 8,
                    Emoji = 9,
                    Object = 10,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Strikethrough => "Strikethrough",
                            Self::Keyboard => "Keyboard",
                            Self::Italic => "Italic",
                            Self::Bold => "Bold",
                            Self::Underscored => "Underscored",
                            Self::Link => "Link",
                            Self::TextColor => "TextColor",
                            Self::BackgroundColor => "BackgroundColor",
                            Self::Mention => "Mention",
                            Self::Emoji => "Emoji",
                            Self::Object => "Object",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Strikethrough" => Some(Self::Strikethrough),
                            "Keyboard" => Some(Self::Keyboard),
                            "Italic" => Some(Self::Italic),
                            "Bold" => Some(Self::Bold),
                            "Underscored" => Some(Self::Underscored),
                            "Link" => Some(Self::Link),
                            "TextColor" => Some(Self::TextColor),
                            "BackgroundColor" => Some(Self::BackgroundColor),
                            "Mention" => Some(Self::Mention),
                            "Emoji" => Some(Self::Emoji),
                            "Object" => Some(Self::Object),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Style {
                Paragraph = 0,
                Header1 = 1,
                Header2 = 2,
                Header3 = 3,
                /// deprecated
                Header4 = 4,
                Quote = 5,
                Code = 6,
                /// currently only one block of this style can exists on a page
                Title = 7,
                Checkbox = 8,
                Marked = 9,
                Numbered = 10,
                Toggle = 11,
                /// currently only one block of this style can exists on a page
                Description = 12,
                Callout = 13,
                ToggleHeader1 = 14,
                ToggleHeader2 = 15,
                ToggleHeader3 = 16,
            }
            impl Style {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Paragraph => "Paragraph",
                        Self::Header1 => "Header1",
                        Self::Header2 => "Header2",
                        Self::Header3 => "Header3",
                        Self::Header4 => "Header4",
                        Self::Quote => "Quote",
                        Self::Code => "Code",
                        Self::Title => "Title",
                        Self::Checkbox => "Checkbox",
                        Self::Marked => "Marked",
                        Self::Numbered => "Numbered",
                        Self::Toggle => "Toggle",
                        Self::Description => "Description",
                        Self::Callout => "Callout",
                        Self::ToggleHeader1 => "ToggleHeader1",
                        Self::ToggleHeader2 => "ToggleHeader2",
                        Self::ToggleHeader3 => "ToggleHeader3",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Paragraph" => Some(Self::Paragraph),
                        "Header1" => Some(Self::Header1),
                        "Header2" => Some(Self::Header2),
                        "Header3" => Some(Self::Header3),
                        "Header4" => Some(Self::Header4),
                        "Quote" => Some(Self::Quote),
                        "Code" => Some(Self::Code),
                        "Title" => Some(Self::Title),
                        "Checkbox" => Some(Self::Checkbox),
                        "Marked" => Some(Self::Marked),
                        "Numbered" => Some(Self::Numbered),
                        "Toggle" => Some(Self::Toggle),
                        "Description" => Some(Self::Description),
                        "Callout" => Some(Self::Callout),
                        "ToggleHeader1" => Some(Self::ToggleHeader1),
                        "ToggleHeader2" => Some(Self::ToggleHeader2),
                        "ToggleHeader3" => Some(Self::ToggleHeader3),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct File {
            #[prost(string, tag = "1")]
            pub hash: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub name: ::prost::alloc::string::String,
            #[prost(enumeration = "file::Type", tag = "3")]
            pub r#type: i32,
            #[prost(string, tag = "4")]
            pub mime: ::prost::alloc::string::String,
            #[prost(int64, tag = "5")]
            pub size: i64,
            #[prost(int64, tag = "6")]
            pub added_at: i64,
            #[prost(string, tag = "9")]
            pub target_object_id: ::prost::alloc::string::String,
            #[prost(enumeration = "file::State", tag = "7")]
            pub state: i32,
            #[prost(enumeration = "file::Style", tag = "8")]
            pub style: i32,
        }
        /// Nested message and enum types in `File`.
        pub mod file {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Type {
                None = 0,
                File = 1,
                Image = 2,
                Video = 3,
                Audio = 4,
                Pdf = 5,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::None => "None",
                        Self::File => "File",
                        Self::Image => "Image",
                        Self::Video => "Video",
                        Self::Audio => "Audio",
                        Self::Pdf => "PDF",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "None" => Some(Self::None),
                        "File" => Some(Self::File),
                        "Image" => Some(Self::Image),
                        "Video" => Some(Self::Video),
                        "Audio" => Some(Self::Audio),
                        "PDF" => Some(Self::Pdf),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Style {
                /// all types expect File and None has Embed style by default
                Auto = 0,
                Link = 1,
                Embed = 2,
            }
            impl Style {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Auto => "Auto",
                        Self::Link => "Link",
                        Self::Embed => "Embed",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Auto" => Some(Self::Auto),
                        "Link" => Some(Self::Link),
                        "Embed" => Some(Self::Embed),
                        _ => None,
                    }
                }
            }
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum State {
                /// There is no file and preview, it's an empty block, that waits files.
                Empty = 0,
                /// There is still no file/preview, but file already uploading
                Uploading = 1,
                /// File and preview downloaded
                Done = 2,
                /// Error while uploading
                Error = 3,
            }
            impl State {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Empty => "Empty",
                        Self::Uploading => "Uploading",
                        Self::Done => "Done",
                        Self::Error => "Error",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Empty" => Some(Self::Empty),
                        "Uploading" => Some(Self::Uploading),
                        "Done" => Some(Self::Done),
                        "Error" => Some(Self::Error),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Smartblock {}
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Dataview {
            /// can be set for detached(without TargetObjectId) inline sets
            #[prost(string, repeated, tag = "1")]
            pub source: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(message, repeated, tag = "2")]
            pub views: ::prost::alloc::vec::Vec<dataview::View>,
            /// do not generate changes for this field
            #[prost(string, tag = "3")]
            pub active_view: ::prost::alloc::string::String,
            /// deprecated
            #[prost(message, repeated, tag = "4")]
            pub relations: ::prost::alloc::vec::Vec<super::super::Relation>,
            #[prost(message, repeated, tag = "12")]
            pub group_orders: ::prost::alloc::vec::Vec<dataview::GroupOrder>,
            #[prost(message, repeated, tag = "13")]
            pub object_orders: ::prost::alloc::vec::Vec<dataview::ObjectOrder>,
            #[prost(message, repeated, tag = "5")]
            pub relation_links: ::prost::alloc::vec::Vec<super::super::RelationLink>,
            /// empty for original set/collection objects and for detached inline sets
            #[prost(string, tag = "6")]
            pub target_object_id: ::prost::alloc::string::String,
            #[prost(bool, tag = "14")]
            pub is_collection: bool,
        }
        /// Nested message and enum types in `Dataview`.
        pub mod dataview {
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct View {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "view::Type", tag = "2")]
                pub r#type: i32,
                #[prost(string, tag = "3")]
                pub name: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "4")]
                pub sorts: ::prost::alloc::vec::Vec<Sort>,
                #[prost(message, repeated, tag = "5")]
                pub filters: ::prost::alloc::vec::Vec<Filter>,
                /// relations fields/columns options, also used to provide the order
                #[prost(message, repeated, tag = "6")]
                pub relations: ::prost::alloc::vec::Vec<Relation>,
                /// Relation used for cover in gallery
                #[prost(string, tag = "7")]
                pub cover_relation_key: ::prost::alloc::string::String,
                /// Hide icon near name
                #[prost(bool, tag = "8")]
                pub hide_icon: bool,
                /// Gallery card size
                #[prost(enumeration = "view::Size", tag = "9")]
                pub card_size: i32,
                /// Image fits container
                #[prost(bool, tag = "10")]
                pub cover_fit: bool,
                /// Group view by this relationKey
                #[prost(string, tag = "11")]
                pub group_relation_key: ::prost::alloc::string::String,
                /// Enable backgrounds in groups
                #[prost(bool, tag = "12")]
                pub group_background_colors: bool,
                /// Limit of objects shown in widget
                #[prost(int32, tag = "13")]
                pub page_limit: i32,
                /// Default template that is chosen for new object created within the view
                #[prost(string, tag = "14")]
                pub default_template_id: ::prost::alloc::string::String,
                /// Default object type that is chosen for new object created within the view
                #[prost(string, tag = "15")]
                pub default_object_type_id: ::prost::alloc::string::String,
                /// Group view by this relationKey
                #[prost(string, tag = "16")]
                pub end_relation_key: ::prost::alloc::string::String,
                /// Wrap content in view
                #[prost(bool, tag = "17")]
                pub wrap_content: bool,
                /// List view size setting
                #[prost(enumeration = "view::ListSize", tag = "18")]
                pub list_size: i32,
            }
            /// Nested message and enum types in `View`.
            pub mod view {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Type {
                    Table = 0,
                    List = 1,
                    Gallery = 2,
                    Kanban = 3,
                    Calendar = 4,
                    Graph = 5,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Table => "Table",
                            Self::List => "List",
                            Self::Gallery => "Gallery",
                            Self::Kanban => "Kanban",
                            Self::Calendar => "Calendar",
                            Self::Graph => "Graph",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Table" => Some(Self::Table),
                            "List" => Some(Self::List),
                            "Gallery" => Some(Self::Gallery),
                            "Kanban" => Some(Self::Kanban),
                            "Calendar" => Some(Self::Calendar),
                            "Graph" => Some(Self::Graph),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Size {
                    Small = 0,
                    Medium = 1,
                    Large = 2,
                }
                impl Size {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Small => "Small",
                            Self::Medium => "Medium",
                            Self::Large => "Large",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Small" => Some(Self::Small),
                            "Medium" => Some(Self::Medium),
                            "Large" => Some(Self::Large),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum ListSize {
                    /// Single-line display (default)
                    Compact = 0,
                    /// Two-line display with description
                    Regular = 1,
                }
                impl ListSize {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Compact => "Compact",
                            Self::Regular => "Regular",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Compact" => Some(Self::Compact),
                            "Regular" => Some(Self::Regular),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Relation {
                #[prost(string, tag = "1")]
                pub key: ::prost::alloc::string::String,
                #[prost(bool, tag = "2")]
                pub is_visible: bool,
                /// the displayed column % calculated based on other visible relations
                #[prost(int32, tag = "3")]
                pub width: i32,
                /// bool isReadOnly = 4; // deprecated
                ///
                /// deprecated
                #[prost(bool, tag = "5")]
                pub date_include_time: bool,
                /// deprecated
                #[prost(enumeration = "relation::TimeFormat", tag = "6")]
                pub time_format: i32,
                /// deprecated
                #[prost(enumeration = "relation::DateFormat", tag = "7")]
                pub date_format: i32,
                #[prost(enumeration = "relation::FormulaType", tag = "8")]
                pub formula: i32,
                #[prost(enumeration = "super::super::Align", tag = "9")]
                pub align: i32,
            }
            /// Nested message and enum types in `Relation`.
            pub mod relation {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum DateFormat {
                    /// Jul 30, 2020
                    MonthAbbrBeforeDay = 0,
                    /// 30 Jul 2020
                    MonthAbbrAfterDay = 1,
                    /// 30/07/2020
                    Short = 2,
                    /// 07/30/2020
                    ShortUs = 3,
                    /// 2020-07-30
                    Iso = 4,
                }
                impl DateFormat {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::MonthAbbrBeforeDay => "MonthAbbrBeforeDay",
                            Self::MonthAbbrAfterDay => "MonthAbbrAfterDay",
                            Self::Short => "Short",
                            Self::ShortUs => "ShortUS",
                            Self::Iso => "ISO",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "MonthAbbrBeforeDay" => Some(Self::MonthAbbrBeforeDay),
                            "MonthAbbrAfterDay" => Some(Self::MonthAbbrAfterDay),
                            "Short" => Some(Self::Short),
                            "ShortUS" => Some(Self::ShortUs),
                            "ISO" => Some(Self::Iso),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum TimeFormat {
                    Format12 = 0,
                    Format24 = 1,
                }
                impl TimeFormat {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Format12 => "Format12",
                            Self::Format24 => "Format24",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Format12" => Some(Self::Format12),
                            "Format24" => Some(Self::Format24),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum FormulaType {
                    None = 0,
                    Count = 1,
                    CountValue = 2,
                    CountDistinct = 3,
                    CountEmpty = 4,
                    CountNotEmpty = 5,
                    PercentEmpty = 6,
                    PercentNotEmpty = 7,
                    MathSum = 8,
                    MathAverage = 9,
                    MathMedian = 10,
                    MathMin = 11,
                    MathMax = 12,
                    Range = 13,
                }
                impl FormulaType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::None => "None",
                            Self::Count => "Count",
                            Self::CountValue => "CountValue",
                            Self::CountDistinct => "CountDistinct",
                            Self::CountEmpty => "CountEmpty",
                            Self::CountNotEmpty => "CountNotEmpty",
                            Self::PercentEmpty => "PercentEmpty",
                            Self::PercentNotEmpty => "PercentNotEmpty",
                            Self::MathSum => "MathSum",
                            Self::MathAverage => "MathAverage",
                            Self::MathMedian => "MathMedian",
                            Self::MathMin => "MathMin",
                            Self::MathMax => "MathMax",
                            Self::Range => "Range",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "None" => Some(Self::None),
                            "Count" => Some(Self::Count),
                            "CountValue" => Some(Self::CountValue),
                            "CountDistinct" => Some(Self::CountDistinct),
                            "CountEmpty" => Some(Self::CountEmpty),
                            "CountNotEmpty" => Some(Self::CountNotEmpty),
                            "PercentEmpty" => Some(Self::PercentEmpty),
                            "PercentNotEmpty" => Some(Self::PercentNotEmpty),
                            "MathSum" => Some(Self::MathSum),
                            "MathAverage" => Some(Self::MathAverage),
                            "MathMedian" => Some(Self::MathMedian),
                            "MathMin" => Some(Self::MathMin),
                            "MathMax" => Some(Self::MathMax),
                            "Range" => Some(Self::Range),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Sort {
                #[prost(string, tag = "1")]
                pub relation_key: ::prost::alloc::string::String,
                #[prost(enumeration = "sort::Type", tag = "2")]
                pub r#type: i32,
                #[prost(message, repeated, tag = "3")]
                pub custom_order: ::prost::alloc::vec::Vec<::prost_types::Value>,
                #[prost(enumeration = "super::super::super::RelationFormat", tag = "4")]
                pub format: i32,
                #[prost(bool, tag = "5")]
                pub include_time: bool,
                #[prost(string, tag = "6")]
                pub id: ::prost::alloc::string::String,
                #[prost(enumeration = "sort::EmptyType", tag = "7")]
                pub empty_placement: i32,
                #[prost(bool, tag = "8")]
                pub no_collate: bool,
            }
            /// Nested message and enum types in `Sort`.
            pub mod sort {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Type {
                    Asc = 0,
                    Desc = 1,
                    Custom = 2,
                }
                impl Type {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Asc => "Asc",
                            Self::Desc => "Desc",
                            Self::Custom => "Custom",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "Asc" => Some(Self::Asc),
                            "Desc" => Some(Self::Desc),
                            "Custom" => Some(Self::Custom),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum EmptyType {
                    NotSpecified = 0,
                    Start = 1,
                    End = 2,
                }
                impl EmptyType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::NotSpecified => "NotSpecified",
                            Self::Start => "Start",
                            Self::End => "End",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "NotSpecified" => Some(Self::NotSpecified),
                            "Start" => Some(Self::Start),
                            "End" => Some(Self::End),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Filter {
                #[prost(string, tag = "9")]
                pub id: ::prost::alloc::string::String,
                /// looks not applicable?
                #[prost(enumeration = "filter::Operator", tag = "1")]
                pub operator: i32,
                #[prost(string, tag = "2")]
                pub relation_key: ::prost::alloc::string::String,
                #[prost(string, tag = "5")]
                pub relation_property: ::prost::alloc::string::String,
                #[prost(enumeration = "filter::Condition", tag = "3")]
                pub condition: i32,
                #[prost(message, optional, tag = "4")]
                pub value: ::core::option::Option<::prost_types::Value>,
                #[prost(enumeration = "filter::QuickOption", tag = "6")]
                pub quick_option: i32,
                #[prost(enumeration = "super::super::super::RelationFormat", tag = "7")]
                pub format: i32,
                #[prost(bool, tag = "8")]
                pub include_time: bool,
                #[prost(message, repeated, tag = "10")]
                pub nested_filters: ::prost::alloc::vec::Vec<Filter>,
            }
            /// Nested message and enum types in `Filter`.
            pub mod filter {
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Operator {
                    No = 0,
                    Or = 1,
                    And = 2,
                }
                impl Operator {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::No => "No",
                            Self::Or => "Or",
                            Self::And => "And",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "No" => Some(Self::No),
                            "Or" => Some(Self::Or),
                            "And" => Some(Self::And),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum Condition {
                    None = 0,
                    Equal = 1,
                    NotEqual = 2,
                    Greater = 3,
                    Less = 4,
                    GreaterOrEqual = 5,
                    LessOrEqual = 6,
                    Like = 7,
                    NotLike = 8,
                    /// "at least one value(from the provided list) is IN"
                    In = 9,
                    /// "none of provided values are IN"
                    NotIn = 10,
                    Empty = 11,
                    NotEmpty = 12,
                    AllIn = 13,
                    NotAllIn = 14,
                    ExactIn = 15,
                    NotExactIn = 16,
                    Exists = 17,
                }
                impl Condition {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::None => "None",
                            Self::Equal => "Equal",
                            Self::NotEqual => "NotEqual",
                            Self::Greater => "Greater",
                            Self::Less => "Less",
                            Self::GreaterOrEqual => "GreaterOrEqual",
                            Self::LessOrEqual => "LessOrEqual",
                            Self::Like => "Like",
                            Self::NotLike => "NotLike",
                            Self::In => "In",
                            Self::NotIn => "NotIn",
                            Self::Empty => "Empty",
                            Self::NotEmpty => "NotEmpty",
                            Self::AllIn => "AllIn",
                            Self::NotAllIn => "NotAllIn",
                            Self::ExactIn => "ExactIn",
                            Self::NotExactIn => "NotExactIn",
                            Self::Exists => "Exists",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "None" => Some(Self::None),
                            "Equal" => Some(Self::Equal),
                            "NotEqual" => Some(Self::NotEqual),
                            "Greater" => Some(Self::Greater),
                            "Less" => Some(Self::Less),
                            "GreaterOrEqual" => Some(Self::GreaterOrEqual),
                            "LessOrEqual" => Some(Self::LessOrEqual),
                            "Like" => Some(Self::Like),
                            "NotLike" => Some(Self::NotLike),
                            "In" => Some(Self::In),
                            "NotIn" => Some(Self::NotIn),
                            "Empty" => Some(Self::Empty),
                            "NotEmpty" => Some(Self::NotEmpty),
                            "AllIn" => Some(Self::AllIn),
                            "NotAllIn" => Some(Self::NotAllIn),
                            "ExactIn" => Some(Self::ExactIn),
                            "NotExactIn" => Some(Self::NotExactIn),
                            "Exists" => Some(Self::Exists),
                            _ => None,
                        }
                    }
                }
                #[derive(
                    Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
                )]
                #[repr(i32)]
                pub enum QuickOption {
                    ExactDate = 0,
                    Yesterday = 1,
                    Today = 2,
                    Tomorrow = 3,
                    LastWeek = 4,
                    CurrentWeek = 5,
                    NextWeek = 6,
                    LastMonth = 7,
                    CurrentMonth = 8,
                    NextMonth = 9,
                    NumberOfDaysAgo = 10,
                    NumberOfDaysNow = 11,
                    LastYear = 12,
                    CurrentYear = 13,
                    NextYear = 14,
                }
                impl QuickOption {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::ExactDate => "ExactDate",
                            Self::Yesterday => "Yesterday",
                            Self::Today => "Today",
                            Self::Tomorrow => "Tomorrow",
                            Self::LastWeek => "LastWeek",
                            Self::CurrentWeek => "CurrentWeek",
                            Self::NextWeek => "NextWeek",
                            Self::LastMonth => "LastMonth",
                            Self::CurrentMonth => "CurrentMonth",
                            Self::NextMonth => "NextMonth",
                            Self::NumberOfDaysAgo => "NumberOfDaysAgo",
                            Self::NumberOfDaysNow => "NumberOfDaysNow",
                            Self::LastYear => "LastYear",
                            Self::CurrentYear => "CurrentYear",
                            Self::NextYear => "NextYear",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "ExactDate" => Some(Self::ExactDate),
                            "Yesterday" => Some(Self::Yesterday),
                            "Today" => Some(Self::Today),
                            "Tomorrow" => Some(Self::Tomorrow),
                            "LastWeek" => Some(Self::LastWeek),
                            "CurrentWeek" => Some(Self::CurrentWeek),
                            "NextWeek" => Some(Self::NextWeek),
                            "LastMonth" => Some(Self::LastMonth),
                            "CurrentMonth" => Some(Self::CurrentMonth),
                            "NextMonth" => Some(Self::NextMonth),
                            "NumberOfDaysAgo" => Some(Self::NumberOfDaysAgo),
                            "NumberOfDaysNow" => Some(Self::NumberOfDaysNow),
                            "LastYear" => Some(Self::LastYear),
                            "CurrentYear" => Some(Self::CurrentYear),
                            "NextYear" => Some(Self::NextYear),
                            _ => None,
                        }
                    }
                }
            }
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroupOrder {
                #[prost(string, tag = "1")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(message, repeated, tag = "2")]
                pub view_groups: ::prost::alloc::vec::Vec<ViewGroup>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ViewGroup {
                #[prost(string, tag = "1")]
                pub group_id: ::prost::alloc::string::String,
                #[prost(int32, tag = "2")]
                pub index: i32,
                #[prost(bool, tag = "3")]
                pub hidden: bool,
                #[prost(string, tag = "4")]
                pub background_color: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ObjectOrder {
                #[prost(string, tag = "1")]
                pub view_id: ::prost::alloc::string::String,
                #[prost(string, tag = "2")]
                pub group_id: ::prost::alloc::string::String,
                #[prost(string, repeated, tag = "3")]
                pub object_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Group {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
                #[prost(oneof = "group::Value", tags = "2, 3, 4, 5")]
                pub value: ::core::option::Option<group::Value>,
            }
            /// Nested message and enum types in `Group`.
            pub mod group {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Value {
                    #[prost(message, tag = "2")]
                    Status(super::Status),
                    #[prost(message, tag = "3")]
                    Tag(super::Tag),
                    #[prost(message, tag = "4")]
                    Checkbox(super::Checkbox),
                    #[prost(message, tag = "5")]
                    Date(super::Date),
                }
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Status {
                #[prost(string, tag = "1")]
                pub id: ::prost::alloc::string::String,
            }
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Tag {
                #[prost(string, repeated, tag = "1")]
                pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Checkbox {
                #[prost(bool, tag = "1")]
                pub checked: bool,
            }
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct Date {}
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Relation {
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Latex {
            #[prost(string, tag = "1")]
            pub text: ::prost::alloc::string::String,
            #[prost(enumeration = "latex::Processor", tag = "2")]
            pub processor: i32,
        }
        /// Nested message and enum types in `Latex`.
        pub mod latex {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Processor {
                Latex = 0,
                Mermaid = 1,
                Chart = 2,
                Youtube = 3,
                Vimeo = 4,
                Soundcloud = 5,
                GoogleMaps = 6,
                Miro = 7,
                Figma = 8,
                Twitter = 9,
                OpenStreetMap = 10,
                Reddit = 11,
                Facebook = 12,
                Instagram = 13,
                Telegram = 14,
                GithubGist = 15,
                Codepen = 16,
                Bilibili = 17,
                Excalidraw = 18,
                Kroki = 19,
                Graphviz = 20,
                Sketchfab = 21,
                Image = 22,
                Drawio = 23,
                Spotify = 24,
            }
            impl Processor {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Latex => "Latex",
                        Self::Mermaid => "Mermaid",
                        Self::Chart => "Chart",
                        Self::Youtube => "Youtube",
                        Self::Vimeo => "Vimeo",
                        Self::Soundcloud => "Soundcloud",
                        Self::GoogleMaps => "GoogleMaps",
                        Self::Miro => "Miro",
                        Self::Figma => "Figma",
                        Self::Twitter => "Twitter",
                        Self::OpenStreetMap => "OpenStreetMap",
                        Self::Reddit => "Reddit",
                        Self::Facebook => "Facebook",
                        Self::Instagram => "Instagram",
                        Self::Telegram => "Telegram",
                        Self::GithubGist => "GithubGist",
                        Self::Codepen => "Codepen",
                        Self::Bilibili => "Bilibili",
                        Self::Excalidraw => "Excalidraw",
                        Self::Kroki => "Kroki",
                        Self::Graphviz => "Graphviz",
                        Self::Sketchfab => "Sketchfab",
                        Self::Image => "Image",
                        Self::Drawio => "Drawio",
                        Self::Spotify => "Spotify",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Latex" => Some(Self::Latex),
                        "Mermaid" => Some(Self::Mermaid),
                        "Chart" => Some(Self::Chart),
                        "Youtube" => Some(Self::Youtube),
                        "Vimeo" => Some(Self::Vimeo),
                        "Soundcloud" => Some(Self::Soundcloud),
                        "GoogleMaps" => Some(Self::GoogleMaps),
                        "Miro" => Some(Self::Miro),
                        "Figma" => Some(Self::Figma),
                        "Twitter" => Some(Self::Twitter),
                        "OpenStreetMap" => Some(Self::OpenStreetMap),
                        "Reddit" => Some(Self::Reddit),
                        "Facebook" => Some(Self::Facebook),
                        "Instagram" => Some(Self::Instagram),
                        "Telegram" => Some(Self::Telegram),
                        "GithubGist" => Some(Self::GithubGist),
                        "Codepen" => Some(Self::Codepen),
                        "Bilibili" => Some(Self::Bilibili),
                        "Excalidraw" => Some(Self::Excalidraw),
                        "Kroki" => Some(Self::Kroki),
                        "Graphviz" => Some(Self::Graphviz),
                        "Sketchfab" => Some(Self::Sketchfab),
                        "Image" => Some(Self::Image),
                        "Drawio" => Some(Self::Drawio),
                        "Spotify" => Some(Self::Spotify),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TableOfContents {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Table {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TableColumn {}
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct TableRow {
            #[prost(bool, tag = "1")]
            pub is_header: bool,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Widget {
            #[prost(enumeration = "widget::Layout", tag = "1")]
            pub layout: i32,
            #[prost(int32, tag = "2")]
            pub limit: i32,
            #[prost(string, tag = "3")]
            pub view_id: ::prost::alloc::string::String,
            #[prost(bool, tag = "4")]
            pub auto_added: bool,
        }
        /// Nested message and enum types in `Widget`.
        pub mod widget {
            #[derive(
                Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
            )]
            #[repr(i32)]
            pub enum Layout {
                Link = 0,
                Tree = 1,
                List = 2,
                CompactList = 3,
                View = 4,
            }
            impl Layout {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Link => "Link",
                        Self::Tree => "Tree",
                        Self::List => "List",
                        Self::CompactList => "CompactList",
                        Self::View => "View",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "Link" => Some(Self::Link),
                        "Tree" => Some(Self::Tree),
                        "List" => Some(Self::List),
                        "CompactList" => Some(Self::CompactList),
                        "View" => Some(Self::View),
                        _ => None,
                    }
                }
            }
        }
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Chat {}
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Position {
        None = 0,
        /// above target block
        Top = 1,
        /// under target block
        Bottom = 2,
        /// to left of target block
        Left = 3,
        /// to right of target block
        Right = 4,
        /// inside target block, as last block
        Inner = 5,
        /// replace target block
        Replace = 6,
        /// inside target block, as first block
        InnerFirst = 7,
    }
    impl Position {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "None",
                Self::Top => "Top",
                Self::Bottom => "Bottom",
                Self::Left => "Left",
                Self::Right => "Right",
                Self::Inner => "Inner",
                Self::Replace => "Replace",
                Self::InnerFirst => "InnerFirst",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "None" => Some(Self::None),
                "Top" => Some(Self::Top),
                "Bottom" => Some(Self::Bottom),
                "Left" => Some(Self::Left),
                "Right" => Some(Self::Right),
                "Inner" => Some(Self::Inner),
                "Replace" => Some(Self::Replace),
                "InnerFirst" => Some(Self::InnerFirst),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Align {
        Left = 0,
        Center = 1,
        Right = 2,
        Justify = 3,
    }
    impl Align {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Left => "AlignLeft",
                Self::Center => "AlignCenter",
                Self::Right => "AlignRight",
                Self::Justify => "AlignJustify",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AlignLeft" => Some(Self::Left),
                "AlignCenter" => Some(Self::Center),
                "AlignRight" => Some(Self::Right),
                "AlignJustify" => Some(Self::Justify),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum VerticalAlign {
        Top = 0,
        Middle = 1,
        Bottom = 2,
    }
    impl VerticalAlign {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Top => "VerticalAlignTop",
                Self::Middle => "VerticalAlignMiddle",
                Self::Bottom => "VerticalAlignBottom",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VerticalAlignTop" => Some(Self::Top),
                "VerticalAlignMiddle" => Some(Self::Middle),
                "VerticalAlignBottom" => Some(Self::Bottom),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ContentValue {
        #[prost(message, tag = "11")]
        Smartblock(content::Smartblock),
        #[prost(message, tag = "14")]
        Text(content::Text),
        #[prost(message, tag = "15")]
        File(content::File),
        #[prost(message, tag = "16")]
        Layout(content::Layout),
        #[prost(message, tag = "17")]
        Div(content::Div),
        #[prost(message, tag = "18")]
        Bookmark(content::Bookmark),
        #[prost(message, tag = "19")]
        Icon(content::Icon),
        #[prost(message, tag = "20")]
        Link(content::Link),
        #[prost(message, tag = "21")]
        Dataview(content::Dataview),
        #[prost(message, tag = "22")]
        Relation(content::Relation),
        #[prost(message, tag = "23")]
        FeaturedRelations(content::FeaturedRelations),
        #[prost(message, tag = "24")]
        Latex(content::Latex),
        #[prost(message, tag = "25")]
        TableOfContents(content::TableOfContents),
        #[prost(message, tag = "26")]
        Table(content::Table),
        #[prost(message, tag = "27")]
        TableColumn(content::TableColumn),
        #[prost(message, tag = "28")]
        TableRow(content::TableRow),
        #[prost(message, tag = "29")]
        Widget(content::Widget),
        #[prost(message, tag = "30")]
        Chat(content::Chat),
    }
}
/// Used to decode block meta only, without the content itself
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockMetaOnly {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub fields: ::core::option::Option<::prost_types::Struct>,
}
/// General purpose structure, uses in Mark.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Range {
    #[prost(int32, tag = "1")]
    pub from: i32,
    #[prost(int32, tag = "2")]
    pub to: i32,
}
/// *
///
/// Contains basic information about a user account
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// User's thread id
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<account::Config>,
    #[prost(message, optional, tag = "5")]
    pub status: ::core::option::Option<account::Status>,
    #[prost(message, optional, tag = "6")]
    pub info: ::core::option::Option<account::Info>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Config {
        #[prost(bool, tag = "1")]
        pub enable_dataview: bool,
        #[prost(bool, tag = "2")]
        pub enable_debug: bool,
        #[prost(bool, tag = "3")]
        pub enable_prerelease_channel: bool,
        #[prost(bool, tag = "4")]
        pub enable_spaces: bool,
        #[prost(message, optional, tag = "100")]
        pub extra: ::core::option::Option<::prost_types::Struct>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {
        #[prost(enumeration = "StatusType", tag = "1")]
        pub status_type: i32,
        #[prost(int64, tag = "2")]
        pub deletion_date: i64,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Info {
        /// home dashboard block id
        #[prost(string, tag = "2")]
        pub home_object_id: ::prost::alloc::string::String,
        /// archive block id
        #[prost(string, tag = "3")]
        pub archive_object_id: ::prost::alloc::string::String,
        /// profile block id
        #[prost(string, tag = "4")]
        pub profile_object_id: ::prost::alloc::string::String,
        /// marketplace workspace id
        #[prost(string, tag = "11")]
        pub marketplace_workspace_id: ::prost::alloc::string::String,
        /// workspace object id. used for space-level chat
        #[prost(string, tag = "15")]
        pub workspace_object_id: ::prost::alloc::string::String,
        /// space-level chat if exists
        #[prost(string, tag = "16")]
        pub space_chat_id: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub device_id: ::prost::alloc::string::String,
        /// the first created private space. It's filled only when account is created
        #[prost(string, tag = "9")]
        pub account_space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "10")]
        pub widgets_id: ::prost::alloc::string::String,
        #[prost(string, tag = "13")]
        pub space_view_id: ::prost::alloc::string::String,
        #[prost(string, tag = "14")]
        pub tech_space_id: ::prost::alloc::string::String,
        /// gateway url for fetching static files
        #[prost(string, tag = "101")]
        pub gateway_url: ::prost::alloc::string::String,
        /// path to local storage
        #[prost(string, tag = "103")]
        pub local_storage_path: ::prost::alloc::string::String,
        /// time zone from config
        #[prost(string, tag = "104")]
        pub time_zone: ::prost::alloc::string::String,
        #[prost(string, tag = "105")]
        pub analytics_id: ::prost::alloc::string::String,
        /// network id to which anytype is connected
        #[prost(string, tag = "106")]
        pub network_id: ::prost::alloc::string::String,
        /// we have Any PK AND Ethereum PK derived from one seed phrase
        #[prost(string, tag = "107")]
        pub ethereum_address: ::prost::alloc::string::String,
        /// symmetric key for encrypting profile metadata
        #[prost(string, tag = "108")]
        pub meta_data_key: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Auth {}
    /// Nested message and enum types in `Auth`.
    pub mod auth {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AppInfo {
            #[prost(string, tag = "1")]
            pub app_hash: ::prost::alloc::string::String,
            /// either from process or specified manually when creating
            #[prost(string, tag = "2")]
            pub app_name: ::prost::alloc::string::String,
            #[prost(string, tag = "4")]
            pub app_key: ::prost::alloc::string::String,
            #[prost(int64, tag = "5")]
            pub created_at: i64,
            #[prost(int64, tag = "6")]
            pub expire_at: i64,
            #[prost(enumeration = "LocalApiScope", tag = "7")]
            pub scope: i32,
            #[prost(bool, tag = "8")]
            pub is_active: bool,
        }
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum LocalApiScope {
            /// Used in WebClipper; AccountSelect(to be deprecated), ObjectSearch, ObjectShow, ObjectCreate, ObjectCreateFromURL, BlockPreview, BlockPaste, BroadcastPayloadEvent
            Limited = 0,
            /// JSON API only, no direct grpc api calls allowed
            JsonApi = 1,
            /// Full access, not available via LocalLink
            Full = 2,
        }
        impl LocalApiScope {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Limited => "Limited",
                    Self::JsonApi => "JsonAPI",
                    Self::Full => "Full",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "Limited" => Some(Self::Limited),
                    "JsonAPI" => Some(Self::JsonApi),
                    "Full" => Some(Self::Full),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum StatusType {
        Active = 0,
        PendingDeletion = 1,
        StartedDeletion = 2,
        Deleted = 3,
    }
    impl StatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Active => "Active",
                Self::PendingDeletion => "PendingDeletion",
                Self::StartedDeletion => "StartedDeletion",
                Self::Deleted => "Deleted",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Active" => Some(Self::Active),
                "PendingDeletion" => Some(Self::PendingDeletion),
                "StartedDeletion" => Some(Self::StartedDeletion),
                "Deleted" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LinkPreview {
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub image_url: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub favicon_url: ::prost::alloc::string::String,
    #[prost(enumeration = "link_preview::Type", tag = "6")]
    pub r#type: i32,
}
/// Nested message and enum types in `LinkPreview`.
pub mod link_preview {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Unknown = 0,
        Page = 1,
        Image = 2,
        Text = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::Page => "Page",
                Self::Image => "Image",
                Self::Text => "Text",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "Page" => Some(Self::Page),
                "Image" => Some(Self::Image),
                "Text" => Some(Self::Text),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Restrictions {
    #[prost(enumeration = "restrictions::ObjectRestriction", repeated, tag = "1")]
    pub object: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "2")]
    pub dataview: ::prost::alloc::vec::Vec<restrictions::DataviewRestrictions>,
}
/// Nested message and enum types in `Restrictions`.
pub mod restrictions {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DataviewRestrictions {
        #[prost(string, tag = "1")]
        pub block_id: ::prost::alloc::string::String,
        #[prost(enumeration = "DataviewRestriction", repeated, tag = "2")]
        pub restrictions: ::prost::alloc::vec::Vec<i32>,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ObjectRestriction {
        None = 0,
        /// restricts delete
        Delete = 1,
        /// restricts work with relations
        Relations = 2,
        /// restricts work with blocks
        Blocks = 3,
        /// restricts work with details
        Details = 4,
        /// restricts type changing
        TypeChange = 5,
        /// restricts layout changing
        LayoutChange = 6,
        /// restricts template creation from this object
        Template = 7,
        /// restricts duplicate object
        Duplicate = 8,
        /// can be set only for types. Restricts creating objects of this type
        CreateObjectOfThisType = 9,
        /// object is not allowed to publish
        Publish = 10,
    }
    impl ObjectRestriction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "None",
                Self::Delete => "Delete",
                Self::Relations => "Relations",
                Self::Blocks => "Blocks",
                Self::Details => "Details",
                Self::TypeChange => "TypeChange",
                Self::LayoutChange => "LayoutChange",
                Self::Template => "Template",
                Self::Duplicate => "Duplicate",
                Self::CreateObjectOfThisType => "CreateObjectOfThisType",
                Self::Publish => "Publish",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "None" => Some(Self::None),
                "Delete" => Some(Self::Delete),
                "Relations" => Some(Self::Relations),
                "Blocks" => Some(Self::Blocks),
                "Details" => Some(Self::Details),
                "TypeChange" => Some(Self::TypeChange),
                "LayoutChange" => Some(Self::LayoutChange),
                "Template" => Some(Self::Template),
                "Duplicate" => Some(Self::Duplicate),
                "CreateObjectOfThisType" => Some(Self::CreateObjectOfThisType),
                "Publish" => Some(Self::Publish),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataviewRestriction {
        DvNone = 0,
        DvRelation = 1,
        DvCreateObject = 2,
        DvViews = 3,
    }
    impl DataviewRestriction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DvNone => "DVNone",
                Self::DvRelation => "DVRelation",
                Self::DvCreateObject => "DVCreateObject",
                Self::DvViews => "DVViews",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DVNone" => Some(Self::DvNone),
                "DVRelation" => Some(Self::DvRelation),
                "DVCreateObject" => Some(Self::DvCreateObject),
                "DVViews" => Some(Self::DvViews),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Object {}
/// Nested message and enum types in `Object`.
pub mod object {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChangePayload {
        #[prost(enumeration = "super::SmartBlockType", tag = "1")]
        pub smart_block_type: i32,
        #[prost(string, tag = "2")]
        pub key: ::prost::alloc::string::String,
        #[prost(bytes = "vec", tag = "3")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpaceObjectHeader {
    #[prost(string, tag = "1")]
    pub space_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectType {
    /// leave empty in case you want to create the new one
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// name of objectType in singular form (can be localized for bundled types)
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// cannot contain more than one Relation with the same RelationType
    #[prost(message, repeated, tag = "3")]
    pub relation_links: ::prost::alloc::vec::Vec<RelationLink>,
    #[prost(enumeration = "object_type::Layout", tag = "4")]
    pub layout: i32,
    /// emoji symbol
    #[prost(string, tag = "5")]
    pub icon_emoji: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub hidden: bool,
    #[prost(bool, tag = "10")]
    pub readonly: bool,
    #[prost(enumeration = "SmartBlockType", repeated, tag = "8")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    /// sets locally to hide object type from set and some other places
    #[prost(bool, tag = "9")]
    pub is_archived: bool,
    #[prost(bool, tag = "11")]
    pub installed_by_default: bool,
    /// name of objectType (can be localized for bundled types)
    #[prost(string, tag = "12")]
    pub key: ::prost::alloc::string::String,
    /// revision of system objectType. Used to check if we should change type content or not
    #[prost(int64, tag = "13")]
    pub revision: i64,
    /// restricts creating objects of this type for users
    #[prost(bool, tag = "14")]
    pub restrict_object_creation: bool,
    /// color of object type icon
    #[prost(int64, tag = "15")]
    pub icon_color: i64,
    /// name of object type icon
    #[prost(string, tag = "16")]
    pub icon_name: ::prost::alloc::string::String,
    /// name of objectType in plural form (can be localized for bundled types)
    #[prost(string, tag = "17")]
    pub plural_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ObjectType`.
pub mod object_type {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Layout {
        Basic = 0,
        Profile = 1,
        Todo = 2,
        Set = 3,
        ObjectType = 4,
        Relation = 5,
        File = 6,
        Dashboard = 7,
        Image = 8,
        Note = 9,
        Space = 10,
        Bookmark = 11,
        RelationOptionsList = 12,
        RelationOption = 13,
        Collection = 14,
        Audio = 15,
        Video = 16,
        Date = 17,
        SpaceView = 18,
        Participant = 19,
        Pdf = 20,
        /// deprecated
        ChatDeprecated = 21,
        ChatDerived = 22,
        Tag = 23,
        Notification = 24,
        MissingObject = 25,
        Devices = 26,
    }
    impl Layout {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Basic => "basic",
                Self::Profile => "profile",
                Self::Todo => "todo",
                Self::Set => "set",
                Self::ObjectType => "objectType",
                Self::Relation => "relation",
                Self::File => "file",
                Self::Dashboard => "dashboard",
                Self::Image => "image",
                Self::Note => "note",
                Self::Space => "space",
                Self::Bookmark => "bookmark",
                Self::RelationOptionsList => "relationOptionsList",
                Self::RelationOption => "relationOption",
                Self::Collection => "collection",
                Self::Audio => "audio",
                Self::Video => "video",
                Self::Date => "date",
                Self::SpaceView => "spaceView",
                Self::Participant => "participant",
                Self::Pdf => "pdf",
                Self::ChatDeprecated => "chatDeprecated",
                Self::ChatDerived => "chatDerived",
                Self::Tag => "tag",
                Self::Notification => "notification",
                Self::MissingObject => "missingObject",
                Self::Devices => "devices",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "basic" => Some(Self::Basic),
                "profile" => Some(Self::Profile),
                "todo" => Some(Self::Todo),
                "set" => Some(Self::Set),
                "objectType" => Some(Self::ObjectType),
                "relation" => Some(Self::Relation),
                "file" => Some(Self::File),
                "dashboard" => Some(Self::Dashboard),
                "image" => Some(Self::Image),
                "note" => Some(Self::Note),
                "space" => Some(Self::Space),
                "bookmark" => Some(Self::Bookmark),
                "relationOptionsList" => Some(Self::RelationOptionsList),
                "relationOption" => Some(Self::RelationOption),
                "collection" => Some(Self::Collection),
                "audio" => Some(Self::Audio),
                "video" => Some(Self::Video),
                "date" => Some(Self::Date),
                "spaceView" => Some(Self::SpaceView),
                "participant" => Some(Self::Participant),
                "pdf" => Some(Self::Pdf),
                "chatDeprecated" => Some(Self::ChatDeprecated),
                "chatDerived" => Some(Self::ChatDerived),
                "tag" => Some(Self::Tag),
                "notification" => Some(Self::Notification),
                "missingObject" => Some(Self::MissingObject),
                "devices" => Some(Self::Devices),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Layout {
    #[prost(enumeration = "object_type::Layout", tag = "1")]
    pub id: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// relations required for this object type
    #[prost(message, repeated, tag = "3")]
    pub required_relations: ::prost::alloc::vec::Vec<Relation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationWithValue {
    #[prost(message, optional, tag = "1")]
    pub relation: ::core::option::Option<Relation>,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::prost_types::Value>,
}
/// Relation describe the human-interpreted relation type. It may be something like "Date of creation, format=date" or "Assignee, format=objectId, objectType=person"
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relation {
    #[prost(string, tag = "100")]
    pub id: ::prost::alloc::string::String,
    /// Key under which the value is stored in the map. Must be unique for the object type.
    /// It usually auto-generated bsonid, but also may be something human-readable in case of prebuilt types.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// format of the underlying data
    #[prost(enumeration = "RelationFormat", tag = "2")]
    pub format: i32,
    /// name to show (can be localized for bundled types)
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub default_value: ::core::option::Option<::prost_types::Value>,
    /// where the data is stored
    #[prost(enumeration = "relation::DataSource", tag = "5")]
    pub data_source: i32,
    /// internal, not displayed to user (e.g. coverX, coverY)
    #[prost(bool, tag = "6")]
    pub hidden: bool,
    /// value not editable by user tobe renamed to readonlyValue
    #[prost(bool, tag = "7")]
    pub read_only: bool,
    /// relation metadata, eg name and format is not editable by user
    #[prost(bool, tag = "15")]
    pub read_only_relation: bool,
    /// allow multiple values (stored in pb list)
    #[prost(bool, tag = "8")]
    pub multi: bool,
    /// URL of object type, empty to allow link to any object
    #[prost(string, repeated, tag = "9")]
    pub object_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// index 10, 11 was used in internal-only builds. Can be reused, but may break some test accounts
    ///
    /// default dictionary with unique values to choose for select/multiSelect format
    #[prost(message, repeated, tag = "12")]
    pub select_dict: ::prost::alloc::vec::Vec<relation::Option>,
    /// max number of values can be set for this relation. 0 means no limit. 1 means the value can be stored in non-repeated field
    #[prost(int32, tag = "13")]
    pub max_count: i32,
    #[prost(string, tag = "14")]
    pub description: ::prost::alloc::string::String,
    /// on-store fields, injected only locally
    ///
    /// deprecated, to be removed
    #[prost(enumeration = "relation::Scope", tag = "20")]
    pub scope: i32,
    /// creator profile id
    #[prost(string, tag = "21")]
    pub creator: ::prost::alloc::string::String,
    /// revision of system relation. Used to check if we should change relation content or not
    #[prost(int64, tag = "22")]
    pub revision: i64,
    /// indicates whether value of relation with date format should be processed with seconds precision
    #[prost(bool, tag = "23")]
    pub include_time: bool,
}
/// Nested message and enum types in `Relation`.
pub mod relation {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Option {
        /// id generated automatically if omitted
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub text: ::prost::alloc::string::String,
        /// stored
        #[prost(string, tag = "3")]
        pub color: ::prost::alloc::string::String,
        /// 4 is reserved for old relation format
        ///
        /// stored
        #[prost(string, tag = "5")]
        pub relation_key: ::prost::alloc::string::String,
        /// lexicographic id of relation option for ordering
        #[prost(string, tag = "6")]
        pub order_id: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Scope {
        /// stored within the object
        Object = 0,
        /// stored within the object type
        Type = 1,
        /// aggregated from the dataview of sets of the same object type
        SetOfTheSameType = 2,
        /// aggregated from the dataview of sets of the same object type
        ObjectsOfTheSameType = 3,
        /// aggregated from relations library
        Library = 4,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Object => "object",
                Self::Type => "type",
                Self::SetOfTheSameType => "setOfTheSameType",
                Self::ObjectsOfTheSameType => "objectsOfTheSameType",
                Self::Library => "library",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "object" => Some(Self::Object),
                "type" => Some(Self::Type),
                "setOfTheSameType" => Some(Self::SetOfTheSameType),
                "objectsOfTheSameType" => Some(Self::ObjectsOfTheSameType),
                "library" => Some(Self::Library),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum DataSource {
        /// default, stored inside the object's details
        Details = 0,
        /// stored locally, e.g. in badger or generated on the fly
        Derived = 1,
        /// stored in the account DB. means existing only for specific anytype account
        Account = 2,
        /// stored locally
        Local = 3,
    }
    impl DataSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Details => "details",
                Self::Derived => "derived",
                Self::Account => "account",
                Self::Local => "local",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "details" => Some(Self::Details),
                "derived" => Some(Self::Derived),
                "account" => Some(Self::Account),
                "local" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RelationLink {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(enumeration = "RelationFormat", tag = "2")]
    pub format: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Relations {
    #[prost(message, repeated, tag = "1")]
    pub relations: ::prost::alloc::vec::Vec<Relation>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelationOptions {
    #[prost(message, repeated, tag = "1")]
    pub options: ::prost::alloc::vec::Vec<relation::Option>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InternalFlag {
    #[prost(enumeration = "internal_flag::Value", tag = "1")]
    pub value: i32,
}
/// Nested message and enum types in `InternalFlag`.
pub mod internal_flag {
    /// Use such a weird construction due to the issue with imported repeated enum type
    /// Look <https://github.com/golang/protobuf/issues/1135> for more information.
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Value {
        EditorDeleteEmpty = 0,
        EditorSelectType = 1,
        EditorSelectTemplate = 2,
        CollectionDontIndexLinks = 3,
    }
    impl Value {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EditorDeleteEmpty => "editorDeleteEmpty",
                Self::EditorSelectType => "editorSelectType",
                Self::EditorSelectTemplate => "editorSelectTemplate",
                Self::CollectionDontIndexLinks => "collectionDontIndexLinks",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "editorDeleteEmpty" => Some(Self::EditorDeleteEmpty),
                "editorSelectType" => Some(Self::EditorSelectType),
                "editorSelectTemplate" => Some(Self::EditorSelectTemplate),
                "collectionDontIndexLinks" => Some(Self::CollectionDontIndexLinks),
                _ => None,
            }
        }
    }
}
/// Works with a smart blocks: Page, Dashboard
/// Dashboard opened, click on a page, Rpc.Block.open, Block.ShowFullscreen(PageBlock)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectView {
    /// Root block id
    #[prost(string, tag = "1")]
    pub root_id: ::prost::alloc::string::String,
    /// dependent simple blocks (descendants)
    #[prost(message, repeated, tag = "2")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    /// details for the current and dependent objects
    #[prost(message, repeated, tag = "3")]
    pub details: ::prost::alloc::vec::Vec<object_view::DetailsSet>,
    #[prost(enumeration = "SmartBlockType", tag = "4")]
    pub r#type: i32,
    /// DEPRECATED, use relationLinks instead
    #[prost(message, repeated, tag = "7")]
    pub relations: ::prost::alloc::vec::Vec<Relation>,
    #[prost(message, repeated, tag = "10")]
    pub relation_links: ::prost::alloc::vec::Vec<RelationLink>,
    /// object restrictions
    #[prost(message, optional, tag = "8")]
    pub restrictions: ::core::option::Option<Restrictions>,
    #[prost(message, optional, tag = "9")]
    pub history: ::core::option::Option<object_view::HistorySize>,
    #[prost(message, repeated, tag = "11")]
    pub block_participants: ::prost::alloc::vec::Vec<object_view::BlockParticipant>,
}
/// Nested message and enum types in `ObjectView`.
pub mod object_view {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DetailsSet {
        /// context objectId
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// can not be a partial state. Should replace client details state
        #[prost(message, optional, tag = "2")]
        pub details: ::core::option::Option<::prost_types::Struct>,
        #[prost(string, repeated, tag = "3")]
        pub sub_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RelationWithValuePerObject {
        #[prost(string, tag = "1")]
        pub object_id: ::prost::alloc::string::String,
        #[prost(message, repeated, tag = "2")]
        pub relations: ::prost::alloc::vec::Vec<super::RelationWithValue>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct HistorySize {
        #[prost(int32, tag = "1")]
        pub undo: i32,
        #[prost(int32, tag = "2")]
        pub redo: i32,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BlockParticipant {
        #[prost(string, tag = "1")]
        pub block_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub participant_id: ::prost::alloc::string::String,
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParticipantPermissionChange {
    #[prost(string, tag = "1")]
    pub identity: ::prost::alloc::string::String,
    #[prost(enumeration = "ParticipantPermissions", tag = "2")]
    pub perms: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Metadata {
    #[prost(oneof = "metadata::PayloadValue", tags = "1")]
    pub payload_value: ::core::option::Option<metadata::PayloadValue>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Payload {}
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct IdentityPayload {
            #[prost(bytes = "vec", tag = "1")]
            pub profile_sym_key: ::prost::alloc::vec::Vec<u8>,
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum PayloadValue {
        #[prost(message, tag = "1")]
        Identity(payload::IdentityPayload),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Notification {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub create_time: i64,
    #[prost(enumeration = "notification::Status", tag = "4")]
    pub status: i32,
    #[prost(bool, tag = "5")]
    pub is_local: bool,
    #[prost(string, tag = "7")]
    pub space: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub acl_head_id: ::prost::alloc::string::String,
    #[prost(
        oneof = "notification::Payload",
        tags = "6, 8, 9, 10, 11, 13, 15, 16, 17, 18"
    )]
    pub payload: ::core::option::Option<notification::Payload>,
}
/// Nested message and enum types in `Notification`.
pub mod notification {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Import {
        #[prost(string, tag = "1")]
        pub process_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::import::ErrorCode", tag = "2")]
        pub error_code: i32,
        #[prost(enumeration = "super::import::Type", tag = "3")]
        pub import_type: i32,
        #[prost(string, tag = "4")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Export {
        #[prost(enumeration = "export::Code", tag = "2")]
        pub error_code: i32,
        #[prost(enumeration = "super::export::Format", tag = "3")]
        pub export_type: i32,
    }
    /// Nested message and enum types in `Export`.
    pub mod export {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Code {
            Null = 0,
            UnknownError = 1,
            BadInput = 2,
        }
        impl Code {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Null => "NULL",
                    Self::UnknownError => "UNKNOWN_ERROR",
                    Self::BadInput => "BAD_INPUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NULL" => Some(Self::Null),
                    "UNKNOWN_ERROR" => Some(Self::UnknownError),
                    "BAD_INPUT" => Some(Self::BadInput),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GalleryImport {
        #[prost(string, tag = "1")]
        pub process_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::import::ErrorCode", tag = "2")]
        pub error_code: i32,
        #[prost(string, tag = "3")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RequestToJoin {
        #[prost(string, tag = "1")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub identity: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub identity_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub identity_icon: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Test {}
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParticipantRequestApproved {
        #[prost(string, tag = "1")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::ParticipantPermissions", tag = "2")]
        pub permissions: i32,
        #[prost(string, tag = "5")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RequestToLeave {
        #[prost(string, tag = "1")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub identity: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub identity_name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub identity_icon: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParticipantRemove {
        #[prost(string, tag = "1")]
        pub identity: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub identity_name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub identity_icon: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParticipantRequestDecline {
        #[prost(string, tag = "1")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParticipantPermissionsChange {
        #[prost(string, tag = "1")]
        pub space_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::ParticipantPermissions", tag = "2")]
        pub permissions: i32,
        #[prost(string, tag = "3")]
        pub space_name: ::prost::alloc::string::String,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Created = 0,
        Shown = 1,
        Read = 2,
        Replied = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Created => "Created",
                Self::Shown => "Shown",
                Self::Read => "Read",
                Self::Replied => "Replied",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Created" => Some(Self::Created),
                "Shown" => Some(Self::Shown),
                "Read" => Some(Self::Read),
                "Replied" => Some(Self::Replied),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ActionType {
        Close = 0,
    }
    impl ActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Close => "CLOSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLOSE" => Some(Self::Close),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "6")]
        Import(Import),
        #[prost(message, tag = "8")]
        Export(Export),
        #[prost(message, tag = "9")]
        GalleryImport(GalleryImport),
        #[prost(message, tag = "10")]
        RequestToJoin(RequestToJoin),
        #[prost(message, tag = "11")]
        Test(Test),
        #[prost(message, tag = "13")]
        ParticipantRequestApproved(ParticipantRequestApproved),
        #[prost(message, tag = "15")]
        RequestToLeave(RequestToLeave),
        #[prost(message, tag = "16")]
        ParticipantRemove(ParticipantRemove),
        #[prost(message, tag = "17")]
        ParticipantRequestDecline(ParticipantRequestDecline),
        #[prost(message, tag = "18")]
        ParticipantPermissionsChange(ParticipantPermissionsChange),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Export {}
/// Nested message and enum types in `Export`.
pub mod export {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Format {
        Markdown = 0,
        Protobuf = 1,
        Json = 2,
        Dot = 3,
        Svg = 4,
        GraphJson = 5,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Markdown => "Markdown",
                Self::Protobuf => "Protobuf",
                Self::Json => "JSON",
                Self::Dot => "DOT",
                Self::Svg => "SVG",
                Self::GraphJson => "GRAPH_JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Markdown" => Some(Self::Markdown),
                "Protobuf" => Some(Self::Protobuf),
                "JSON" => Some(Self::Json),
                "DOT" => Some(Self::Dot),
                "SVG" => Some(Self::Svg),
                "GRAPH_JSON" => Some(Self::GraphJson),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Import {}
/// Nested message and enum types in `Import`.
pub mod import {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        Notion = 0,
        Markdown = 1,
        /// external developers use it
        External = 2,
        Pb = 3,
        Html = 4,
        Txt = 5,
        Csv = 6,
        /// Markdown with obsidian improvements
        Obsidian = 7,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Notion => "Notion",
                Self::Markdown => "Markdown",
                Self::External => "External",
                Self::Pb => "Pb",
                Self::Html => "Html",
                Self::Txt => "Txt",
                Self::Csv => "Csv",
                Self::Obsidian => "Obsidian",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Notion" => Some(Self::Notion),
                "Markdown" => Some(Self::Markdown),
                "External" => Some(Self::External),
                "Pb" => Some(Self::Pb),
                "Html" => Some(Self::Html),
                "Txt" => Some(Self::Txt),
                "Csv" => Some(Self::Csv),
                "Obsidian" => Some(Self::Obsidian),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ErrorCode {
        Null = 0,
        UnknownError = 1,
        BadInput = 2,
        InternalError = 3,
        FileLoadError = 8,
        ImportIsCanceled = 6,
        NotionNoObjectsInIntegration = 5,
        NotionServerIsUnavailable = 12,
        NotionRateLimitExceeded = 13,
        FileImportNoObjectsInZipArchive = 14,
        FileImportNoObjectsInDirectory = 17,
        HtmlWrongHtmlStructure = 10,
        PbNotAnyblockFormat = 11,
        CsvLimitOfRowsOrRelationsExceeded = 7,
        InsufficientPermissions = 9,
    }
    impl ErrorCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Null => "NULL",
                Self::UnknownError => "UNKNOWN_ERROR",
                Self::BadInput => "BAD_INPUT",
                Self::InternalError => "INTERNAL_ERROR",
                Self::FileLoadError => "FILE_LOAD_ERROR",
                Self::ImportIsCanceled => "IMPORT_IS_CANCELED",
                Self::NotionNoObjectsInIntegration => "NOTION_NO_OBJECTS_IN_INTEGRATION",
                Self::NotionServerIsUnavailable => "NOTION_SERVER_IS_UNAVAILABLE",
                Self::NotionRateLimitExceeded => "NOTION_RATE_LIMIT_EXCEEDED",
                Self::FileImportNoObjectsInZipArchive => "FILE_IMPORT_NO_OBJECTS_IN_ZIP_ARCHIVE",
                Self::FileImportNoObjectsInDirectory => "FILE_IMPORT_NO_OBJECTS_IN_DIRECTORY",
                Self::HtmlWrongHtmlStructure => "HTML_WRONG_HTML_STRUCTURE",
                Self::PbNotAnyblockFormat => "PB_NOT_ANYBLOCK_FORMAT",
                Self::CsvLimitOfRowsOrRelationsExceeded => {
                    "CSV_LIMIT_OF_ROWS_OR_RELATIONS_EXCEEDED"
                }
                Self::InsufficientPermissions => "INSUFFICIENT_PERMISSIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NULL" => Some(Self::Null),
                "UNKNOWN_ERROR" => Some(Self::UnknownError),
                "BAD_INPUT" => Some(Self::BadInput),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "FILE_LOAD_ERROR" => Some(Self::FileLoadError),
                "IMPORT_IS_CANCELED" => Some(Self::ImportIsCanceled),
                "NOTION_NO_OBJECTS_IN_INTEGRATION" => Some(Self::NotionNoObjectsInIntegration),
                "NOTION_SERVER_IS_UNAVAILABLE" => Some(Self::NotionServerIsUnavailable),
                "NOTION_RATE_LIMIT_EXCEEDED" => Some(Self::NotionRateLimitExceeded),
                "FILE_IMPORT_NO_OBJECTS_IN_ZIP_ARCHIVE" => {
                    Some(Self::FileImportNoObjectsInZipArchive)
                }
                "FILE_IMPORT_NO_OBJECTS_IN_DIRECTORY" => Some(Self::FileImportNoObjectsInDirectory),
                "HTML_WRONG_HTML_STRUCTURE" => Some(Self::HtmlWrongHtmlStructure),
                "PB_NOT_ANYBLOCK_FORMAT" => Some(Self::PbNotAnyblockFormat),
                "CSV_LIMIT_OF_ROWS_OR_RELATIONS_EXCEEDED" => {
                    Some(Self::CsvLimitOfRowsOrRelationsExceeded)
                }
                "INSUFFICIENT_PERMISSIONS" => Some(Self::InsufficientPermissions),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Invite {
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvitePayload {
    #[prost(string, tag = "1")]
    pub creator_identity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub creator_name: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub creator_icon_cid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "13")]
    pub creator_icon_encryption_keys: ::prost::alloc::vec::Vec<FileEncryptionKey>,
    #[prost(bytes = "vec", tag = "3")]
    pub acl_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub space_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub space_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub space_icon_cid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "10")]
    pub space_icon_option: u32,
    #[prost(uint32, tag = "11")]
    pub space_ux_type: u32,
    #[prost(message, repeated, tag = "7")]
    pub space_icon_encryption_keys: ::prost::alloc::vec::Vec<FileEncryptionKey>,
    #[prost(enumeration = "InviteType", tag = "8")]
    pub invite_type: i32,
    #[prost(bytes = "vec", tag = "9")]
    pub guest_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityProfile {
    #[prost(string, tag = "1")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub icon_cid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub icon_encryption_keys: ::prost::alloc::vec::Vec<FileEncryptionKey>,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub global_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityProfileWithKey {
    #[prost(message, optional, tag = "1")]
    pub identity_profile: ::core::option::Option<IdentityProfile>,
    #[prost(bytes = "vec", tag = "2")]
    pub request_metadata: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    #[prost(string, tag = "1")]
    pub file_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub encryption_keys: ::prost::alloc::vec::Vec<FileEncryptionKey>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileEncryptionKey {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ManifestInfo {
    #[prost(string, tag = "1")]
    pub schema: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub license: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "8")]
    pub screenshots: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "9")]
    pub download_link: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub file_size: i32,
    #[prost(string, repeated, tag = "11")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "12")]
    pub language: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Membership {
    /// it was Tier before, changed to int32 to allow dynamic values
    #[prost(uint32, tag = "1")]
    pub tier: u32,
    #[prost(enumeration = "membership::Status", tag = "2")]
    pub status: i32,
    #[prost(uint64, tag = "3")]
    pub date_started: u64,
    #[prost(uint64, tag = "4")]
    pub date_ends: u64,
    #[prost(bool, tag = "5")]
    pub is_auto_renew: bool,
    #[prost(enumeration = "membership::PaymentMethod", tag = "6")]
    pub payment_method: i32,
    /// can be empty if user did not ask for any name
    #[prost(string, tag = "7")]
    pub ns_name: ::prost::alloc::string::String,
    #[prost(enumeration = "NameserviceNameType", tag = "8")]
    pub ns_name_type: i32,
    /// if the email was verified by the user or set during the checkout - it will be here
    #[prost(string, tag = "9")]
    pub user_email: ::prost::alloc::string::String,
    #[prost(bool, tag = "10")]
    pub subscribe_to_newsletter: bool,
}
/// Nested message and enum types in `Membership`.
pub mod membership {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Unknown = 0,
        /// please wait a bit more, we are still processing your request
        /// the payment is confirmed, but we need more time to do some side-effects:
        ///
        /// * increase limits
        /// * send emails
        /// * allocate names
        Pending = 1,
        /// the membership is active, ready to use!
        Active = 2,
        /// in some cases we need to finalize the process:
        ///
        /// * if user has bought membership directly without first calling
        ///   the BuySubscription method
        ///   in this case please call Finalize to finish the process
        PendingRequiresFinalization = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "StatusUnknown",
                Self::Pending => "StatusPending",
                Self::Active => "StatusActive",
                Self::PendingRequiresFinalization => "StatusPendingRequiresFinalization",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "StatusUnknown" => Some(Self::Unknown),
                "StatusPending" => Some(Self::Pending),
                "StatusActive" => Some(Self::Active),
                "StatusPendingRequiresFinalization" => Some(Self::PendingRequiresFinalization),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PaymentMethod {
        MethodNone = 0,
        MethodStripe = 1,
        MethodCrypto = 2,
        MethodInappApple = 3,
        MethodInappGoogle = 4,
    }
    impl PaymentMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MethodNone => "MethodNone",
                Self::MethodStripe => "MethodStripe",
                Self::MethodCrypto => "MethodCrypto",
                Self::MethodInappApple => "MethodInappApple",
                Self::MethodInappGoogle => "MethodInappGoogle",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MethodNone" => Some(Self::MethodNone),
                "MethodStripe" => Some(Self::MethodStripe),
                "MethodCrypto" => Some(Self::MethodCrypto),
                "MethodInappApple" => Some(Self::MethodInappApple),
                "MethodInappGoogle" => Some(Self::MethodInappGoogle),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum EmailVerificationStatus {
        /// user NEVER comleted the verification of the email
        StatusNotVerified = 0,
        /// user has asked for new code, but did not enter it yet
        /// (even if email was verified before, you can ask to UPDATE your e-mail)
        /// please wait, you can not ask for more codes yet
        StatusCodeSent = 1,
        /// the e-mail is finally verified
        StatusVerified = 2,
    }
    impl EmailVerificationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::StatusNotVerified => "StatusNotVerified",
                Self::StatusCodeSent => "StatusCodeSent",
                Self::StatusVerified => "StatusVerified",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "StatusNotVerified" => Some(Self::StatusNotVerified),
                "StatusCodeSent" => Some(Self::StatusCodeSent),
                "StatusVerified" => Some(Self::StatusVerified),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MembershipTierData {
    /// this is a unique Payment Node ID of the tier
    /// WARNING: tiers can be sorted differently, not according to their IDs!
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// localazied name of the tier
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// just a short technical description
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// is this tier for testing and debugging only?
    #[prost(bool, tag = "4")]
    pub is_test: bool,
    /// how long is the period of the subscription
    #[prost(enumeration = "membership_tier_data::PeriodType", tag = "5")]
    pub period_type: i32,
    /// i.e. "5 days" or "3 years"
    #[prost(uint32, tag = "6")]
    pub period_value: u32,
    /// this one is a price we use ONLY on Stripe platform
    #[prost(uint32, tag = "7")]
    pub price_stripe_usd_cents: u32,
    /// number of ANY NS names that this tier includes
    /// also in the "features" list (see below)
    #[prost(uint32, tag = "8")]
    pub any_names_count_included: u32,
    /// somename.any - is of len 8
    #[prost(uint32, tag = "9")]
    pub any_name_min_length: u32,
    /// localized strings for the features
    #[prost(string, repeated, tag = "10")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// green, blue, red, purple, custom
    #[prost(string, tag = "11")]
    pub color_str: ::prost::alloc::string::String,
    /// Stripe platform-specific data:
    #[prost(string, tag = "12")]
    pub stripe_product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub stripe_manage_url: ::prost::alloc::string::String,
    /// iOS platform-specific data:
    #[prost(string, tag = "15")]
    pub ios_product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub ios_manage_url: ::prost::alloc::string::String,
    /// Android platform-specific data:
    #[prost(string, tag = "17")]
    pub android_product_id: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub android_manage_url: ::prost::alloc::string::String,
    /// "limited offer" or somehing like that
    #[prost(string, tag = "19")]
    pub offer: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MembershipTierData`.
pub mod membership_tier_data {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PeriodType {
        Unknown = 0,
        Unlimited = 1,
        Days = 2,
        Weeks = 3,
        Months = 4,
        Years = 5,
    }
    impl PeriodType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "PeriodTypeUnknown",
                Self::Unlimited => "PeriodTypeUnlimited",
                Self::Days => "PeriodTypeDays",
                Self::Weeks => "PeriodTypeWeeks",
                Self::Months => "PeriodTypeMonths",
                Self::Years => "PeriodTypeYears",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PeriodTypeUnknown" => Some(Self::Unknown),
                "PeriodTypeUnlimited" => Some(Self::Unlimited),
                "PeriodTypeDays" => Some(Self::Days),
                "PeriodTypeWeeks" => Some(Self::Weeks),
                "PeriodTypeMonths" => Some(Self::Months),
                "PeriodTypeYears" => Some(Self::Years),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MembershipV2 {}
/// Nested message and enum types in `MembershipV2`.
pub mod membership_v2 {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Amount {
        /// ISO 4217 currency code
        #[prost(string, tag = "1")]
        pub currency: ::prost::alloc::string::String,
        /// $0.01 = 1
        /// $1.00 = 100
        /// also supports negative amounts!
        /// some invoices can have negatice amount (refund)
        #[prost(int64, tag = "2")]
        pub amount_cents: i64,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Invoice {
        #[prost(uint64, tag = "1")]
        pub date: u64,
        #[prost(message, optional, tag = "2")]
        pub total: ::core::option::Option<Amount>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Features {
        #[prost(uint64, tag = "1")]
        pub storage_bytes: u64,
        #[prost(uint32, tag = "2")]
        pub space_readers: u32,
        #[prost(uint32, tag = "3")]
        pub space_writers: u32,
        #[prost(uint32, tag = "4")]
        pub shared_spaces: u32,
        #[prost(uint32, tag = "5")]
        pub team_seats: u32,
        #[prost(uint32, tag = "6")]
        pub any_name_count: u32,
        #[prost(uint32, tag = "7")]
        pub any_name_min_len: u32,
        #[prost(uint32, tag = "8")]
        pub private_spaces: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Product {
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
        #[prost(bool, tag = "4")]
        pub is_top_level: bool,
        #[prost(bool, tag = "5")]
        pub is_hidden: bool,
        /// isIntro flag can be used as follows:
        ///
        ///    1. if current user's top level product has isIntro flag ->
        ///       then you'd rather show a FULL list of all products
        ///       to enable upgrading from CURRENT product
        ///    1. but if current user's top level product has no isIntro flag ->
        ///       then it means that this plan was aquired and user need to control it.
        ///       then show "second screen" to control that product instead
        #[prost(bool, tag = "6")]
        pub is_intro: bool,
        /// isUpgradeable can be used as follows:
        ///
        /// if current user's top level product has isUpgradeable flag ->
        /// show incentives to buy something else
        #[prost(bool, tag = "7")]
        pub is_upgradeable: bool,
        #[prost(message, repeated, tag = "8")]
        pub prices_yearly: ::prost::alloc::vec::Vec<Amount>,
        #[prost(message, repeated, tag = "9")]
        pub prices_monthly: ::prost::alloc::vec::Vec<Amount>,
        /// green, blue, red, purple, custom, etc
        #[prost(string, tag = "10")]
        pub color_str: ::prost::alloc::string::String,
        #[prost(string, tag = "11")]
        pub offer: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "12")]
        pub features: ::core::option::Option<Features>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PurchaseInfo {
        #[prost(uint64, tag = "1")]
        pub date_started: u64,
        #[prost(uint64, tag = "2")]
        pub date_ends: u64,
        #[prost(bool, tag = "3")]
        pub is_auto_renew: bool,
        #[prost(enumeration = "Period", tag = "4")]
        pub period: i32,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ProductStatus {
        #[prost(enumeration = "product_status::Status", tag = "1")]
        pub status: i32,
    }
    /// Nested message and enum types in `ProductStatus`.
    pub mod product_status {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum Status {
            Unknown = 0,
            Pending = 1,
            Active = 2,
            PendingRequiresAnyNameAllocation = 3,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unknown => "StatusUnknown",
                    Self::Pending => "StatusPending",
                    Self::Active => "StatusActive",
                    Self::PendingRequiresAnyNameAllocation => {
                        "StatusPendingRequiresAnyNameAllocation"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "StatusUnknown" => Some(Self::Unknown),
                    "StatusPending" => Some(Self::Pending),
                    "StatusActive" => Some(Self::Active),
                    "StatusPendingRequiresAnyNameAllocation" => {
                        Some(Self::PendingRequiresAnyNameAllocation)
                    }
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PurchasedProduct {
        #[prost(message, optional, tag = "1")]
        pub product: ::core::option::Option<Product>,
        #[prost(message, optional, tag = "2")]
        pub purchase_info: ::core::option::Option<PurchaseInfo>,
        #[prost(message, optional, tag = "3")]
        pub product_status: ::core::option::Option<ProductStatus>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CartProduct {
        #[prost(message, optional, tag = "1")]
        pub product: ::core::option::Option<Product>,
        /// otherwise - monthly
        #[prost(bool, tag = "2")]
        pub is_yearly: bool,
        /// set to true if you want to remove this item from the customer
        /// it's like setting -1 to some product
        #[prost(bool, tag = "3")]
        pub remove: bool,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cart {
        /// if you add Nx the same product - it will be Nx in the 'products' array, i.e:
        /// each product instance has a unique index
        #[prost(message, repeated, tag = "1")]
        pub products: ::prost::alloc::vec::Vec<CartProduct>,
        /// total amount of the cart (including discounts, etc)
        #[prost(message, optional, tag = "2")]
        pub total: ::core::option::Option<Amount>,
        /// in case you are paying in the middle of the period (for existing customers)
        /// the next invoice amount will also be generated
        #[prost(message, optional, tag = "3")]
        pub total_next_invoice: ::core::option::Option<Amount>,
        #[prost(uint64, tag = "4")]
        pub next_invoice_date: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub products: ::prost::alloc::vec::Vec<PurchasedProduct>,
        #[prost(message, optional, tag = "2")]
        pub next_invoice: ::core::option::Option<Invoice>,
        #[prost(string, tag = "3")]
        pub team_owner_id: ::prost::alloc::string::String,
        #[prost(enumeration = "PaymentProvider", tag = "4")]
        pub payment_provider: i32,
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Platform {
        Unknown = 0,
        Desktop = 1,
        MobileIos = 2,
        MobileAndroid = 3,
        Web = 4,
    }
    impl Platform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "Unknown",
                Self::Desktop => "Desktop",
                Self::MobileIos => "MobileIOS",
                Self::MobileAndroid => "MobileAndroid",
                Self::Web => "Web",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unknown" => Some(Self::Unknown),
                "Desktop" => Some(Self::Desktop),
                "MobileIOS" => Some(Self::MobileIos),
                "MobileAndroid" => Some(Self::MobileAndroid),
                "Web" => Some(Self::Web),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum PaymentProvider {
        None = 0,
        Stripe = 1,
        Crypto = 2,
        BillingPortal = 3,
        AppStore = 4,
        GooglePlay = 5,
    }
    impl PaymentProvider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "None",
                Self::Stripe => "Stripe",
                Self::Crypto => "Crypto",
                Self::BillingPortal => "BillingPortal",
                Self::AppStore => "AppStore",
                Self::GooglePlay => "GooglePlay",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "None" => Some(Self::None),
                "Stripe" => Some(Self::Stripe),
                "Crypto" => Some(Self::Crypto),
                "BillingPortal" => Some(Self::BillingPortal),
                "AppStore" => Some(Self::AppStore),
                "GooglePlay" => Some(Self::GooglePlay),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Period {
        Unlimited = 0,
        Monthly = 1,
        Yearly = 2,
        ThreeYears = 3,
    }
    impl Period {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unlimited => "Unlimited",
                Self::Monthly => "Monthly",
                Self::Yearly => "Yearly",
                Self::ThreeYears => "ThreeYears",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "Unlimited" => Some(Self::Unlimited),
                "Monthly" => Some(Self::Monthly),
                "Yearly" => Some(Self::Yearly),
                "ThreeYears" => Some(Self::ThreeYears),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Detail {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// NUll - removes key
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<::prost_types::Value>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub add_date: i64,
    #[prost(bool, tag = "4")]
    pub archived: bool,
    #[prost(bool, tag = "5")]
    pub is_connected: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChatState {
    /// unread messages
    #[prost(message, optional, tag = "1")]
    pub messages: ::core::option::Option<chat_state::UnreadState>,
    /// unread mentions
    #[prost(message, optional, tag = "2")]
    pub mentions: ::core::option::Option<chat_state::UnreadState>,
    /// reflects the state of the chat db at the moment of sending response/event that includes this state
    #[prost(string, tag = "3")]
    pub last_state_id: ::prost::alloc::string::String,
    /// Order is serial number of this state. Client should apply chat state only if its order is greater than previously saved order
    #[prost(int64, tag = "4")]
    pub order: i64,
}
/// Nested message and enum types in `ChatState`.
pub mod chat_state {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UnreadState {
        /// oldest(in the lex sorting) unread message order id. Client should ALWAYS scroll through unread messages from the oldest to the newest
        #[prost(string, tag = "1")]
        pub oldest_order_id: ::prost::alloc::string::String,
        /// total number of unread messages
        #[prost(int32, tag = "2")]
        pub counter: i32,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatMessage {
    /// Unique message identifier
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Lexicographical id for message in order of tree traversal
    #[prost(string, tag = "2")]
    pub order_id: ::prost::alloc::string::String,
    /// Identifier for the message creator
    #[prost(string, tag = "3")]
    pub creator: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created_at: i64,
    #[prost(int64, tag = "9")]
    pub modified_at: i64,
    /// stateId is ever-increasing id (BSON ObjectId) for this message. Unlike orderId, this ID is ordered by the time messages are added. For example, it's useful to prevent accidental reading of messages from the past when a ChatReadMessages request is sent: a message from the past may appear, but the client is still unaware of it
    #[prost(string, tag = "11")]
    pub state_id: ::prost::alloc::string::String,
    /// Identifier for the message being replied to
    #[prost(string, tag = "5")]
    pub reply_to_message_id: ::prost::alloc::string::String,
    /// Message content
    #[prost(message, optional, tag = "6")]
    pub message: ::core::option::Option<chat_message::MessageContent>,
    /// Attachments slice
    #[prost(message, repeated, tag = "7")]
    pub attachments: ::prost::alloc::vec::Vec<chat_message::Attachment>,
    /// Reactions to the message
    #[prost(message, optional, tag = "8")]
    pub reactions: ::core::option::Option<chat_message::Reactions>,
    /// Message read status
    #[prost(bool, tag = "10")]
    pub read: bool,
    #[prost(bool, tag = "12")]
    pub mention_read: bool,
    #[prost(bool, tag = "14")]
    pub has_mention: bool,
    #[prost(bool, tag = "13")]
    pub synced: bool,
}
/// Nested message and enum types in `ChatMessage`.
pub mod chat_message {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MessageContent {
        /// The text content of the message part
        #[prost(string, tag = "1")]
        pub text: ::prost::alloc::string::String,
        /// The style/type of the message part
        #[prost(enumeration = "super::block::content::text::Style", tag = "2")]
        pub style: i32,
        /// List of marks applied to the text
        #[prost(message, repeated, tag = "3")]
        pub marks: ::prost::alloc::vec::Vec<super::block::content::text::Mark>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Attachment {
        /// Identifier for the attachment object
        #[prost(string, tag = "1")]
        pub target: ::prost::alloc::string::String,
        /// Type of attachment
        #[prost(enumeration = "attachment::AttachmentType", tag = "2")]
        pub r#type: i32,
    }
    /// Nested message and enum types in `Attachment`.
    pub mod attachment {
        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum AttachmentType {
            /// File attachment
            File = 0,
            /// Image attachment
            Image = 1,
            /// Link attachment
            Link = 2,
        }
        impl AttachmentType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::File => "FILE",
                    Self::Image => "IMAGE",
                    Self::Link => "LINK",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FILE" => Some(Self::File),
                    "IMAGE" => Some(Self::Image),
                    "LINK" => Some(Self::Link),
                    _ => None,
                }
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reactions {
        /// Map of emoji to list of user IDs
        #[prost(map = "string, message", tag = "1")]
        pub reactions:
            ::std::collections::HashMap<::prost::alloc::string::String, reactions::IdentityList>,
    }
    /// Nested message and enum types in `Reactions`.
    pub mod reactions {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct IdentityList {
            /// List of user IDs
            #[prost(string, repeated, tag = "1")]
            pub ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SmartBlockType {
    /// deprecated
    AccountOld = 0,
    Page = 16,
    ProfilePage = 17,
    Home = 32,
    Archive = 48,
    Widget = 112,
    File = 256,
    Template = 288,
    BundledTemplate = 289,
    /// DEPRECATED
    BundledRelation = 512,
    SubObject = 513,
    /// DEPRECATED
    BundledObjectType = 514,
    AnytypeProfile = 515,
    Date = 516,
    Workspace = 518,
    StRelation = 521,
    StType = 528,
    StRelationOption = 529,
    SpaceView = 530,
    Identity = 532,
    Participant = 534,
    MissingObject = 519,
    FileObject = 533,
    NotificationObject = 535,
    DevicesObject = 536,
    /// DEPRECATED Container for any-store based chats
    ChatObjectDeprecated = 537,
    /// Any-store based object for chat
    ChatDerivedObject = 544,
    /// Container for account data in tech space
    AccountObject = 545,
}
impl SmartBlockType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AccountOld => "AccountOld",
            Self::Page => "Page",
            Self::ProfilePage => "ProfilePage",
            Self::Home => "Home",
            Self::Archive => "Archive",
            Self::Widget => "Widget",
            Self::File => "File",
            Self::Template => "Template",
            Self::BundledTemplate => "BundledTemplate",
            Self::BundledRelation => "BundledRelation",
            Self::SubObject => "SubObject",
            Self::BundledObjectType => "BundledObjectType",
            Self::AnytypeProfile => "AnytypeProfile",
            Self::Date => "Date",
            Self::Workspace => "Workspace",
            Self::StRelation => "STRelation",
            Self::StType => "STType",
            Self::StRelationOption => "STRelationOption",
            Self::SpaceView => "SpaceView",
            Self::Identity => "Identity",
            Self::Participant => "Participant",
            Self::MissingObject => "MissingObject",
            Self::FileObject => "FileObject",
            Self::NotificationObject => "NotificationObject",
            Self::DevicesObject => "DevicesObject",
            Self::ChatObjectDeprecated => "ChatObjectDeprecated",
            Self::ChatDerivedObject => "ChatDerivedObject",
            Self::AccountObject => "AccountObject",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AccountOld" => Some(Self::AccountOld),
            "Page" => Some(Self::Page),
            "ProfilePage" => Some(Self::ProfilePage),
            "Home" => Some(Self::Home),
            "Archive" => Some(Self::Archive),
            "Widget" => Some(Self::Widget),
            "File" => Some(Self::File),
            "Template" => Some(Self::Template),
            "BundledTemplate" => Some(Self::BundledTemplate),
            "BundledRelation" => Some(Self::BundledRelation),
            "SubObject" => Some(Self::SubObject),
            "BundledObjectType" => Some(Self::BundledObjectType),
            "AnytypeProfile" => Some(Self::AnytypeProfile),
            "Date" => Some(Self::Date),
            "Workspace" => Some(Self::Workspace),
            "STRelation" => Some(Self::StRelation),
            "STType" => Some(Self::StType),
            "STRelationOption" => Some(Self::StRelationOption),
            "SpaceView" => Some(Self::SpaceView),
            "Identity" => Some(Self::Identity),
            "Participant" => Some(Self::Participant),
            "MissingObject" => Some(Self::MissingObject),
            "FileObject" => Some(Self::FileObject),
            "NotificationObject" => Some(Self::NotificationObject),
            "DevicesObject" => Some(Self::DevicesObject),
            "ChatObjectDeprecated" => Some(Self::ChatObjectDeprecated),
            "ChatDerivedObject" => Some(Self::ChatDerivedObject),
            "AccountObject" => Some(Self::AccountObject),
            _ => None,
        }
    }
}
/// RelationFormat describes how the underlying data is stored in the google.protobuf.Value and how it should be validated/sanitized
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RelationFormat {
    /// string
    Longtext = 0,
    /// string, usually short enough. May be truncated in the future
    Shorttext = 1,
    /// double
    Number = 2,
    /// string or list of string(len==1)
    Status = 3,
    /// list of string (choose multiple from a list)
    Tag = 11,
    /// float64(pb.Value doesn't have int64) or the string
    Date = 4,
    /// relation can has objects of specific types: file, image, audio, video
    File = 5,
    /// boolean
    Checkbox = 6,
    /// string with sanity check
    Url = 7,
    /// string with sanity check
    Email = 8,
    /// string with sanity check
    Phone = 9,
    /// one emoji, can contains multiple utf-8 symbols
    Emoji = 10,
    /// relation can has objectType to specify objectType
    Object = 100,
    /// base64-encoded relation pb model
    Relations = 101,
}
impl RelationFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Longtext => "longtext",
            Self::Shorttext => "shorttext",
            Self::Number => "number",
            Self::Status => "status",
            Self::Tag => "tag",
            Self::Date => "date",
            Self::File => "file",
            Self::Checkbox => "checkbox",
            Self::Url => "url",
            Self::Email => "email",
            Self::Phone => "phone",
            Self::Emoji => "emoji",
            Self::Object => "object",
            Self::Relations => "relations",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "longtext" => Some(Self::Longtext),
            "shorttext" => Some(Self::Shorttext),
            "number" => Some(Self::Number),
            "status" => Some(Self::Status),
            "tag" => Some(Self::Tag),
            "date" => Some(Self::Date),
            "file" => Some(Self::File),
            "checkbox" => Some(Self::Checkbox),
            "url" => Some(Self::Url),
            "email" => Some(Self::Email),
            "phone" => Some(Self::Phone),
            "emoji" => Some(Self::Emoji),
            "object" => Some(Self::Object),
            "relations" => Some(Self::Relations),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ObjectOrigin {
    None = 0,
    Clipboard = 1,
    DragAndDrop = 2,
    Import = 3,
    Webclipper = 4,
    SharingExtension = 5,
    Usecase = 6,
    Builtin = 7,
    Bookmark = 8,
    Api = 9,
}
impl ObjectOrigin {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "none",
            Self::Clipboard => "clipboard",
            Self::DragAndDrop => "dragAndDrop",
            Self::Import => "import",
            Self::Webclipper => "webclipper",
            Self::SharingExtension => "sharingExtension",
            Self::Usecase => "usecase",
            Self::Builtin => "builtin",
            Self::Bookmark => "bookmark",
            Self::Api => "api",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "none" => Some(Self::None),
            "clipboard" => Some(Self::Clipboard),
            "dragAndDrop" => Some(Self::DragAndDrop),
            "import" => Some(Self::Import),
            "webclipper" => Some(Self::Webclipper),
            "sharingExtension" => Some(Self::SharingExtension),
            "usecase" => Some(Self::Usecase),
            "builtin" => Some(Self::Builtin),
            "bookmark" => Some(Self::Bookmark),
            "api" => Some(Self::Api),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpaceStatus {
    /// Unknown means the space is not loaded yet
    Unknown = 0,
    /// Loading - the space in progress of loading
    Loading = 1,
    /// Ok - the space loaded and available
    Ok = 2,
    /// Missing - the space is missing
    Missing = 3,
    /// Error - the space loading ended with an error
    Error = 4,
    /// RemoteWaitingDeletion - network status is "waiting deletion"
    RemoteWaitingDeletion = 5,
    /// RemoteDeleted - the space is deleted in the current network
    RemoteDeleted = 6,
    /// SpaceDeleted - the space should be deleted in the network
    SpaceDeleted = 7,
    /// SpaceActive - the space is active in the network
    SpaceActive = 8,
    /// SpaceJoining - the account is joining the space
    SpaceJoining = 9,
    /// SpaceRemoving - the account is removing from space or the space is removed from network
    SpaceRemoving = 10,
}
impl SpaceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Loading => "Loading",
            Self::Ok => "Ok",
            Self::Missing => "Missing",
            Self::Error => "Error",
            Self::RemoteWaitingDeletion => "RemoteWaitingDeletion",
            Self::RemoteDeleted => "RemoteDeleted",
            Self::SpaceDeleted => "SpaceDeleted",
            Self::SpaceActive => "SpaceActive",
            Self::SpaceJoining => "SpaceJoining",
            Self::SpaceRemoving => "SpaceRemoving",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Loading" => Some(Self::Loading),
            "Ok" => Some(Self::Ok),
            "Missing" => Some(Self::Missing),
            "Error" => Some(Self::Error),
            "RemoteWaitingDeletion" => Some(Self::RemoteWaitingDeletion),
            "RemoteDeleted" => Some(Self::RemoteDeleted),
            "SpaceDeleted" => Some(Self::SpaceDeleted),
            "SpaceActive" => Some(Self::SpaceActive),
            "SpaceJoining" => Some(Self::SpaceJoining),
            "SpaceRemoving" => Some(Self::SpaceRemoving),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParticipantPermissions {
    Reader = 0,
    Writer = 1,
    Owner = 2,
    NoPermissions = 3,
}
impl ParticipantPermissions {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Reader => "Reader",
            Self::Writer => "Writer",
            Self::Owner => "Owner",
            Self::NoPermissions => "NoPermissions",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Reader" => Some(Self::Reader),
            "Writer" => Some(Self::Writer),
            "Owner" => Some(Self::Owner),
            "NoPermissions" => Some(Self::NoPermissions),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InviteType {
    /// aclKey contains the key to sign the ACL record
    Member = 0,
    /// guestKey contains the privateKey of the guest user
    Guest = 1,
    /// aclKey contains the key to sign the ACL record, but no approval needed
    WithoutApprove = 2,
}
impl InviteType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Member => "Member",
            Self::Guest => "Guest",
            Self::WithoutApprove => "WithoutApprove",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Member" => Some(Self::Member),
            "Guest" => Some(Self::Guest),
            "WithoutApprove" => Some(Self::WithoutApprove),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParticipantStatus {
    Joining = 0,
    Active = 1,
    Removed = 2,
    Declined = 3,
    Removing = 4,
    Canceled = 5,
}
impl ParticipantStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Joining => "Joining",
            Self::Active => "Active",
            Self::Removed => "Removed",
            Self::Declined => "Declined",
            Self::Removing => "Removing",
            Self::Canceled => "Canceled",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Joining" => Some(Self::Joining),
            "Active" => Some(Self::Active),
            "Removed" => Some(Self::Removed),
            "Declined" => Some(Self::Declined),
            "Removing" => Some(Self::Removing),
            "Canceled" => Some(Self::Canceled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpaceAccessType {
    Private = 0,
    Personal = 1,
    Shared = 2,
}
impl SpaceAccessType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Private => "Private",
            Self::Personal => "Personal",
            Self::Shared => "Shared",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Private" => Some(Self::Private),
            "Personal" => Some(Self::Personal),
            "Shared" => Some(Self::Shared),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpaceUxType {
    /// old value for chat, deprecated
    None = 0,
    /// objects-first UX
    Data = 1,
    /// stream UX (chat with limited amount of owners)
    Stream = 2,
    /// chat UX
    Chat = 3,
    /// onetoone UX (space with chat and immutable ACL between two participants)
    OneToOne = 4,
}
impl SpaceUxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "None",
            Self::Data => "Data",
            Self::Stream => "Stream",
            Self::Chat => "Chat",
            Self::OneToOne => "OneToOne",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "None" => Some(Self::None),
            "Data" => Some(Self::Data),
            "Stream" => Some(Self::Stream),
            "Chat" => Some(Self::Chat),
            "OneToOne" => Some(Self::OneToOne),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImageKind {
    Basic = 0,
    Cover = 1,
    Icon = 2,
    AutomaticallyAdded = 3,
}
impl ImageKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Basic => "Basic",
            Self::Cover => "Cover",
            Self::Icon => "Icon",
            Self::AutomaticallyAdded => "AutomaticallyAdded",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Basic" => Some(Self::Basic),
            "Cover" => Some(Self::Cover),
            "Icon" => Some(Self::Icon),
            "AutomaticallyAdded" => Some(Self::AutomaticallyAdded),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileIndexingStatus {
    NotIndexed = 0,
    Indexed = 1,
    NotFound = 2,
}
impl FileIndexingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotIndexed => "NotIndexed",
            Self::Indexed => "Indexed",
            Self::NotFound => "NotFound",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NotIndexed" => Some(Self::NotIndexed),
            "Indexed" => Some(Self::Indexed),
            "NotFound" => Some(Self::NotFound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpaceShareableStatus {
    StatusUnknown = 0,
    StatusShareable = 1,
    StatusNotShareable = 2,
}
impl SpaceShareableStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StatusUnknown => "StatusUnknown",
            Self::StatusShareable => "StatusShareable",
            Self::StatusNotShareable => "StatusNotShareable",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "StatusUnknown" => Some(Self::StatusUnknown),
            "StatusShareable" => Some(Self::StatusShareable),
            "StatusNotShareable" => Some(Self::StatusNotShareable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NameserviceNameType {
    /// .any suffix
    AnyName = 0,
}
impl NameserviceNameType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AnyName => "AnyName",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AnyName" => Some(Self::AnyName),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceNetworkType {
    Wifi = 0,
    Cellular = 1,
    NotConnected = 2,
}
impl DeviceNetworkType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Wifi => "WIFI",
            Self::Cellular => "CELLULAR",
            Self::NotConnected => "NOT_CONNECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WIFI" => Some(Self::Wifi),
            "CELLULAR" => Some(Self::Cellular),
            "NOT_CONNECTED" => Some(Self::NotConnected),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncStatus {
    Synced = 0,
    Syncing = 1,
    Error = 2,
    Queued = 3,
}
impl SyncStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Synced => "SyncStatusSynced",
            Self::Syncing => "SyncStatusSyncing",
            Self::Error => "SyncStatusError",
            Self::Queued => "SyncStatusQueued",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SyncStatusSynced" => Some(Self::Synced),
            "SyncStatusSyncing" => Some(Self::Syncing),
            "SyncStatusError" => Some(Self::Error),
            "SyncStatusQueued" => Some(Self::Queued),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SyncError {
    Null = 0,
    IncompatibleVersion = 2,
    NetworkError = 3,
    Oversized = 4,
}
impl SyncError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Null => "SyncErrorNull",
            Self::IncompatibleVersion => "SyncErrorIncompatibleVersion",
            Self::NetworkError => "SyncErrorNetworkError",
            Self::Oversized => "SyncErrorOversized",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SyncErrorNull" => Some(Self::Null),
            "SyncErrorIncompatibleVersion" => Some(Self::IncompatibleVersion),
            "SyncErrorNetworkError" => Some(Self::NetworkError),
            "SyncErrorOversized" => Some(Self::Oversized),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TemplateNamePrefillType {
    Empty = 0,
    FromTemplateName = 1,
}
impl TemplateNamePrefillType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Empty => "Empty",
            Self::FromTemplateName => "FromTemplateName",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Empty" => Some(Self::Empty),
            "FromTemplateName" => Some(Self::FromTemplateName),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// DEPRECATED
    #[prost(string, repeated, tag = "2")]
    pub object_type_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<::prost_types::Struct>,
    /// DEPRECATED
    #[prost(message, repeated, tag = "4")]
    pub relations: ::prost::alloc::vec::Vec<Relation>,
    #[prost(string, tag = "5")]
    pub snippet: ::prost::alloc::string::String,
    /// DEPRECATED
    #[prost(bool, tag = "6")]
    pub has_inbound_links: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectDetails {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<::prost_types::Struct>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObjectLinks {
    #[prost(string, repeated, tag = "1")]
    pub inbound_i_ds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub outbound_i_ds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectLinksInfo {
    #[prost(message, repeated, tag = "1")]
    pub inbound: ::prost::alloc::vec::Vec<ObjectInfo>,
    #[prost(message, repeated, tag = "2")]
    pub outbound: ::prost::alloc::vec::Vec<ObjectInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectInfoWithLinks {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<ObjectInfo>,
    #[prost(message, optional, tag = "3")]
    pub links: ::core::option::Option<ObjectLinksInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectInfoWithOutboundLinks {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<ObjectInfo>,
    #[prost(message, repeated, tag = "3")]
    pub outbound_links: ::prost::alloc::vec::Vec<ObjectInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObjectInfoWithOutboundLinksIDs {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<ObjectInfo>,
    #[prost(string, repeated, tag = "3")]
    pub outbound_links: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObjectStoreChecksums {
    #[prost(string, tag = "1")]
    pub bundled_object_types: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub bundled_relations: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub bundled_layouts: ::prost::alloc::string::String,
    /// increased in order to trigger all objects reindex
    #[prost(int32, tag = "4")]
    pub objects_force_reindex_counter: i32,
    /// increased in order to fully reindex all objects
    #[prost(int32, tag = "5")]
    pub files_force_reindex_counter: i32,
    /// increased in order to remove indexes and reindex everything. Automatically triggers objects and files reindex(one time only)
    #[prost(int32, tag = "6")]
    pub idx_rebuild_counter: i32,
    /// DEPRECATED increased in order to perform fulltext indexing for all type of objects (useful when we change fulltext config)
    #[prost(int32, tag = "7")]
    pub fulltext_rebuild: i32,
    /// DEPRECATED remove all the fulltext indexes and add to reindex queue after
    #[prost(int32, tag = "11")]
    pub fulltext_erase: i32,
    #[prost(string, tag = "8")]
    pub bundled_templates: ::prost::alloc::string::String,
    /// anytypeProfile and maybe some others in the feature
    #[prost(int32, tag = "9")]
    pub bundled_objects: i32,
    #[prost(int32, tag = "10")]
    pub filestore_keys_force_reindex_counter: i32,
    #[prost(bool, tag = "12")]
    pub are_old_files_removed: bool,
    /// DEPRECATED
    #[prost(bool, tag = "13")]
    pub are_deleted_objects_reindexed: bool,
    #[prost(int32, tag = "14")]
    pub links_erase: i32,
    #[prost(int32, tag = "15")]
    pub marketplace_force_reindex_counter: i32,
    #[prost(int32, tag = "16")]
    pub reindex_deleted_objects: i32,
    #[prost(int32, tag = "17")]
    pub reindex_participants: i32,
    #[prost(int32, tag = "18")]
    pub reindex_chats: i32,
    #[prost(int32, tag = "19")]
    pub reindex_fulltext_chat_messages: i32,
    #[prost(int32, tag = "20")]
    pub invalidate_objects_index: i32,
}
